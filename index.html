<!DOCTYPE html>
<html lang="en">
<head>
    <!-- 
        SailAI - Sailing Performance Coach
        Version: 0.9.38-PRO-v11-FINAL
        Date: February 14, 2026
        Update: STORAGE QUOTA FIX - Sessions now save summary metrics only (not full CSV). Smaller storage, perfect for comparison!
        Author: Mike Bonham
        Repository: https://github.com/mjbonham-boop/SailAI
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SailAI - Performance Analysis</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
        #map { background: #1f2937; min-height: 600px; }
        #map.clickable { cursor: crosshair; }
        .chart-container { position: relative; height: 350px; width: 100%; }
        .metric-card { transition: transform 0.2s; }
        .metric-card:hover { transform: translateY(-2px); }
        .coaching-tip { border-left: 4px solid #10B981; }
        .mark-controls { position: absolute; top: 10px; right: 10px; z-index: 1000; }
        
        /* Layer Toggle Controls */
        .layer-toggles {
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid #4B5563;
            border-radius: 8px;
            padding: 8px;
            margin-top: 8px;
        }
        .layer-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 6px 10px;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.2s;
            cursor: pointer;
            border: none;
            margin-bottom: 4px;
        }
        .layer-toggle-btn.active {
            background: #3B82F6;
            color: white;
        }
        .layer-toggle-btn.inactive {
            background: #374151;
            color: #9CA3AF;
        }
        .layer-toggle-btn:hover {
            transform: translateX(-2px);
        }
        
        /* Help System Styles */
        .help-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background: #374151;
            color: #9CA3AF;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            margin-left: 6px;
            transition: all 0.2s;
            vertical-align: middle;
        }
        
        .help-icon:hover {
            background: #4B5563;
            color: #60A5FA;
            transform: scale(1.1);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 340px;
            background-color: #1F2937;
            color: #F3F4F6;
            text-align: left;
            border-radius: 8px;
            padding: 14px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -170px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #60A5FA;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            font-size: 13px;
            line-height: 1.6;
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #1F2937 transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .help-section {
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .help-section summary {
            cursor: pointer;
            font-weight: 600;
            color: #60A5FA;
            user-select: none;
        }
        
        .help-section summary:hover {
            color: #93C5FD;
        }
        
        .help-section p {
            margin-top: 8px;
            color: #D1D5DB;
        }
        
        .help-section ul {
            margin-top: 8px;
            margin-left: 20px;
            color: #D1D5DB;
        }
        
        .help-section li {
            margin-top: 4px;
        }
        
        .help-section code {
            background: #374151;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            color: #FCD34D;
        }
        
        .metric-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            margin-left: 8px;
            vertical-align: middle;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .badge-excellent { background: #065F46; color: #6EE7B7; }
        .badge-good { background: #1E3A8A; color: #93C5FD; }
        .badge-moderate { background: #78350F; color: #FCD34D; }
        .badge-poor { background: #7F1D1D; color: #FCA5A5; }
    
        /* Mobile Responsive Styles */
        #sidebar {
            transition: transform 0.3s ease-in-out;
        }
        
        #mobileMenuBtn {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: #1F2937;
            border: 2px solid #60A5FA;
            border-radius: 0.5rem;
            padding: 0.75rem;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        #mobileMenuBtn:hover {
            background: #374151;
        }
        
        #mobileOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        
        @media screen and (max-width: 768px) {
            #mobileMenuBtn {
                display: block;
            }
            
            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 1000;
                transform: translateX(-100%);
                width: 85vw;
                max-width: 360px;
                padding-top: 4.5rem !important; /* Space for mobile menu button */
            }
            
            #sidebar.open {
                transform: translateX(0);
            }
            
            #mobileOverlay.active {
                display: block;
            }
            
            #mainContent {
                padding: 1rem !important;
                padding-top: 4rem !important;
                background-color: #111827 !important; /* Force dark background on mobile */
                min-height: 100vh;
            }
            
            /* Stack charts vertically on mobile */
            .grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Enhanced mobile button styling */
            button {
                min-height: 48px !important;
                font-size: 16px !important;
                font-weight: 600 !important;
                transition: all 0.15s ease !important;
                touch-action: manipulation; /* Prevents double-tap zoom */
            }
            
            /* Visual feedback when tapping buttons */
            button:active {
                transform: scale(0.97) !important;
                opacity: 0.9 !important;
            }
            
            /* Make Auto-Detect and Add Race buttons more prominent */
            #autoDetectRaces {
                padding: 0.875rem 1.25rem !important;
                font-size: 1.125rem !important;
                min-height: 52px !important;
            }
            
            #addRace {
                padding: 0.875rem 1.25rem !important;
                font-size: 1rem !important;
                min-height: 52px !important;
            }
            
            /* Ensure PDF buttons are prominent and easy to tap */
            #generatePDF, #pdfButtonMain {
                min-height: 52px !important;
                font-size: 1.125rem !important;
                padding: 0.875rem 1.25rem !important;
            }
            
            /* Slider labels bigger */
            input[type="range"] + label,
            label[for] {
                font-size: 1rem !important;
                font-weight: 600 !important;
            }
            
            input[type="range"] {
                height: 44px !important;
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
            }
            
            /* Slider track */
            input[type="range"]::-webkit-slider-track {
                height: 8px;
                background: linear-gradient(to right, #3b82f6, #60a5fa);
                border-radius: 4px;
                border: none;
            }
            
            input[type="range"]::-moz-range-track {
                height: 8px;
                background: linear-gradient(to right, #3b82f6, #60a5fa);
                border-radius: 4px;
                border: none;
            }
            
            /* Slider thumb - BIGGER for mobile */
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: white;
                border: 3px solid #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                margin-top: -10px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: white;
                border: 3px solid #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            }
            
            /* Active state - visual feedback when dragging */
            input[type="range"]:active::-webkit-slider-thumb {
                background: #60a5fa;
                transform: scale(1.1);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.2);
            }
            
            input[type="range"]:active::-moz-range-thumb {
                background: #60a5fa;
                transform: scale(1.1);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.2);
            }
            
            /* Readable text */
            body {
                font-size: 16px;
            }
            
            /* Responsive charts */
            .chart-container {
                height: 250px !important;
            }
            
            /* Better spacing on mobile */
            .mb-8 {
                margin-bottom: 1.5rem !important;
            }
            
            .p-6 {
                padding: 1rem !important;
            }
        }
        
        /* Tooltip Styles */
        .tooltip-container {
            position: relative;
            display: inline-block;
            margin-left: 4px;
        }
        
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            border-radius: 50%;
            color: #60A5FA;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            transition: all 0.2s;
        }
        
        .tooltip-icon:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #60A5FA;
            transform: scale(1.1);
        }
        
        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
            pointer-events: none;
        }
        
        .tooltip-content::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: #1F2937;
        }
        
        .tooltip-container:hover .tooltip-content,
        .tooltip-container.active .tooltip-content {
            visibility: visible;
            opacity: 1;
        }
        
        .tooltip-content strong {
            color: #60A5FA;
            display: block;
            margin-bottom: 6px;
            font-size: 14px;
        }
        
        .tooltip-content p {
            color: #D1D5DB;
            font-size: 13px;
            line-height: 1.5;
            margin: 0;
        }
        
        /* Mobile tooltip adjustments */
        @media (max-width: 768px) {
            .tooltip-content {
                width: 200px;
                font-size: 12px;
            }
            
            .tooltip-icon {
                width: 20px;
                height: 20px;
            }
        }
        
        /* Section Dividers & Visual Polish */
        .section-divider {
            height: 2px;
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.5), transparent);
            margin: 2rem 0;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .section-header::before,
        .section-header::after {
            content: '';
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(59, 130, 246, 0.3));
        }
        
        .section-header::after {
            background: linear-gradient(to left, transparent, rgba(59, 130, 246, 0.3));
        }
        
        /* Enhanced Card Shadows */
        .metric-card {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }
        
        /* Improved Button Styling */
        button:not(.tooltip-icon) {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
            font-weight: 600;
        }
        
        button:not(.tooltip-icon):hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        button:not(.tooltip-icon):active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        
        /* Better Container Styling */
        .bg-gray-800 {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* Improved Text Contrast */
        .text-gray-400 {
            color: #9CA3AF !important;
        }
        
        .text-gray-300 {
            color: #D1D5DB !important;
        }
        
        /* Section Title Styling */
        h3 {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            letter-spacing: 0.025em;
        }
        
        /* Gradient Accents */
        .gradient-accent {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1));
            border-left: 3px solid rgba(59, 130, 246, 0.5);
        }
        
        /* Tab Navigation Styles */
        .tab-navigation {
            background: #1F2937;
            border-bottom: 1px solid #374151;
            position: sticky;
            top: 0;
            z-index: 900;
        }
        .tab-button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #9CA3AF;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .tab-button:hover {
            color: #E5E7EB;
            background: rgba(55, 65, 81, 0.3);
        }
        .tab-button.active {
            color: #3B82F6;
            border-bottom-color: #3B82F6;
        }
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }
        .tab-content.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Mobile tab scrolling */
        @media (max-width: 768px) {
            .tab-button {
                padding: 10px 16px;
                font-size: 13px;
            }
        }
        
        /* ============================================
         * PROFESSIONAL THEME OVERRIDES v2
         * Comprehensive color and typography fixes
         * One consistent navy/gray scheme, no random colors
         * Bigger, bolder, more readable fonts
         * ============================================ */
        
        /* === CONSISTENT NAVY COLOR SCHEME === */
        
        /* Replace ALL blues with one consistent navy */
        .bg-blue-900, .bg-blue-800, .bg-blue-700, .bg-blue-600 { 
            background-color: #1E3A5F !important;  /* Darker navy for cards */
        }
        .border-blue-900, .border-blue-800, .border-blue-700, .border-blue-600 {
            border-color: #0C4A6E !important;
        }
        .text-blue-400, .text-blue-300, .text-blue-200 {
            color: #60A5FA !important;  /* Light blue for highlights */
            font-weight: 700 !important;
        }
        
        /* Replace ALL purple with navy */
        .bg-purple-900, .bg-purple-800, .bg-purple-700, .bg-purple-600 { 
            background-color: #1E3A5F !important; 
        }
        .border-purple-700, .border-purple-600 {
            border-color: #0C4A6E !important;
        }
        .text-purple-400, .text-purple-300 { 
            color: #60A5FA !important;
            font-weight: 700 !important;
        }
        
        /* Replace ALL orange/yellow/amber with consistent colors */
        .bg-orange-900, .bg-orange-800, .bg-yellow-900, .bg-amber-900 {
            background-color: #374151 !important;
        }
        .border-orange-600, .border-yellow-600, .border-amber-600 {
            border-color: #4B5563 !important;
        }
        .text-orange-400, .text-orange-300, .text-yellow-400, .text-yellow-300, .text-amber-400 {
            color: #60A5FA !important;
            font-weight: 700 !important;
        }
        
        /* Replace ALL red with consistent colors */
        .bg-red-900, .bg-red-800 {
            background-color: rgba(220, 38, 38, 0.15) !important;  /* Subtle red for errors */
        }
        .border-red-600, .border-red-700 {
            border-color: #DC2626 !important;
        }
        .text-red-400, .text-red-300 {
            color: #F87171 !important;
            font-weight: 700 !important;
        }
        
        /* Replace ALL green with consistent colors */
        .bg-green-900, .bg-green-800 {
            background-color: rgba(5, 150, 105, 0.15) !important;  /* Subtle green for success */
        }
        .border-green-600, .border-green-700 {
            border-color: #059669 !important;
        }
        .text-green-400, .text-green-300 {
            color: #34D399 !important;
            font-weight: 700 !important;
        }
        
        /* === MUCH BIGGER, BOLDER FONTS === */
        
        /* Main metric numbers - HUGE and bold */
        .text-5xl {
            font-size: 4rem !important;  /* 64px */
            font-weight: 900 !important;
            line-height: 1 !important;
            color: #60A5FA !important;
        }
        
        .text-4xl {
            font-size: 3rem !important;  /* 48px */
            font-weight: 900 !important;
            line-height: 1.1 !important;
            color: #60A5FA !important;
        }
        
        .text-3xl {
            font-size: 2.5rem !important;  /* 40px */
            font-weight: 800 !important;
            line-height: 1.2 !important;
            color: #60A5FA !important;
        }
        
        .text-2xl { 
            font-size: 1.75rem !important;  /* 28px */
            font-weight: 700 !important;
            color: #E5E7EB !important;
        }
        
        .text-xl {
            font-size: 1.25rem !important;  /* 20px */
            font-weight: 600 !important;
        }
        
        /* Headers - prominent */
        h1, h2, h3 {
            font-weight: 700 !important;
            color: #F3F4F6 !important;
        }
        
        h4, h5, h6 {
            font-weight: 600 !important;
            color: #E5E7EB !important;
        }
        
        /* === BETTER TEXT READABILITY === */
        
        /* Labels and secondary text - easier to read */
        .text-sm {
            font-size: 0.95rem !important;  /* Slightly bigger */
            font-weight: 500 !important;
        }
        
        .text-xs {
            font-size: 0.85rem !important;  /* Slightly bigger */
            font-weight: 500 !important;
        }
        
        /* Gray text - better contrast */
        .text-gray-400 {
            color: #9CA3AF !important;  /* Lighter gray - more readable */
            font-weight: 500 !important;
        }
        
        .text-gray-500 {
            color: #9CA3AF !important;
            font-weight: 500 !important;
        }
        
        .text-gray-300 {
            color: #D1D5DB !important;  /* Even lighter */
            font-weight: 500 !important;
        }
        
        .text-gray-200 {
            color: #E5E7EB !important;
            font-weight: 500 !important;
        }
        
        /* White text - ensure it's actually white */
        .text-white {
            color: #FFFFFF !important;
        }
        
        /* === PROFESSIONAL BADGES === */
        
        /* All badges consistent style */
        .bg-red-900.text-red-300, 
        .bg-yellow-900.text-yellow-300, 
        .bg-green-900.text-green-300,
        .bg-blue-900.text-blue-300 {
            background-color: rgba(96, 165, 250, 0.15) !important;
            color: #60A5FA !important;
            border: 1px solid #60A5FA !important;
            font-weight: 700 !important;
            padding: 0.25rem 0.75rem !important;
            border-radius: 6px !important;
        }
        
        /* === CARD IMPROVEMENTS === */
        
        .bg-gray-800 { 
            padding: 1.25rem !important;
            background-color: #1F2937 !important;  /* Consistent dark background */
        }
        
        .bg-gray-700 {
            background-color: #374151 !important;
        }
        
        /* === TAB STYLING === */
        
        .tab-button.active {
            border-bottom-color: #60A5FA !important;
            color: #60A5FA !important;
            font-weight: 700 !important;
        }
        
        /* === BUTTONS === */
        
        button, .button {
            font-weight: 600 !important;
        }
        
        .bg-green-600 {
            background-color: #059669 !important;
        }
        
        .bg-green-600:hover {
            background-color: #047857 !important;
        }
        
        .bg-blue-600 {
            background-color: #0C4A6E !important;
        }
        
        .bg-blue-600:hover {
            background-color: #0369A1 !important;
        }
        
        /* ============================================
         * PROFESSIONAL SPACING SYSTEM - Change 3
         * 8px-based consistent spacing for visual hierarchy
         * More breathing room, better organization
         * ============================================ */
        
        /* === CARD SPACING === */
        
        /* Main metric cards - generous padding */
        .metric-card {
            padding: 1.5rem !important;  /* 24px */
        }
        
        /* Card grids - consistent gaps */
        .grid {
            gap: 1rem !important;  /* 16px between cards */
        }
        
        /* Section backgrounds */
        .bg-gray-800, .bg-gray-700 {
            padding: 1.5rem !important;  /* 24px */
            margin-bottom: 1.5rem !important;  /* 24px */
        }
        
        /* === SECTION SPACING === */
        
        /* Large section breaks */
        .mb-8 {
            margin-bottom: 3rem !important;  /* 48px - bigger breaks between major sections */
        }
        
        /* Medium section breaks */
        .mb-6 {
            margin-bottom: 2rem !important;  /* 32px */
        }
        
        /* Small section breaks */
        .mb-4 {
            margin-bottom: 1.5rem !important;  /* 24px */
        }
        
        /* Tiny breaks */
        .mb-3, .mb-2 {
            margin-bottom: 1rem !important;  /* 16px */
        }
        
        /* === TEXT SPACING === */
        
        /* Headers - more breathing room */
        h1, h2, h3, h4, h5, h6 {
            margin-bottom: 1rem !important;  /* 16px below headers */
            line-height: 1.3 !important;  /* Tighter line height for headers */
        }
        
        /* Paragraphs - readable spacing */
        p {
            line-height: 1.6 !important;  /* 1.6 for body text readability */
            margin-bottom: 1rem !important;  /* 16px between paragraphs */
        }
        
        /* Lists - better spacing */
        ul, ol {
            margin-bottom: 1rem !important;
            padding-left: 1.5rem !important;
        }
        
        li {
            margin-bottom: 0.5rem !important;  /* 8px between list items */
            line-height: 1.6 !important;
        }
        
        /* === PADDING SYSTEM === */
        
        /* Standard padding sizes */
        .p-6 {
            padding: 1.5rem !important;  /* 24px */
        }
        
        .p-4 {
            padding: 1rem !important;  /* 16px */
        }
        
        .p-3 {
            padding: 0.75rem !important;  /* 12px */
        }
        
        .p-2 {
            padding: 0.5rem !important;  /* 8px */
        }
        
        /* Vertical padding */
        .py-6 {
            padding-top: 1.5rem !important;
            padding-bottom: 1.5rem !important;
        }
        
        .py-4 {
            padding-top: 1rem !important;
            padding-bottom: 1rem !important;
        }
        
        /* Horizontal padding */
        .px-6 {
            padding-left: 1.5rem !important;
            padding-right: 1.5rem !important;
        }
        
        .px-4 {
            padding-left: 1rem !important;
            padding-right: 1rem !important;
        }
        
        /* === GAP SYSTEM === */
        
        /* Flexbox/Grid gaps */
        .gap-6 {
            gap: 1.5rem !important;  /* 24px */
        }
        
        .gap-4 {
            gap: 1rem !important;  /* 16px */
        }
        
        .gap-3 {
            gap: 0.75rem !important;  /* 12px */
        }
        
        .gap-2 {
            gap: 0.5rem !important;  /* 8px */
        }
        
        /* === COMPONENT-SPECIFIC SPACING === */
        
        /* Tab buttons - comfortable touch targets */
        .tab-button {
            padding: 0.75rem 1rem !important;  /* 12px vertical, 16px horizontal */
            margin-right: 0.5rem !important;  /* 8px between tabs */
        }
        
        /* Buttons - comfortable padding */
        button {
            padding: 0.75rem 1.5rem !important;  /* 12px vertical, 24px horizontal */
        }
        
        /* Small buttons */
        .text-sm button, button.text-sm {
            padding: 0.5rem 1rem !important;  /* 8px vertical, 16px horizontal */
        }
        
        /* Form elements */
        input, select, textarea {
            padding: 0.75rem 1rem !important;  /* 12px vertical, 16px horizontal */
            margin-bottom: 1rem !important;  /* 16px */
        }
        
        /* === PROFESSIONAL STATUS BADGES === */
        
        /* Base badge style - clean pills */
        .metric-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem !important;  /* 4px vertical, 12px horizontal */
            border-radius: 12px !important;  /* Pill shape */
            font-size: 0.75rem !important;  /* 12px */
            font-weight: 700 !important;  /* Bold */
            letter-spacing: 0.05em !important;  /* Slight spacing */
            text-transform: uppercase !important;
            margin-left: 0.5rem !important;  /* 8px spacing from number */
            vertical-align: middle !important;
        }
        
        /* Excellent badge - success green */
        .badge-excellent {
            background-color: rgba(5, 150, 105, 0.2) !important;
            color: #34D399 !important;
            border: 1px solid rgba(52, 211, 153, 0.5) !important;
        }
        
        /* Good badge - light blue */
        .badge-good {
            background-color: rgba(96, 165, 250, 0.2) !important;
            color: #93C5FD !important;
            border: 1px solid rgba(147, 197, 253, 0.5) !important;
        }
        
        /* Moderate/OK badge - amber */
        .badge-moderate {
            background-color: rgba(251, 191, 36, 0.2) !important;
            color: #FCD34D !important;
            border: 1px solid rgba(252, 211, 77, 0.5) !important;
        }
        
        /* Poor/Needs Work badge - warning red */
        .badge-poor {
            background-color: rgba(220, 38, 38, 0.2) !important;
            color: #F87171 !important;
            border: 1px solid rgba(248, 113, 113, 0.5) !important;
        }
        
        /* Badge hover effect */
        .metric-badge:hover {
            opacity: 0.9 !important;
        }
        
        /* === VISUAL BREATHING ROOM === */
        
        /* Main content container */
        #main-content {
            padding: 2rem !important;  /* 32px all around */
        }
        
        /* Mobile adjustments */
        @media (max-width: 768px) {
            #main-content {
                padding: 1rem !important;  /* 16px on mobile */
            }
            
            .metric-card {
                padding: 1rem !important;  /* 16px on mobile */
            }
            
            .bg-gray-800, .bg-gray-700 {
                padding: 1rem !important;  /* 16px on mobile */
            }
        }
        
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <!-- UPDATE BANNER - AUTO-UPDATE SYSTEM -->
    <div id="updateBanner" style="display: none; position: fixed; top: 0; left: 0; right: 0; z-index: 10000; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); animation: slideDown 0.3s ease;">
        <div style="max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; gap: 16px;">
            <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 16px; margin-bottom: 4px;">üéâ New Version Available!</div>
                <div style="font-size: 14px; opacity: 0.9;">SailAI has been updated with improvements and bug fixes.</div>
            </div>
            <button id="updateBtn" style="background: white; color: #667eea; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; white-space: nowrap; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.2s;">Update Now</button>
            <button id="dismissBtn" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 13px; white-space: nowrap;">Later</button>
        </div>
    </div>
    <style>
    @keyframes slideDown {
        from { transform: translateY(-100%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }
    #updateBtn:hover { transform: scale(1.05); }
    #updateBtn:active { transform: scale(0.95); }
    #dismissBtn:hover { background: rgba(255,255,255,0.3); }
    @media (max-width: 640px) {
        #updateBanner > div { flex-direction: column; text-align: center; }
        #updateBanner button { width: 100%; }
    }
    </style>
    <!-- END UPDATE BANNER -->

    <div id="root">
        <!-- Loading indicator - replaced when app loads -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #1F2937;">
            <div style="text-align: center;">
                <div style="width: 60px; height: 60px; border: 4px solid #374151; border-top-color: #60A5FA; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1.5rem;"></div>
                <h2 style="color: #60A5FA; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem;">‚õµ SailAI</h2>
                <p style="color: #9CA3AF; font-size: 1rem;">Loading your sailing coach...</p>
            </div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    
    <script>
        let csvData = null;
        let analysis = null;
        let windDir = 225;
        let races = [
            { start: '11:00:00', end: '12:00:00' }
        ];
        let selectedRace = '0';
        let raceWindDirections = {}; // Store auto-detected wind direction per race
        let raceResults = {}; // Store analysis results per race for comparison
        let map = null;
        let manualMarks = [];
        let markMode = null;
        let startLinePins = [];
        let startLinePolyline = null;
        let finishLinePins = [];
        let finishLinePolyline = null;
        
        // Map layer groups for toggle control
        let mapLayers = {
            track: [],
            upwindLaylines: [],
            downwindLaylines: [],
            shiftZones: [],
            maneuvers: [],
            shiftMarkers: [],
            startLine: [],
            finishLine: []
        };
        
        // Layer visibility state (all visible by default)
        let layerVisibility = {
            track: true,
            'upwind-laylines': true,
            'downwind-laylines': true,
            'shift-zones': true,
            maneuvers: true,
            'shift-markers': true,
            'start-line': true,
            'finish-line': true
        };
        
        // Tooltip definitions
        const tooltips = {
            vmg: {
                title: "VMG (Velocity Made Good)",
                text: "Your speed directly toward the mark. Higher VMG = faster progress. Example: sailing 6 kts at 45¬∞ to wind might give 4.2 kts VMG upwind."
            },
            leeway: {
                title: "Leeway",
                text: "How much you're slipping sideways. Lower is better. Caused by: excessive heel, dirty bottom, centerboard not down. Target: under 5¬∞ for good performance."
            },
            heel: {
                title: "Optimal Heel Angle",
                text: "Best heel angle for maximum VMG. Found by analyzing when your boat goes fastest upwind. Typically 8-12¬∞ for most dinghies, but varies by conditions."
            },
            trim: {
                title: "Optimal Trim (Bow Up/Down)",
                text: "Best fore/aft balance. Positive = bow up (light air), negative = bow down (heavy air). Affects wetted surface and pointing ability."
            },
            tackEfficiency: {
                title: "Tack Efficiency",
                text: "How well you maintain speed through tacks. Based on exit speed vs. entry speed. 85%+ is good, 90%+ is excellent. Smooth helm and quick sheeting help."
            },
            boatHandling: {
                title: "Boat Handling Score",
                text: "Overall skill rating (0-100) based on: tack efficiency (40%), low leeway (30%), and sailing efficient course (30%). Higher = better technique."
            },
            timeInZone: {
                title: "Time in Optimal Zone",
                text: "Percent of time at your best heel/trim angles. More time in zone = more consistency = faster average speeds. Target: 60%+."
            },
            pointing: {
                title: "Pointing Angle",
                text: "How close to the wind you can sail. Lower angles = pointing higher. But pointing too high can hurt VMG. Best sailors balance pointing with speed."
            },
            windShifts: {
                title: "Wind Shifts",
                text: "Changes in wind direction. Lifts (green) let you point higher. Headers (red) force you lower. Tack on headers, sail lifts longer for best VMG."
            },
            courseBias: {
                title: "Course Bias",
                text: "Which side of the course was favored. Based on wind shifts and geographic features. Helps plan strategy for next race."
            }
        };
        
        // Create tooltip HTML
        function createTooltip(key) {
            const tip = tooltips[key];
            if (!tip) return '';
            
            return `<span class="tooltip-container">
                <span class="tooltip-icon">?</span>
                <span class="tooltip-content">
                    <strong>${tip.title}</strong>
                    <p>${tip.text}</p>
                </span>
            </span>`;
        }
        
        // Enable mobile tap-to-toggle tooltips
        document.addEventListener('click', function(e) {
            const tooltipContainer = e.target.closest('.tooltip-container');
            
            if (tooltipContainer) {
                e.stopPropagation();
                
                // Close all other tooltips
                document.querySelectorAll('.tooltip-container.active').forEach(tc => {
                    if (tc !== tooltipContainer) {
                        tc.classList.remove('active');
                    }
                });
                
                // Toggle this tooltip
                tooltipContainer.classList.toggle('active');
            } else {
                // Close all tooltips if clicking outside
                document.querySelectorAll('.tooltip-container.active').forEach(tc => {
                    tc.classList.remove('active');
                });
            }
        });
        
        // Maneuver detection parameters
        let maneuverParams = {
            minAngle: 60,
            timeWindow: 10,
            minSpeed: 2.0
        };

        // Help system helper functions
        function helpIcon(tooltipText) {
            return `
                <span class="tooltip">
                    <span class="help-icon">?</span>
                    <span class="tooltiptext">${tooltipText}</span>
                </span>
            `;
        }

        function metricBadge(value, excellentThreshold, goodThreshold, higherIsBetter = true) {
            let badgeClass, badgeText;
            
            if (higherIsBetter) {
                if (value >= excellentThreshold) {
                    badgeClass = 'badge-excellent';
                    badgeText = 'Excellent';
                } else if (value >= goodThreshold) {
                    badgeClass = 'badge-good';
                    badgeText = 'Good';
                } else if (value >= goodThreshold * 0.8) {
                    badgeClass = 'badge-moderate';
                    badgeText = 'OK';
                } else {
                    badgeClass = 'badge-poor';
                    badgeText = 'Needs Work';
                }
            } else {
                // Lower is better (e.g., leeway)
                if (value <= excellentThreshold) {
                    badgeClass = 'badge-excellent';
                    badgeText = 'Excellent';
                } else if (value <= goodThreshold) {
                    badgeClass = 'badge-good';
                    badgeText = 'Good';
                } else if (value <= goodThreshold * 1.5) {
                    badgeClass = 'badge-moderate';
                    badgeText = 'OK';
                } else {
                    badgeClass = 'badge-poor';
                    badgeText = 'Needs Work';
                }
            }
            
            return `<span class="metric-badge ${badgeClass}">${badgeText}</span>`;
        }

        function expandableHelp(title, content) {
            return `
                <details class="help-section">
                    <summary>üí° ${title}</summary>
                    ${content}
                </details>
            `;
        }

        function getCompassDirection(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        // Download HTML function
        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sailing-analysis-${new Date().toISOString().split('T')[0]}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Check if in preview/iframe mode and show download button
        window.addEventListener('DOMContentLoaded', () => {
            if (typeof L === 'undefined' || typeof Chart === 'undefined') {
                const btn = document.getElementById('downloadBtn');
                if (btn) btn.classList.remove('hidden');
            }
        });

        function initApp() {
            document.getElementById('root').innerHTML = `
                <!-- Mobile Menu Button -->
                <button id="mobileMenuBtn" aria-label="Toggle Menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                
                <!-- Mobile Overlay -->
                <div id="mobileOverlay"></div>
                
                <div class="flex h-screen">
                    <div id="sidebar" class="bg-gray-800 p-6 overflow-y-auto border-r border-gray-700" style="width: 360px;">
                        <div class="mb-6" style="padding-top: 0;">
                            <!-- SailAI Logo - Larger for wider sidebar -->
                            <svg width="260" height="78" viewBox="0 0 260 78" style="margin-bottom: 0.5rem; max-width: 100%; height: auto;">
                                <defs>
                                    <linearGradient id="sailGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                        <stop offset="0%" style="stop-color:#60A5FA;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#93C5FD;stop-opacity:0.8" />
                                    </linearGradient>
                                </defs>
                                <path d="M26 68 L26 15 L62 41.5 Z" fill="url(#sailGradient)"/>
                                <line x1="26" y1="15" x2="26" y2="68" stroke="#60A5FA" stroke-width="2.5"/>
                                <text x="78" y="49" font-family="system-ui, -apple-system, sans-serif" font-size="36" font-weight="900" letter-spacing="-0.03em">
                                    <tspan fill="#60A5FA">Sail</tspan><tspan fill="#93C5FD">AI</tspan>
                                </text>
                            </svg>
                            <p class="text-sm text-gray-400 mt-2" style="font-weight: 400; letter-spacing: 0.01em;">Performance insights from your GPS sailing data</p>
                        </div>

                        <button id="downloadBtn" onclick="downloadHTML()" class="w-full mb-4 px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-sm font-semibold text-white hidden">
                            üì• Download Full Version (GPS Map + All Features)
                        </button>

                        <div class="mb-6">
                            <label class="block text-sm font-medium mb-2">üì§ Upload CSV</label>
                            
                            <!-- QUICK START INSTRUCTIONS -->
                            <div class="bg-blue-900/30 border border-blue-700 rounded-lg p-3 mb-3">
                                <div class="text-xs font-semibold text-blue-300 mb-2">üìù Quick Start:</div>
                                <ol class="text-xs text-blue-100 space-y-1 ml-4 list-decimal">
                                    <li>Upload your Vakaros CSV file below</li>
                                    <li>Enter start/end times for each race (or click Auto-Detect)</li>
                                    <li>Check auto-detected wind direction - adjust slider if needed</li>
                                    <li>Review your performance metrics and insights</li>
                                </ol>
                            </div>
                            
                            <input type="file" accept=".csv" id="fileInput" class="w-full p-2 bg-gray-700 border border-gray-600 rounded text-sm" />
                            <div class="text-xs text-gray-500 mt-1">Vakaros GPS data ‚Ä¢ Future: multi-file support planned</div>
                            <div id="error" class="mt-2 text-xs text-red-400 hidden"></div>
                            
                            <!-- Status/Progress Indicator -->
                            <div id="statusIndicator" class="mt-3 hidden">
                                <div class="flex items-center gap-2 text-sm">
                                    <div class="animate-spin">
                                        <svg class="w-4 h-4 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                        </svg>
                                    </div>
                                    <span id="statusText" class="text-blue-400"></span>
                                </div>
                                <div id="progressDetails" class="mt-1 text-xs text-gray-400"></div>
                            </div>
                            
                            <!-- Success Message -->
                            <div id="successMessage" class="mt-3 text-xs text-green-400 hidden">
                                <div class="flex items-center gap-2">
                                    <span>‚úÖ</span>
                                    <span id="successText"></span>
                                </div>
                            </div>
                        </div>

                        <div class="mb-6">
                            <label class="block text-sm font-medium mb-2">Race Times</label>
                            <div id="racesContainer"></div>
                            <div class="mt-2 grid grid-cols-2 gap-2">
                                <button id="autoDetectRaces" class="p-2 bg-purple-600 hover:bg-purple-700 rounded text-sm font-semibold">
                                    ü§ñ Auto-Detect
                                </button>
                                <button id="addRace" class="p-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                                    + Manual Add
                                </button>
                            </div>
                            <div class="mt-2 text-xs text-gray-500 italic">
                                Auto-detect finds races from GPS gaps (>3 min between points)
                            </div>
                        </div>

                        <div class="mb-6" id="raceSelector" style="display:none;">
                            <label class="block text-sm font-medium mb-2">Select Race</label>
                            <select id="raceSelect" class="w-full p-2 bg-gray-700 border border-gray-600 rounded text-sm">
                                <option value="all">All Races (Combined)</option>
                            </select>
                            <div class="text-xs text-gray-400 mt-1">Note: "All Races" combines all data points from all races into a single analysis.</div>
                        </div>

                        <div class="mb-6" id="maneuverTuner" style="display:none;">
                            <div class="text-sm font-medium mb-3 border-b border-gray-600 pb-2">üéõÔ∏è Maneuver Detection</div>
                            
                            <!-- Instructions -->
                            <div class="bg-gray-800/50 border border-gray-700 rounded p-2 mb-3 text-xs text-gray-300">
                                <div class="font-semibold text-gray-200 mb-1">üí° Adjust these if tacks/gybes are over/under-detected:</div>
                                <ul class="ml-4 space-y-1 list-disc">
                                    <li><strong>Min Angle:</strong> Heading change required (‚Üì = more sensitive)</li>
                                    <li><strong>Time Window:</strong> How long to look for turn (‚Üë = slower turns)</li>
                                    <li><strong>Min Speed:</strong> Ignore maneuvers below this speed</li>
                                </ul>
                            </div>
                            
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Min Angle: <span id="minAngleDisplay">${maneuverParams.minAngle}</span>¬∞</label>
                                <input type="range" min="30" max="120" value="${maneuverParams.minAngle}" id="minAngleSlider" class="w-full" />
                            </div>
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Time Window: <span id="timeWindowDisplay">${maneuverParams.timeWindow}</span>s</label>
                                <input type="range" min="5" max="30" value="${maneuverParams.timeWindow}" id="timeWindowSlider" class="w-full" />
                            </div>
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Min Speed: <span id="minSpeedDisplay">${maneuverParams.minSpeed}</span> kts</label>
                                <input type="range" min="0" max="5" step="0.5" value="${maneuverParams.minSpeed}" id="minSpeedSlider" class="w-full" />
                            </div>
                        </div>

                        <div class="mb-6" id="heelOptions" style="display:none;">
                            <div class="text-sm font-medium mb-3 border-b border-gray-600 pb-2">‚öñÔ∏è Heel Analysis</div>
                            
                            <label class="flex items-start text-xs mb-3">
                                <input type="checkbox" id="absHeelCheck" class="mr-2 mt-0.5" />
                                <div class="flex-1">
                                    <div class="font-semibold mb-1">Use Absolute Heel</div>
                                    <div class="text-gray-400 text-xs leading-relaxed">
                                        Uses raw heel angle values (0¬∞ upright, higher = more heel). 
                                        <strong>Best for:</strong> Understanding actual heel angles you're sailing at.
                                    </div>
                                </div>
                            </label>
                            
                            <label class="flex items-start text-xs">
                                <input type="checkbox" id="showBestFitCheck" class="mr-2 mt-0.5" checked />
                                <div class="flex-1">
                                    <div class="font-semibold mb-1">Show Best Fit Curve</div>
                                    <div class="text-gray-400 text-xs leading-relaxed">
                                        Displays smoothed trend line through your data points. 
                                        <strong>Best for:</strong> Identifying optimal heel angle pattern and reducing noise from waves/gusts.
                                    </div>
                                </div>
                            </label>
                            
                            <div class="mt-3 p-2 bg-blue-900 bg-opacity-20 rounded border border-blue-600 text-xs">
                                <div class="flex items-start">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#60A5FA" stroke-width="2" class="mr-1.5 flex-shrink-0 mt-0.5">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M12 16v-4"></path>
                                        <path d="M12 8h.01"></path>
                                    </svg>
                                    <div class="text-gray-300">
                                        <strong>Tip:</strong> Enable both to see raw data points with the trend line overlay for best insights.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div id="sessionInfo" class="text-xs text-gray-400 p-3 bg-gray-700 rounded hidden">
                            <div class="font-semibold mb-2">Session Info</div>
                            <div id="dataPoints"></div>
                            <div id="dataQuality" class="mt-2"></div>
                        </div>

                        <!-- Race Date Input for PDF -->
                        <div id="raceDateContainer" class="mt-4 px-2" style="display:none;">
                            <label for="raceDate" class="block text-sm font-semibold text-gray-300 mb-2">
                                üìÖ Race Date (for PDF tracking)
                            </label>
                            <input 
                                type="date" 
                                id="raceDate" 
                                class="w-full p-2 bg-gray-700 border border-gray-600 rounded text-white"
                                value=""
                            />
                            <div class="text-xs text-gray-400 mt-1">
                                This date will appear on your PDF report
                            </div>
                        </div>

                        <button id="generatePDF" class="w-full p-3 bg-green-600 hover:bg-green-700 rounded font-semibold text-base mt-4 shadow-lg" style="display:none;">
                            üìÑ Generate PDF Report
                        </button>
                        <div class="text-xs text-yellow-400 mt-2 px-2" id="pdfNote" style="display:none;">
                            üí° Scroll down in the sidebar to find this button after uploading data
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-8" id="mainContent">
                        <div class="flex items-center justify-center" style="min-height: 400px;">
                            <div class="text-center text-gray-400">
                                <div class="text-6xl mb-4">üì§</div>
                                <p class="text-xl">Upload your Vakaros CSV file</p>
                                <p class="text-sm mt-2 text-gray-500">Complete performance analysis with all metrics</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            renderRaces();
            
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('addRace').addEventListener('click', addRace);
            document.getElementById('autoDetectRaces').addEventListener('click', autoDetectRaces);
            
            // Maneuver tuner listeners
            document.getElementById('minAngleSlider').addEventListener('input', (e) => {
                maneuverParams.minAngle = parseInt(e.target.value);
                document.getElementById('minAngleDisplay').textContent = maneuverParams.minAngle;
                if (csvData) analyzeData();
            });
            document.getElementById('timeWindowSlider').addEventListener('input', (e) => {
                maneuverParams.timeWindow = parseInt(e.target.value);
                document.getElementById('timeWindowDisplay').textContent = maneuverParams.timeWindow;
                if (csvData) analyzeData();
            });
            document.getElementById('minSpeedSlider').addEventListener('input', (e) => {
                maneuverParams.minSpeed = parseFloat(e.target.value);
                document.getElementById('minSpeedDisplay').textContent = maneuverParams.minSpeed;
                if (csvData) analyzeData();
            });
            
            // Heel options
            document.getElementById('absHeelCheck').addEventListener('change', () => {
                if (csvData) renderCharts();
            });
            document.getElementById('showBestFitCheck').addEventListener('change', () => {
                if (csvData) renderCharts();
            });
            
            // PDF generation
            document.getElementById('generatePDF').addEventListener('click', function(e) {
                console.log("üîµ PDF button clicked!");
                e.preventDefault();
                generatePDF();
            });
            
            // Setup mobile menu
            setupMobileMenu();
        }

        function renderRaces() {
            const container = document.getElementById('racesContainer');
            container.innerHTML = races.map((race, idx) => {
                const raceKey = `race_${idx}`;
                const raceWind = raceWindDirections[raceKey] || windDir;
                
                // Show confidence badge if auto-detected
                const confidenceBadge = race.autoDetected ? `
                    <span class="text-xs px-2 py-1 rounded ${
                        race.confidence === 'HIGH' ? 'bg-green-900 text-green-300' :
                        race.confidence === 'MEDIUM' ? 'bg-blue-900 text-blue-300' :
                        'bg-yellow-900 text-yellow-300'
                    }">
                        ü§ñ ${race.confidence}
                    </span>
                ` : '';
                
                const raceInfo = race.autoDetected ? `
                    <div class="text-xs text-gray-500 mt-1">
                        ${race.durationMin} min ‚Ä¢ ${race.points} GPS points ‚Ä¢ ${race.avgSpeed} kts avg
                    </div>
                ` : '';
                
                return `
                <div class="p-3 bg-gray-700 rounded border border-gray-600 mb-2">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                            <div class="text-xs text-gray-400">Race ${idx + 1}</div>
                            ${confidenceBadge}
                        </div>
                        ${races.length > 1 ? `<button data-remove-race="${idx}" class="remove-race-btn text-red-400 text-xs hover:text-red-300">‚úï</button>` : ''}
                    </div>
                    <div class="flex gap-2 mb-2">
                        <div class="flex-1">
                            <label class="text-xs text-gray-400 mb-1 block">Start (HH:MM:SS)</label>
                            <input type="time" step="1" value="${race.start}" 
                                   data-race-idx="${idx}" data-field="start"
                                   class="race-time-input w-full p-2 bg-gray-600 border border-gray-500 rounded text-sm text-white" />
                        </div>
                        <div class="flex-1">
                            <label class="text-xs text-gray-400 mb-1 block">End (HH:MM:SS)</label>
                            <input type="time" step="1" value="${race.end}"
                                   data-race-idx="${idx}" data-field="end"
                                   class="race-time-input w-full p-2 bg-gray-600 border border-gray-500 rounded text-sm text-white" />
                        </div>
                    </div>
                    ${raceInfo}
                    <div class="mt-2 p-3 bg-gray-800 rounded border border-gray-700">
                        <label class="text-sm text-gray-300 font-semibold mb-2 block">
                            Wind Direction (FROM): <span id="raceWind_${idx}" class="text-white font-bold text-lg">${Math.round(raceWind)}¬∞</span>
                            <span class="text-gray-400 ml-2">${getCompassDirection(Math.round(raceWind))}</span>
                        </label>
                        
                        <!-- Number Input (Top Row) -->
                        <div class="mb-2">
                            <input type="number" min="0" max="359" value="${Math.round(raceWind)}" 
                                   class="wind-number-input w-full bg-gray-700 text-white px-3 py-2 rounded text-center font-semibold border border-gray-600 focus:border-blue-500 focus:outline-none" 
                                   data-race-idx="${idx}" 
                                   placeholder="Enter degrees (0-359)" />
                        </div>
                        
                        <!-- Increment Buttons (Bottom Row) -->
                        <div class="flex gap-2 mb-3">
                            <button class="wind-adjust-btn flex-1 bg-gray-700 hover:bg-gray-600 px-2 py-2 rounded text-sm font-semibold" data-race-idx="${idx}" data-adjust="-5">-5¬∞</button>
                            <button class="wind-adjust-btn flex-1 bg-gray-700 hover:bg-gray-600 px-2 py-2 rounded text-sm font-semibold" data-race-idx="${idx}" data-adjust="-1">-1¬∞</button>
                            <button class="wind-adjust-btn flex-1 bg-gray-700 hover:bg-gray-600 px-2 py-2 rounded text-sm font-semibold" data-race-idx="${idx}" data-adjust="+1">+1¬∞</button>
                            <button class="wind-adjust-btn flex-1 bg-gray-700 hover:bg-gray-600 px-2 py-2 rounded text-sm font-semibold" data-race-idx="${idx}" data-adjust="+5">+5¬∞</button>
                        </div>
                        
                        <!-- Slider -->
                        <input type="range" min="0" max="359" value="${Math.round(raceWind)}" step="1"
                               data-race-idx="${idx}"
                               class="race-wind-slider w-full mb-2" 
                               style="height: 10px; touch-action: none;" />
                        
                        <div class="text-xs text-gray-400 flex items-start">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="mr-1 flex-shrink-0 mt-0.5">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M12 16v-4"></path>
                                <path d="M12 8h.01"></path>
                            </svg>
                            <span>Verify auto-detected wind. Use buttons or slider to fine-tune.</span>
                        </div>
                    </div>
                </div>
                `;
            }).join('');

            // Add event listeners using delegation
            container.querySelectorAll('.remove-race-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.dataset.removeRace);
                    removeRace(idx);
                });
            });

            container.querySelectorAll('.race-time-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    const field = e.target.dataset.field;
                    updateRace(idx, field, e.target.value);
                });
            });

            // Add wind slider listeners
            container.querySelectorAll('.race-wind-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    const value = parseInt(e.target.value);
                    updateWindDirection(idx, value);
                });
            });
            
            // Add wind adjustment button listeners
            container.querySelectorAll('.wind-adjust-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    const adjust = parseInt(e.target.dataset.adjust);
                    const slider = container.querySelector(`.race-wind-slider[data-race-idx="${idx}"]`);
                    if (slider) {
                        let newValue = parseInt(slider.value) + adjust;
                        // Wrap around 0-359
                        if (newValue < 0) newValue += 360;
                        if (newValue > 359) newValue -= 360;
                        slider.value = newValue;
                        updateWindDirection(idx, newValue);
                    }
                });
            });
            
            // Add number input listeners
            container.querySelectorAll('.wind-number-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    let value = parseInt(e.target.value);
                    // Clamp to 0-359
                    if (value < 0) value = 0;
                    if (value > 359) value = 359;
                    e.target.value = value;
                    
                    const slider = container.querySelector(`.race-wind-slider[data-race-idx="${idx}"]`);
                    if (slider) {
                        slider.value = value;
                        updateWindDirection(idx, value);
                    }
                });
            });
            
            // Helper function to update wind direction
            function updateWindDirection(idx, value) {
                const raceKey = `race_${idx}`;
                raceWindDirections[raceKey] = value;
                
                // Update display
                const windSpan = document.getElementById(`raceWind_${idx}`);
                if (windSpan) {
                    windSpan.textContent = value + '¬∞';
                    
                    // Update compass direction
                    const compassSpan = windSpan.nextElementSibling;
                    if (compassSpan) {
                        compassSpan.textContent = getCompassDirection(value);
                    }
                }
                
                // Update number input
                const numberInput = container.querySelector(`.wind-number-input[data-race-idx="${idx}"]`);
                if (numberInput) {
                    numberInput.value = value;
                }
                
                // If this is the currently selected race, update global wind and re-analyze
                if (selectedRace === String(idx)) {
                    windDir = value;
                    if (csvData) analyzeData();
                }
            }

            // Update race selector
            const selector = document.getElementById('raceSelect');
            if (selector) {
                selector.innerHTML = '<option value="all">All Races</option>' +
                    races.map((_, idx) => `<option value="${idx}">Race ${idx + 1}</option>`).join('');
                selector.value = selectedRace;
            }

            if (races.length > 1) {
                document.getElementById('raceSelector').style.display = 'block';
                const raceSelect = document.getElementById('raceSelect');
                // Remove old listener if exists
                const newSelect = raceSelect.cloneNode(true);
                raceSelect.parentNode.replaceChild(newSelect, raceSelect);
                newSelect.addEventListener('change', (e) => {
                    const oldRace = selectedRace;
                    selectedRace = e.target.value;
                    
                    // Restore stored wind direction for this race, or keep current if not stored yet
                    const raceKey = selectedRace === 'all' ? 'all' : `race_${selectedRace}`;
                    if (raceWindDirections[raceKey]) {
                        windDir = Math.round(raceWindDirections[raceKey]);
                        console.log(`üîÑ Switched from race ${oldRace} to ${selectedRace}, restored wind direction: ${windDir}¬∞`);
                    } else {
                        console.log(`üîÑ Switched to race ${selectedRace}, will auto-detect wind direction`);
                    }
                    
                    if (csvData) analyzeData();
                });
            } else {
                document.getElementById('raceSelector').style.display = 'none';
            }
        }

        function addRace() {
            races.push({ start: '12:00:00', end: '13:00:00' });
            renderRaces();
            if (csvData) analyzeData();
        }

        function autoDetectRaces() {
            if (!csvData || csvData.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            console.log('ü§ñ Auto-detecting races from GPS gaps...');
            console.log(`üìä Total data points: ${csvData.length}`);
            
            // Parse timestamps and sort data
            const dataWithTime = csvData
                .map(row => {
                    const timestamp = new Date(row.timestamp);
                    return {
                        timestamp,
                        time: timestamp.getTime(),
                        speed: parseFloat(row.speed) || 0
                    };
                })
                .filter(d => !isNaN(d.time))
                .sort((a, b) => a.time - b.time);
            
            if (dataWithTime.length < 10) {
                alert('Not enough GPS data to detect races');
                return;
            }
            
            console.log(`‚úÖ Valid timestamps: ${dataWithTime.length}`);
            console.log(`üìÖ Data range: ${dataWithTime[0].timestamp.toLocaleString()} to ${dataWithTime[dataWithTime.length-1].timestamp.toLocaleString()}`);
            
            // MORE LENIENT: Detect gaps (>2 minutes = 120,000 ms between points)
            const minGapMs = 2 * 60 * 1000; // Changed from 3 to 2 minutes
            const minRaceDurationMs = 5 * 60 * 1000; // Changed from 10 to 5 minutes minimum
            const maxRaceDurationMs = 120 * 60 * 1000; // 2 hours max race
            
            // Find all gaps in the data
            const gaps = [];
            for (let i = 1; i < dataWithTime.length; i++) {
                const timeDiff = dataWithTime[i].time - dataWithTime[i-1].time;
                if (timeDiff > minGapMs) {
                    gaps.push({
                        index: i,
                        gapMinutes: (timeDiff / 60000).toFixed(1),
                        before: dataWithTime[i-1].timestamp.toLocaleTimeString(),
                        after: dataWithTime[i].timestamp.toLocaleTimeString()
                    });
                }
            }
            
            console.log(`üîç Found ${gaps.length} gaps >2 minutes:`);
            gaps.forEach(g => {
                console.log(`  Gap at ${g.before} ‚Üí ${g.after} (${g.gapMinutes} min)`);
            });
            
            const segments = [];
            let currentSegment = {
                start: dataWithTime[0].timestamp,
                end: dataWithTime[0].timestamp,
                points: 1,
                avgSpeed: dataWithTime[0].speed
            };
            
            for (let i = 1; i < dataWithTime.length; i++) {
                const timeDiff = dataWithTime[i].time - dataWithTime[i-1].time;
                
                if (timeDiff > minGapMs) {
                    // Gap detected - finish current segment
                    const duration = currentSegment.end.getTime() - currentSegment.start.getTime();
                    segments.push({...currentSegment, duration});
                    console.log(`  Segment: ${currentSegment.start.toLocaleTimeString()} - ${currentSegment.end.toLocaleTimeString()} (${(duration/60000).toFixed(1)} min, ${currentSegment.points} pts)`);
                    
                    // Start new segment
                    currentSegment = {
                        start: dataWithTime[i].timestamp,
                        end: dataWithTime[i].timestamp,
                        points: 1,
                        avgSpeed: dataWithTime[i].speed
                    };
                } else {
                    // Continue current segment
                    currentSegment.end = dataWithTime[i].timestamp;
                    currentSegment.points++;
                    currentSegment.avgSpeed = (currentSegment.avgSpeed * (currentSegment.points - 1) + dataWithTime[i].speed) / currentSegment.points;
                }
            }
            
            // Add final segment
            const duration = currentSegment.end.getTime() - currentSegment.start.getTime();
            segments.push({...currentSegment, duration});
            console.log(`  Segment: ${currentSegment.start.toLocaleTimeString()} - ${currentSegment.end.toLocaleTimeString()} (${(duration/60000).toFixed(1)} min, ${currentSegment.points} pts)`);
            
            console.log(`üì¶ Total segments: ${segments.length}`);
            
            // Filter segments by duration
            const validSegments = segments.filter(seg => {
                const durationMin = seg.duration / 60000;
                const valid = seg.duration >= minRaceDurationMs && seg.duration <= maxRaceDurationMs;
                if (!valid) {
                    console.log(`  ‚ùå Filtered out: ${seg.start.toLocaleTimeString()} - ${seg.end.toLocaleTimeString()} (${durationMin.toFixed(1)} min - ${durationMin < 5 ? 'too short' : 'too long'})`);
                }
                return valid;
            });
            
            console.log(`‚úÖ Valid segments (5-120 min): ${validSegments.length}`);
            
            if (validSegments.length === 0) {
                const message = segments.length === 0 
                    ? 'No gaps detected in data. Data appears continuous.\n\nPossible causes:\n‚Ä¢ Races were back-to-back (<2 min apart)\n‚Ä¢ Single continuous sailing session\n‚Ä¢ Need to manually enter race times'
                    : `Found ${segments.length} segment(s) but none were 5-120 minutes long.\n\nSegments found:\n${segments.map(s => `‚Ä¢ ${s.start.toLocaleTimeString()} - ${s.end.toLocaleTimeString()} (${(s.duration/60000).toFixed(1)} min)`).join('\n')}\n\nTry manual race entry instead.`;
                    
                alert(message);
                console.log('‚ö†Ô∏è No valid races detected');
                return;
            }
            
            // Calculate confidence based on data quality
            const detectedRaces = validSegments.map((seg, idx) => {
                const durationMin = seg.duration / 60000;
                const pointsPerMinute = seg.points / durationMin;
                
                // Confidence scoring:
                // HIGH: >30 min race, >0.8 points/min (good GPS coverage)
                // MEDIUM: 20-30 min race OR 0.5-0.8 points/min
                // LOW: <20 min race OR <0.5 points/min
                let confidence = 'LOW';
                if (durationMin >= 30 && pointsPerMinute >= 0.8) {
                    confidence = 'HIGH';
                } else if (durationMin >= 20 && pointsPerMinute >= 0.5) {
                    confidence = 'MEDIUM';
                }
                
                return {
                    start: seg.start.toTimeString().slice(0, 8),
                    end: seg.end.toTimeString().slice(0, 8),
                    confidence,
                    autoDetected: true,
                    durationMin: Math.round(durationMin),
                    points: seg.points,
                    avgSpeed: seg.avgSpeed.toFixed(1)
                };
            });
            
            // Store original races in case user cancels
            const originalRaces = [...races];
            
            // Replace current races with detected ones
            races = detectedRaces;
            
            console.log(`‚úÖ Detected ${races.length} races:`);
            races.forEach((r, idx) => {
                console.log(`  Race ${idx + 1}: ${r.start} - ${r.end} (${r.durationMin} min, ${r.points} pts, ${r.confidence} confidence)`);
            });
            
            // Alert user
            const raceList = races.map((r, idx) => 
                `Race ${idx + 1}: ${r.start}-${r.end} (${r.durationMin}min, ${r.confidence})`
            ).join('\n');
            
            const confirmed = confirm(
                `ü§ñ Auto-detected ${races.length} race(s):\n\n${raceList}\n\nClick OK to use these races, or Cancel to keep manual entries.`
            );
            
            if (confirmed) {
                renderRaces();
                if (csvData) analyzeData();
                alert('‚úÖ Races updated! You can still edit times manually if needed.');
            } else {
                // Restore original races
                races = originalRaces;
                alert('Auto-detection cancelled. Manual races preserved.');
            }
        }

        function removeRace(idx) {
            races.splice(idx, 1);
            renderRaces();
            if (csvData) analyzeData();
        }

        // Debounce timer for updateRace
        let updateRaceTimer = null;
        
        function updateRace(idx, field, value) {
            races[idx][field] = value;
            
            // Debounce: Wait 500ms after last change before re-analyzing
            // This prevents lag when typing time values
            if (updateRaceTimer) clearTimeout(updateRaceTimer);
            
            updateRaceTimer = setTimeout(() => {
                if (csvData) {
                    console.log(`üîÑ Race time updated, re-analyzing...`);
                    analyzeData();
                }
            }, 500);
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            showStatus('Uploading file...', `Reading ${file.name}`);

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    showStatus('Parsing CSV...', 'Processing data rows');
                    
                    csvData = parseCSV(event.target.result);
                    console.log(`‚úÖ Parsed ${csvData.length} rows`);
                    
                    showStatus('Analyzing data...', `${csvData.length} GPS points loaded`);
                    
                    // Small delay to show the status message
                    setTimeout(() => {
                        analyzeData();
                    }, 100);
                    
                } catch (err) {
                    console.error("‚ùå Parse error:", err);
                    hideStatus();
                    
                    // Provide helpful error messages
                    let errorMessage = 'Error reading CSV file';
                    if (err.message.includes('header')) {
                        errorMessage = '‚ùå CSV must have a header row with column names';
                    } else if (err.message.includes('columns')) {
                        errorMessage = '‚ùå CSV missing required columns (latitude, longitude, speed, heading)';
                    } else {
                        errorMessage = `‚ùå ${err.message}`;
                    }
                    
                    showErrorMessage(errorMessage);
                }
            };
            
            reader.onerror = () => {
                hideStatus();
                showErrorMessage('‚ùå Failed to read file. Please try again.');
            };
            
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) throw new Error('CSV must have header and data');

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            console.log("üìã CSV Headers:", headers.join(', '));
            
            const data = lines.slice(1).map(line => {
                const values = line.split(',');
                const row = {};
                headers.forEach((h, i) => {
                    const val = values[i]?.trim();
                    if (!val || val === '') { row[h] = null; return; }
                    const num = parseFloat(val);
                    row[h] = (!isNaN(num) && h !== 'timestamp' && h !== 'time') ? num : val;
                });
                return row;
            });

            if (data.length > 0) {
                console.log("üìã First data row:", data[0]);
                console.log("üìç GPS fields present:", {
                    latitude: !!data[0].latitude,
                    lat: !!data[0].lat,
                    longitude: !!data[0].longitude,
                    lon: !!data[0].lon
                });
            }

            return data.filter(row => Object.values(row).some(v => v !== null && v !== '' && v !== 0));
        }

        function analyzeData() {
            if (!csvData) return;
            console.log("üîÑ Starting comprehensive analysis...");
            
            showStatus('Analyzing performance...', 'Processing GPS data');

            // Filter by race times
            let filteredData = csvData;
            
            if (selectedRace !== 'all') {
                const raceIdx = parseInt(selectedRace);
                const race = races[raceIdx];
                filteredData = csvData.filter(row => {
                    const ts = row.timestamp || row.time;
                    if (!ts) return false;
                    try {
                        const date = new Date(ts);
                        const h = String(date.getHours()).padStart(2, '0');
                        const m = String(date.getMinutes()).padStart(2, '0');
                        const s = String(date.getSeconds()).padStart(2, '0');
                        const timeStr = `${h}:${m}:${s}`;
                        return timeStr >= race.start && timeStr <= race.end;
                    } catch (e) { return false; }
                });
            }

            console.log(`üìä Filtered to ${filteredData.length} points`);
            
            showStatus('Analyzing performance...', `${filteredData.length} GPS points`);

            if (filteredData.length === 0) {
                hideStatus();
                showError("No data in selected race time range");
                return;
            }

            // PROCESS DATA
            const processedData = filteredData.map((row, idx) => {
                const speed = row.sog_kts || row.sog || row.speed || 0;
                const heading = row.hdg_true || row.heading || row.hdg || 0;
                const heel = row.heel || 0;
                const trim = row.trim || row.pitch || 0;
                const cog = row.cog || heading;
                
                let rawTWA_cog = (cog - windDir + 180) % 360 - 180;
                const tackSign = Math.sign(rawTWA_cog) || 1;
                const twa_cog = rawTWA_cog + ((Math.abs(heel) * 0.1) * tackSign);
                
                let leeway = cog - heading;
                if (leeway > 180) leeway -= 360;
                if (leeway < -180) leeway += 360;
                
                const isUpwind = Math.abs(twa_cog) < 90;
                const vmg = speed * Math.cos(twa_cog * Math.PI / 180);
                
                let deltaHeading = 0;
                if (idx > 0) {
                    const prevHeading = filteredData[idx-1].hdg_true || filteredData[idx-1].heading || 0;
                    deltaHeading = heading - prevHeading;
                    if (deltaHeading > 180) deltaHeading -= 360;
                    if (deltaHeading < -180) deltaHeading += 360;
                }
                
                return {
                    speed, heading, cog, heel, trim, twa_cog, vmg,
                    leeway: Math.abs(leeway), isUpwind,
                    deltaHeading, rot: Math.abs(deltaHeading),
                    latitude: row.latitude, lat: row.lat,
                    longitude: row.longitude, lon: row.lon,
                    timestamp: row.timestamp
                };
            });

            // ========================================================================
            // NEW TWA DETECTION ALGORITHM - USE ONLY 5-15 MIN AFTER RACE START
            // ========================================================================
            // Problem: Start line can include downwind legs, pre-start maneuvering
            // Solution: Use data from 5-15 minutes AFTER start = clean upwind sailing
            
            let twaDetectionData = processedData;
            
            if (selectedRace !== 'all') {
                const raceIdx = parseInt(selectedRace);
                const race = races[raceIdx];
                
                // Parse start time to get timestamp
                const [startHour, startMin, startSec = 0] = race.start.split(':').map(Number);
                
                console.log(`‚è±Ô∏è Race start: ${race.start}`);
                
                // Filter for 5-15 minutes after start
                twaDetectionData = processedData.filter(row => {
                    if (!row.timestamp) return false;
                    try {
                        const date = new Date(row.timestamp);
                        const pointHour = date.getHours();
                        const pointMin = date.getMinutes();
                        const pointSec = date.getSeconds();
                        
                        // Calculate minutes elapsed since race start
                        const startTotalSec = startHour * 3600 + startMin * 60 + startSec;
                        const pointTotalSec = pointHour * 3600 + pointMin * 60 + pointSec;
                        const elapsedSec = pointTotalSec - startTotalSec;
                        
                        // Keep only data from 5-15 minutes after start (300-900 seconds)
                        return elapsedSec >= 300 && elapsedSec <= 900;
                    } catch (e) {
                        return false;
                    }
                });
                
                console.log(`üìä TWA Detection: Using ${twaDetectionData.length} points from 5-15 min after start`);
            }
            
            // If not enough data in 5-15 min window, expand to 3-20 min
            if (twaDetectionData.length < 100) {
                console.warn("‚ö†Ô∏è Not enough data in 5-15 min window, expanding to 3-20 min");
                
                if (selectedRace !== 'all') {
                    const raceIdx = parseInt(selectedRace);
                    const race = races[raceIdx];
                    const [startHour, startMin, startSec = 0] = race.start.split(':').map(Number);
                    
                    twaDetectionData = processedData.filter(row => {
                        if (!row.timestamp) return false;
                        try {
                            const date = new Date(row.timestamp);
                            const pointHour = date.getHours();
                            const pointMin = date.getMinutes();
                            const pointSec = date.getSeconds();
                            
                            const startTotalSec = startHour * 3600 + startMin * 60 + startSec;
                            const pointTotalSec = pointHour * 3600 + pointMin * 60 + pointSec;
                            const elapsedSec = pointTotalSec - startTotalSec;
                            
                            // Expand window: 3-20 minutes (180-1200 seconds)
                            return elapsedSec >= 180 && elapsedSec <= 1200;
                        } catch (e) {
                            return false;
                        }
                    });
                    
                    console.log(`üìä Expanded TWA window: ${twaDetectionData.length} points from 3-20 min`);
                }
            }
            
            // Now find predominant upwind headings from clean sailing data
            const upwindCandidates = twaDetectionData.filter(r => 
                r.speed > 3 &&  // Moving
                r.rot < 5       // Not turning (excludes tacks/gybes)
            );
            
            console.log(`üß≠ Upwind candidates for TWA: ${upwindCandidates.length} points (steady sailing only)`);
            
            if (upwindCandidates.length < 30) {
                console.warn("‚ö†Ô∏è Very few steady upwind points - TWA may be unreliable");
            }
            
            const headings = upwindCandidates.map(r => r.cog);
            headings.sort((a, b) => a - b);
            
            // Find two peaks in heading distribution (port and starboard tack)
            const headingBins = {};
            headings.forEach(h => {
                const bin = Math.round(h / 5) * 5;
                headingBins[bin] = (headingBins[bin] || 0) + 1;
            });
            
            const sortedBins = Object.entries(headingBins)
                .map(([bin, count]) => ({ bin: parseInt(bin), count }))
                .sort((a, b) => b.count - a.count);
            
            console.log("üß≠ Top 5 heading bins:", sortedBins.slice(0, 5).map(b => `${b.bin}¬∞ (${b.count})`));
            
            // Get the two most common headings (should be port and starboard tack)
            // CRITICAL: Must be at least 70¬∞ separation AND similar counts (both upwind)
            const peak1 = sortedBins[0]?.bin || 0;
            const peak1Count = sortedBins[0]?.count || 0;
            let peak2 = 0;
            let peak2Count = 0;
            
            for (let i = 1; i < sortedBins.length; i++) {
                // Calculate angular separation (handle wraparound)
                const separation = Math.min(
                    Math.abs(sortedBins[i].bin - peak1),
                    360 - Math.abs(sortedBins[i].bin - peak1)
                );
                
                // Must be:
                // 1. At least 70¬∞ apart (different tacks)
                // 2. Count > 10 (statistically significant)
                if (separation >= 70 && sortedBins[i].count > 10) {
                    peak2 = sortedBins[i].bin;
                    peak2Count = sortedBins[i].count;
                    console.log(`‚úÖ Found second peak: ${peak2}¬∞ (${peak2Count} points), ${separation.toFixed(0)}¬∞ from peak1`);
                    break;
                }
            }
            
            // Estimate wind direction as midpoint between the two tacks
            // When sailing UPWIND, you point TOWARD the wind, so bisector IS wind direction
            let estimatedWindDir, avgTWA;
            
            if (peak2 === 0) {
                console.warn("‚ö†Ô∏è Could not find two distinct tack headings - may be single-leg race");
                estimatedWindDir = peak1;  // Use only peak we found
                avgTWA = 0;
            } else {
                const diff = Math.abs(peak2 - peak1);
                
                if (diff > 180) {
                    // Headings wrap around 0/360 (e.g., 350¬∞ and 10¬∞)
                    const smallerAngle = Math.min(peak1, peak2);
                    const largerAngle = Math.max(peak1, peak2);
                    const actualGap = 360 - diff;
                    estimatedWindDir = (largerAngle + actualGap / 2) % 360;
                    avgTWA = actualGap / 2;
                } else {
                    // Normal case - headings don't wrap around
                    estimatedWindDir = (peak1 + peak2) / 2;
                    avgTWA = diff / 2;
                }
            }
            
            console.log(`üß≠ Auto-detected: Peak headings ${peak1}¬∞ (${peak1Count}) and ${peak2}¬∞ (${peak2Count})`);
            console.log(`üß≠ Wind FROM (bisector): ${estimatedWindDir.toFixed(0)}¬∞ (TWA ~${avgTWA.toFixed(0)}¬∞)`);
            
            // Store detected wind direction for this race
            const raceKey = selectedRace === 'all' ? 'all' : `race_${selectedRace}`;
            if (!raceWindDirections[raceKey]) {
                raceWindDirections[raceKey] = estimatedWindDir;
                console.log(`üíæ Stored wind direction for ${raceKey}: ${estimatedWindDir.toFixed(0)}¬∞`);
            }
            
            const predominantHeadings = {
                peak1,
                peak2,
                peak1Count,
                peak2Count,
                estimatedWindDir,
                avgTWA,
                confidence: peak1Count > 100 && peak2Count > 50 ? 'high' : 
                           peak1Count > 50 && peak2Count > 20 ? 'medium' : 'low',
                detectionWindow: selectedRace !== 'all' ? '5-15 min after start' : 'all data'
            };

            // DETECT MANEUVERS (both tacks and gybes)
            const maneuvers = [];
            let tackNumber = 0;

            for (let i = maneuverParams.timeWindow; i < processedData.length - maneuverParams.timeWindow; i++) {
                if (processedData[i].speed < maneuverParams.minSpeed) continue;

                const prevCOG = processedData[i - maneuverParams.timeWindow].cog;
                const nextCOG = processedData[i + maneuverParams.timeWindow].cog;
                let cogChange = Math.abs(nextCOG - prevCOG);
                if (cogChange > 180) cogChange = 360 - cogChange;

                if (cogChange >= maneuverParams.minAngle) {
                    const entrySpeed = processedData.slice(i - 3, i).reduce((sum, r) => sum + r.speed, 0) / 3;
                    const exitSpeed = processedData.slice(i + 1, i + 4).reduce((sum, r) => sum + r.speed, 0) / 3;
                    const speedLoss = entrySpeed - exitSpeed;
                    const timeLost = speedLoss > 0 ? (maneuverParams.timeWindow * 2) * (speedLoss / entrySpeed) : 0;
                    const distanceLost = (entrySpeed * 0.514444) * timeLost;
                    const efficiency = exitSpeed > 0 ? (exitSpeed / entrySpeed) * 100 : 0;
                    
                    // Determine if tack or gybe based on TWA
                    const entryTWA = Math.abs(processedData[i - maneuverParams.timeWindow].twa_cog);
                    const exitTWA = Math.abs(processedData[i + maneuverParams.timeWindow].twa_cog);
                    const avgTWA = (entryTWA + exitTWA) / 2;
                    const maneuverType = avgTWA < 90 ? 'Tack' : 'Gybe';
                    
                    // Collect speed-over-time data (¬±30 seconds around maneuver for better visualization)
                    const rawSpeedData = [];
                    const timeWindow = 30; // seconds before/after for data collection
                    for (let t = -timeWindow; t <= timeWindow; t++) {
                        const idx = i + t;
                        if (idx >= 0 && idx < processedData.length) {
                            rawSpeedData.push({
                                rawTime: t,
                                speed: processedData[idx].speed,
                                timestamp: processedData[idx].timestamp,
                                index: idx
                            });
                        }
                    }
                    
                    // Find the MINIMUM SPEED POINT (this is t=0 in Gemini's plot)
                    let minSpeedIdx = 0;
                    let minSpeed = rawSpeedData[0].speed;
                    rawSpeedData.forEach((d, idx) => {
                        if (d.speed < minSpeed) {
                            minSpeed = d.speed;
                            minSpeedIdx = idx;
                        }
                    });
                    
                    // Re-center time axis so t=0 is at minimum speed point
                    const speedOverTime = rawSpeedData.map((d, idx) => ({
                        time: d.rawTime - rawSpeedData[minSpeedIdx].rawTime, // Re-center around min speed
                        speed: d.speed,
                        timestamp: d.timestamp
                    }));

                    tackNumber++;
                    maneuvers.push({
                        tackNumber,
                        type: maneuverType,
                        cogChange: cogChange.toFixed(1),
                        entrySpeed,
                        exitSpeed,
                        speedLoss,
                        distanceLost: Math.max(0, distanceLost),
                        efficiency,
                        entryTWA,
                        exitTWA,
                        lat: processedData[i].latitude || processedData[i].lat,
                        lon: processedData[i].longitude || processedData[i].lon,
                        timestamp: processedData[i].timestamp,
                        speedOverTime // NEW: Speed data for visualization
                    });

                    i += maneuverParams.timeWindow;
                }
            }
            
            const tacks = maneuvers.filter(m => m.type === 'Tack');
            const gybes = maneuvers.filter(m => m.type === 'Gybe');
            console.log(`‚öì Detected ${tacks.length} tacks and ${gybes.length} gybes`);
            
            showStatus('Analyzing performance...', `Found ${tacks.length} tacks, ${gybes.length} gybes`);

            const upwind = processedData.filter(r => r.isUpwind && r.speed > 4.5 && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            const downwind = processedData.filter(r => !r.isUpwind && r.speed > 4.5 && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            
            // For speed/heel distributions, use ALL data (no speed filter)
            const upwindAll = processedData.filter(r => r.isUpwind && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            const downwindAll = processedData.filter(r => !r.isUpwind && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);

            // CALCULATE OPTIMAL HEEL/TRIM
            const heelBinsUp = {};
            upwind.forEach(r => {
                const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                if (!heelBinsUp[bin]) heelBinsUp[bin] = [];
                heelBinsUp[bin].push(r.vmg);
            });

            let bestHeelUp = 0;
            let bestVMGUp = -999;
            const heelDistribution = [];
            
            for (const [heel, vmgs] of Object.entries(heelBinsUp)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                const avg = vmgs.reduce((a, b) => a + b, 0) / vmgs.length;
                
                heelDistribution.push({ heel: parseInt(heel), count: vmgs.length, p90, avg });
                
                if (p90 > bestVMGUp) {
                    bestVMGUp = p90;
                    bestHeelUp = parseInt(heel);
                }
            }

            const heelBinsDown = {};
            downwind.forEach(r => {
                const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                if (!heelBinsDown[bin]) heelBinsDown[bin] = [];
                heelBinsDown[bin].push(Math.abs(r.vmg));
            });

            let bestHeelDown = 0;
            let bestVMGDown = -999;
            
            for (const [heel, vmgs] of Object.entries(heelBinsDown)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestVMGDown) {
                    bestVMGDown = p90;
                    bestHeelDown = parseInt(heel);
                }
            }

            const trimBinsUp = {};
            upwind.forEach(r => {
                const bin = Math.round(r.trim / 2) * 2;
                if (!trimBinsUp[bin]) trimBinsUp[bin] = [];
                trimBinsUp[bin].push(r.vmg);
            });

            let bestTrimUp = 0;
            let bestTrimVMGUp = -999;
            
            for (const [trim, vmgs] of Object.entries(trimBinsUp)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestTrimVMGUp) {
                    bestTrimVMGUp = p90;
                    bestTrimUp = parseInt(trim);
                }
            }

            const trimBinsDown = {};
            downwind.forEach(r => {
                const bin = Math.round(r.trim / 2) * 2;
                if (!trimBinsDown[bin]) trimBinsDown[bin] = [];
                trimBinsDown[bin].push(Math.abs(r.vmg));
            });

            let bestTrimDown = 0;
            let bestTrimVMGDown = -999;
            
            for (const [trim, vmgs] of Object.entries(trimBinsDown)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestTrimVMGDown) {
                    bestTrimVMGDown = p90;
                    bestTrimDown = parseInt(trim);
                }
            }

            // OTHER METRICS
            const avgVMG = upwind.reduce((sum, r) => sum + r.vmg, 0) / upwind.length;
            const vmgEfficiency = (avgVMG / bestVMGUp) * 100;

            const inOptimalZone = upwind.filter(r => 
                Math.abs(Math.abs(r.heel) - bestHeelUp) <= 3 && 
                Math.abs(r.trim - bestTrimUp) <= 3
            ).length;
            const timeInZone = (inOptimalZone / upwind.length) * 100;

            const optimalData = upwind.filter(r => Math.abs(Math.abs(r.heel) - bestHeelUp) < 2);
            const avgLeeway = optimalData.reduce((sum, r) => sum + r.leeway, 0) / optimalData.length;

            const upwindGood = processedData.filter(r => r.isUpwind && r.vmg > 3.5 && Math.abs(r.twa_cog) >= 30 && r.speed > 4.5);
            const bestPointing = upwindGood.length > 0 ? Math.min(...upwindGood.map(r => Math.abs(r.twa_cog))) : 0;

            const portTime = processedData.filter(r => r.isUpwind && r.twa_cog < 0).length;
            const starboardTime = processedData.filter(r => r.isUpwind && r.twa_cog > 0).length;
            const totalUpwindTime = portTime + starboardTime;
            const portPercent = (portTime / totalUpwindTime * 100);
            const starboardPercent = (starboardTime / totalUpwindTime * 100);

            const upwindSpeeds = processedData.filter(r => r.isUpwind && r.speed > 2).map(r => r.speed);
            const downwindSpeeds = processedData.filter(r => !r.isUpwind && r.speed > 2).map(r => r.speed);
            const avgUpwindSpeed = upwindSpeeds.reduce((a, b) => a + b, 0) / upwindSpeeds.length;
            const avgDownwindSpeed = downwindSpeeds.reduce((a, b) => a + b, 0) / downwindSpeeds.length;
            const speedRatio = avgDownwindSpeed / avgUpwindSpeed;

            const tackEfficiency = maneuvers.length > 0 
                ? maneuvers.reduce((sum, t) => sum + t.efficiency, 0) / maneuvers.length
                : 0;
            const avgTackLoss = maneuvers.length > 0
                ? maneuvers.reduce((sum, t) => sum + t.distanceLost, 0) / maneuvers.length
                : 0;

            // DISTANCE EFFICIENCY
            if (processedData.length > 1) {
                const firstPoint = processedData[0];
                const lastPoint = processedData[processedData.length - 1];
                const straightLine = haversineDistance(
                    firstPoint.latitude || firstPoint.lat,
                    firstPoint.longitude || firstPoint.lon,
                    lastPoint.latitude || lastPoint.lat,
                    lastPoint.longitude || lastPoint.lon
                );
                
                let totalDistance = 0;
                for (let i = 0; i < processedData.length - 1; i++) {
                    const p1 = processedData[i];
                    const p2 = processedData[i + 1];
                    totalDistance += haversineDistance(
                        p1.latitude || p1.lat, p1.longitude || p1.lon,
                        p2.latitude || p2.lat, p2.longitude || p2.lon
                    );
                }
                
                var distanceEfficiency = (straightLine / totalDistance) * 100;
            } else {
                var distanceEfficiency = 0;
            }

            // BOAT HANDLING SCORE
            const tackScore = Math.max(0, Math.min(100, 100 - (avgTackLoss * 2)));
            const leewayScore = Math.max(0, Math.min(100, 100 - (avgLeeway * 5)));
            const distScore = distanceEfficiency;
            const boatHandlingScore = (tackScore * 0.3 + leewayScore * 0.4 + distScore * 0.3);

            console.log(`üìä Boat Handling Components: Tack=${tackScore.toFixed(0)}, Leeway=${leewayScore.toFixed(0)}, Dist=${distScore.toFixed(0)}`);

            // TWA & SPEED DISTRIBUTIONS
            const twaDistribution = {};
            processedData.forEach(r => {
                const bin = Math.round(r.twa_cog / 5) * 5;
                twaDistribution[bin] = (twaDistribution[bin] || 0) + 1;
            });
            const twaDist = Object.entries(twaDistribution)
                .map(([twa, count]) => ({ twa: parseInt(twa), count }))
                .sort((a, b) => a.twa - b.twa);

            const speedDistribution = {};
            processedData.forEach(r => {
                const bin = Math.round(r.speed * 2) / 2;
                speedDistribution[bin] = (speedDistribution[bin] || 0) + 1;
            });
            const speedDist = Object.entries(speedDistribution)
                .map(([speed, count]) => ({ speed: parseFloat(speed), count }))
                .sort((a, b) => a.speed - b.speed);

            // POLAR DATA
            const polarData = {};
            processedData.forEach(r => {
                const bin = Math.round(Math.abs(r.twa_cog) / 5) * 5;
                // Only include angles from 0-180¬∞
                if (bin >= 0 && bin <= 180) {
                    if (!polarData[bin]) polarData[bin] = [];
                    polarData[bin].push(r.speed);
                }
            });
            
            const polar = Object.entries(polarData)
                .filter(([_, speeds]) => speeds.length > 10)
                .map(([twa, speeds]) => {
                    const sorted = speeds.sort((a, b) => b - a);
                    const target = sorted[Math.floor(sorted.length * 0.1)];
                    const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                    return { twa: parseInt(twa), target, avg, count: speeds.length };
                })
                .sort((a, b) => a.twa - b.twa);

            // SAMPLE DATA
            const upwindSample = upwind.filter((_, i) => i % 5 === 0);
            const downwindSample = downwind.filter((_, i) => i % 5 === 0);

            // WIND SHIFT ANALYSIS
            const upwindData = processedData.filter(r => r.isUpwind && r.speed > 2);
            const avgUpwindTWA = upwindData.length > 0 ? upwindData.reduce((sum, r) => sum + Math.abs(r.twa_cog), 0) / upwindData.length : 0;
            let lifts = 0, headers = 0;
            let liftAngles = [], headerAngles = [];
            
            // Mark significant shifts on all data points for map visualization
            processedData.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                const shift = twa - avgUpwindTWA;
                r.isLift = shift < -5;
                r.isHeader = shift > 5;
                r.shiftAmount = shift;
            });
            
            upwindData.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                if (twa < avgUpwindTWA - 3) {
                    lifts++;
                    liftAngles.push(avgUpwindTWA - twa);
                } else if (twa > avgUpwindTWA + 3) {
                    headers++;
                    headerAngles.push(twa - avgUpwindTWA);
                }
            });
            const windAnalysis = {
                lifts,
                headers,
                liftPct: lifts + headers > 0 ? (lifts / (lifts + headers) * 100) : 0,
                headerPct: lifts + headers > 0 ? (headers / (lifts + headers) * 100) : 0,
                avgLiftAngle: liftAngles.length > 0 ? liftAngles.reduce((a,b) => a+b, 0) / liftAngles.length : 0,
                avgHeaderAngle: headerAngles.length > 0 ? headerAngles.reduce((a,b) => a+b, 0) / headerAngles.length : 0,
                avgUpwindTWA
            };

            // COURSE BIAS ANALYSIS
            const courseBias = {
                portTime,
                starboardTime,
                portPct: portPercent,
                starboardPct: starboardPercent
            };

            // COACHING TIPS
            const coachingTips = [];
            if (tackEfficiency < 85 && maneuvers.length > 0) {
                coachingTips.push({
                    category: "Tack Efficiency",
                    message: `Tack efficiency is ${tackEfficiency.toFixed(0)}%. Aim for 90%+ by maintaining speed through tacks`,
                    impact: `~${((90-tackEfficiency)/100 * maneuvers.length * 3).toFixed(0)} seconds per race`,
                    priority: tackEfficiency < 80 ? "high" : "medium"
                });
            }
            if (windAnalysis.liftPct < 40 && upwindData.length > 100) {
                coachingTips.push({
                    category: "Wind Shifts",
                    message: `Only ${windAnalysis.liftPct.toFixed(0)}% on lifts. Tack on headers more aggressively`,
                    impact: "Potentially 30-60 seconds per leg",
                    priority: "high"
                });
            }
            const biasDiff = Math.abs(portPercent - 50);
            if (biasDiff > 20) {
                const favored = portPercent > 50 ? "port" : "starboard";
                coachingTips.push({
                    category: "Course Balance",
                    message: `${biasDiff.toFixed(0)}% bias toward ${favored} tack. Consider if this matches the favored side`,
                    impact: "Strategic - depends on conditions",
                    priority: "medium"
                });
            }

            // GENERATE SUGGESTIONS
            const suggestions = generateSuggestions({
                boatHandlingScore,
                avgLeeway,
                vmgEfficiency,
                timeInZone,
                tackEfficiency,
                avgTackLoss,
                distanceEfficiency,
                bestHeelUp,
                bestTrimUp,
                portPercent,
                starboardPercent,
                speedRatio
            });

            analysis = {
                dataPoints: processedData.length,
                predominantHeadings,
                optimalHeelUp: bestHeelUp,
                optimalHeelDown: bestHeelDown,
                optimalTrimUp: bestTrimUp,
                optimalTrimDown: bestTrimDown,
                vmgEfficiency, avgVMG, bestVMG: bestVMGUp,
                timeInZone,
                leeway: avgLeeway,
                bestPointing,
                portPercent, starboardPercent,
                avgUpwindSpeed, avgDownwindSpeed, speedRatio,
                tacksCount: tacks.length,
                gybesCount: gybes.length,
                tackEfficiency: tacks.length > 0 ? tacks.reduce((sum, t) => sum + t.efficiency, 0) / tacks.length : 0,
                gybeEfficiency: gybes.length > 0 ? gybes.reduce((sum, g) => sum + g.efficiency, 0) / gybes.length : 0,
                avgTackLoss: tacks.length > 0 ? tacks.reduce((sum, t) => sum + t.distanceLost, 0) / tacks.length : 0,
                avgGybeLoss: gybes.length > 0 ? gybes.reduce((sum, g) => sum + g.distanceLost, 0) / gybes.length : 0,
                maneuvers,
                tacks,
                gybes,
                boatHandlingScore,
                distanceEfficiency,
                trackData: processedData,
                heelDistribution: heelDistribution.sort((a, b) => a.heel - b.heel),
                heelDistributionUpwind: upwindAll.map(r => Math.abs(r.heel)),
                heelDistributionDownwind: downwindAll.map(r => Math.abs(r.heel)),
                speedDistributionUpwind: upwindAll.map(r => r.speed),
                speedDistributionDownwind: downwindAll.map(r => r.speed),
                twaDist,
                speedDist,
                polar,
                upwindSample,
                downwindSample,
                windAnalysis,
                courseBias,
                coachingTips,
                suggestions,
                heelDataQuality: {
                    upwindSamples: upwind.length,
                    downwindSamples: downwind.length,
                    minSamplesPerBin: 50,
                    reliable: upwind.length > 500
                }
            };

            // ADDITIONAL ANALYSIS: Heel by wind speed segments
            const lightAir = upwind.filter(r => r.speed >= 3 && r.speed < 5); // ~5-10 kts true wind
            const moderateAir = upwind.filter(r => r.speed >= 5 && r.speed < 7); // ~10-15 kts true wind
            
            let optimalHeelLightAir = bestHeelUp;
            let optimalHeelModerateAir = bestHeelUp;
            
            if (lightAir.length > 100) {
                const heelBinsLight = {};
                lightAir.forEach(r => {
                    const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                    if (!heelBinsLight[bin]) heelBinsLight[bin] = [];
                    heelBinsLight[bin].push(r.vmg);
                });
                
                let bestVMG = -999;
                for (const [heel, vmgs] of Object.entries(heelBinsLight)) {
                    if (vmgs.length < 20) continue;
                    const sorted = vmgs.sort((a, b) => b - a);
                    const p90 = sorted[Math.floor(sorted.length * 0.1)];
                    if (p90 > bestVMG) {
                        bestVMG = p90;
                        optimalHeelLightAir = parseInt(heel);
                    }
                }
            }
            
            if (moderateAir.length > 100) {
                const heelBinsMod = {};
                moderateAir.forEach(r => {
                    const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                    if (!heelBinsMod[bin]) heelBinsMod[bin] = [];
                    heelBinsMod[bin].push(r.vmg);
                });
                
                let bestVMG = -999;
                for (const [heel, vmgs] of Object.entries(heelBinsMod)) {
                    if (vmgs.length < 20) continue;
                    const sorted = vmgs.sort((a, b) => b - a);
                    const p90 = sorted[Math.floor(sorted.length * 0.1)];
                    if (p90 > bestVMG) {
                        bestVMG = p90;
                        optimalHeelModerateAir = parseInt(heel);
                    }
                }
            }
            
            analysis.heelByWindSpeed = {
                lightAir: {
                    samples: lightAir.length,
                    optimal: optimalHeelLightAir,
                    speedRange: '3-5 kts boat speed (~5-10 kts TWS)'
                },
                moderateAir: {
                    samples: moderateAir.length,
                    optimal: optimalHeelModerateAir,
                    speedRange: '5-7 kts boat speed (~10-15 kts TWS)'
                }
            };
            
            // LEEWAY DIAGNOSIS
            const leewayDiagnosis = [];
            if (avgLeeway > 15) {
                leewayDiagnosis.push({
                    severity: 'critical',
                    issue: `Excessive leeway (${avgLeeway.toFixed(0)}¬∞) - Normal range is 3-8¬∞`,
                    possibleCauses: [
                        'Heading sensor calibration error (magnetic declination offset)',
                        'GPS COG lag during maneuvers (not true leeway)',
                        'Centerboard not fully deployed',
                        'Damaged or fouled foils'
                    ],
                    recommendation: 'Most likely: Heading sensor calibration. Test in straight-line light air - true leeway should be <5¬∞.'
                });
            }
            
            analysis.leewayAnalysis = {
                average: avgLeeway,
                diagnosis: leewayDiagnosis,
                concernLevel: avgLeeway > 15 ? 'critical' : avgLeeway > 10 ? 'moderate' : 'good'
            };
            
            // TACK TIMING ANALYSIS - Were tacks on headers?
            const tackTimingAnalysis = [];
            let tacksOnHeaders = 0;
            let tacksOnLifts = 0;
            let tacksNeutral = 0;
            
            maneuvers.filter(m => m.type === 'Tack').forEach(tack => {
                // Find the data point for this tack
                const tackIdx = processedData.findIndex(d => 
                    Math.abs(d.lat - tack.lat) < 0.0001 && Math.abs(d.lon - tack.lon) < 0.0001
                );
                
                if (tackIdx > 5 && tackIdx < processedData.length - 5) {
                    // Check average TWA deviation in 30 seconds before tack
                    const preTackWindow = processedData.slice(Math.max(0, tackIdx - 30), tackIdx);
                    const avgShift = preTackWindow
                        .filter(d => d.isUpwind)
                        .reduce((sum, d) => sum + (d.shiftAmount || 0), 0) / preTackWindow.length;
                    
                    tack.windShift = avgShift;
                    tack.tackTiming = avgShift > 3 ? 'header' : avgShift < -3 ? 'lift' : 'neutral';
                    
                    if (avgShift > 3) tacksOnHeaders++;
                    else if (avgShift < -3) tacksOnLifts++;
                    else tacksNeutral++;
                }
            });
            
            // Calculate tack timing score
            const totalTacks = tacksOnHeaders + tacksOnLifts + tacksNeutral;
            const tackTimingScore = totalTacks > 0 ? (tacksOnHeaders / totalTacks * 100) : 0;
            
            if (tacksOnHeaders + tacksOnLifts > 5) {
                tackTimingAnalysis.push({
                    metric: 'Tacking on Headers',
                    value: `${tacksOnHeaders} of ${totalTacks} tacks (${tackTimingScore.toFixed(0)}%)`,
                    assessment: tackTimingScore > 60 ? 'excellent' : tackTimingScore > 40 ? 'good' : 'needs improvement',
                    recommendation: tackTimingScore < 50 ? 
                        'Tack more aggressively on headers to minimize time on unfavorable tack' :
                        'Good wind shift awareness - keep tacking on headers'
                });
                
                if (tacksOnLifts > tacksOnHeaders) {
                    tackTimingAnalysis.push({
                        metric: 'Tacks on Lifts',
                        value: `${tacksOnLifts} tacks during favorable conditions`,
                        assessment: 'concerning',
                        recommendation: 'Avoid tacking when lifted - stay on the lifted tack as long as possible'
                    });
                }
            }
            
            analysis.tackTiming = {
                onHeaders: tacksOnHeaders,
                onLifts: tacksOnLifts,
                neutral: tacksNeutral,
                score: tackTimingScore,
                analysis: tackTimingAnalysis
            };
            
            console.log(`‚öì Heel by wind: Light ${optimalHeelLightAir}¬∞ (${lightAir.length} pts), Moderate ${optimalHeelModerateAir}¬∞ (${moderateAir.length} pts)`);
            console.log(`‚öì Leeway: ${avgLeeway.toFixed(1)}¬∞ - ${analysis.leewayAnalysis.concernLevel.toUpperCase()}`);

            // CALCULATE POINTING ANGLE (tightest TWA with good VMG)
            const tightUpwind = upwind.filter(r => r.vmg > 0);
            const twaByAngle = {};
            tightUpwind.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                const bin = Math.round(twa / 2) * 2;
                if (!twaByAngle[bin]) twaByAngle[bin] = [];
                twaByAngle[bin].push(r.vmg);
            });
            
            let bestPointingAngle = 45; // Default for Melges 15
            let bestPointingVMG = 0;
            
            // Find tightest angle where we still maintain good VMG (>90% of max)
            for (let angle = 30; angle <= 55; angle += 2) {
                if (!twaByAngle[angle] || twaByAngle[angle].length < 30) continue;
                const avgVMG = twaByAngle[angle].reduce((a, b) => a + b, 0) / twaByAngle[angle].length;
                if (avgVMG > bestPointingVMG * 0.9 && avgVMG > 0) {
                    bestPointingAngle = angle;
                    bestPointingVMG = Math.max(bestPointingVMG, avgVMG);
                }
            }
            
            // Laylines calculation - these are GEOGRAPHIC LINES from a mark
            const detectedWindDir = predominantHeadings.estimatedWindDir;
            
            analysis.laylines = {
                pointingAngle: bestPointingAngle,
                pointingVMG: bestPointingVMG,
                windDirection: detectedWindDir,
                // These are the HEADINGS of the laylines (lines extending from mark)
                portLaylineHeading: (detectedWindDir + bestPointingAngle) % 360,
                starboardLaylineHeading: (detectedWindDir - bestPointingAngle + 360) % 360,
                // These are the headings YOU sail when ON the layline
                portTackHeading: (detectedWindDir + bestPointingAngle) % 360,
                starboardTackHeading: (detectedWindDir - bestPointingAngle + 360) % 360,
                needsMark: true // Indicates user needs to place mark for actual laylines
            };
            
            // DOWNWIND LAYLINES - Calculate optimal reaching angles for asymmetric
            const downwindData = processedData.filter(r => r.isDownwind && r.speed > 2);
            const downwindByAngle = {};
            
            downwindData.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                const bin = Math.round(twa / 5) * 5; // 5-degree bins
                if (!downwindByAngle[bin]) downwindByAngle[bin] = [];
                downwindByAngle[bin].push(r.vmg);
            });
            
            let bestReachingAngle = 135; // Default for asymmetric
            let bestReachingVMG = 0;
            
            // Find optimal reaching angle (usually 120-150¬∞ for asymmetric spinnaker)
            for (let angle = 100; angle <= 170; angle += 5) {
                if (!downwindByAngle[angle] || downwindByAngle[angle].length < 20) continue;
                const avgVMG = downwindByAngle[angle].reduce((a, b) => a + b, 0) / downwindByAngle[angle].length;
                if (Math.abs(avgVMG) > Math.abs(bestReachingVMG)) {
                    bestReachingAngle = angle;
                    bestReachingVMG = avgVMG;
                }
            }
            
            analysis.downwindLaylines = {
                reachingAngle: bestReachingAngle,
                reachingVMG: Math.abs(bestReachingVMG),
                windDirection: detectedWindDir,
                // Downwind laylines extend upwind from leeward mark
                portGybeHeading: (detectedWindDir + bestReachingAngle) % 360,
                starboardGybeHeading: (detectedWindDir - bestReachingAngle + 360) % 360,
                needsMark: true
            };
            
            console.log(`üìê Pointing: Best ${bestPointingAngle}¬∞ TWA @ ${bestPointingVMG.toFixed(2)} VMG`);
            console.log(`üìê Reaching: Best ${bestReachingAngle}¬∞ TWA @ ${Math.abs(bestReachingVMG).toFixed(2)} VMG downwind`);
            console.log(`‚õµ Tack timing: ${tacksOnHeaders} on headers, ${tacksOnLifts} on lifts, ${tacksNeutral} neutral`);

            // STORE RACE RESULTS FOR COMPARISON
            if (selectedRace !== 'all') {
                raceResults[selectedRace] = {
                    raceId: selectedRace,
                    avgVMG: avgVMG,
                    bestVMG: bestVMGUp,
                    vmgEfficiency: vmgEfficiency,
                    tackEfficiency: analysis.tackEfficiency,
                    avgUpwindSpeed: avgUpwindSpeed,
                    optimalHeelUp: bestHeelUp,
                    leeway: avgLeeway,
                    tacksCount: tacks.length,
                    tackTimingScore: analysis.tackTiming.score,
                    boatHandlingScore: boatHandlingScore,
                    dataPoints: processedData.length
                };
            }

            // MULTI-RACE COMPARISON ANALYSIS
            const raceKeys = Object.keys(raceResults);
            if (raceKeys.length > 1) {
                const sortedByVMG = raceKeys.sort((a, b) => raceResults[b].avgVMG - raceResults[a].avgVMG);
                const bestRaceKey = sortedByVMG[0];
                const worstRaceKey = sortedByVMG[sortedByVMG.length - 1];
                
                const improvement = raceKeys.map((key, idx) => ({
                    race: key,
                    order: idx + 1,
                    vmg: raceResults[key].avgVMG,
                    tackEff: raceResults[key].tackEfficiency,
                    handling: raceResults[key].boatHandlingScore
                }));
                
                // Calculate consistency (coefficient of variation)
                const vmgs = raceKeys.map(k => raceResults[k].avgVMG);
                const avgVMGAll = vmgs.reduce((a, b) => a + b, 0) / vmgs.length;
                const stdDev = Math.sqrt(vmgs.map(v => Math.pow(v - avgVMGAll, 2)).reduce((a, b) => a + b) / vmgs.length);
                const consistency = stdDev / avgVMGAll * 100;
                
                analysis.multiRaceComparison = {
                    racesAnalyzed: raceKeys.length,
                    bestRace: {
                        id: bestRaceKey,
                        ...raceResults[bestRaceKey]
                    },
                    worstRace: {
                        id: worstRaceKey,
                        ...raceResults[worstRaceKey]
                    },
                    improvement: improvement,
                    consistency: {
                        vmgVariation: consistency,
                        assessment: consistency < 5 ? 'excellent' : consistency < 10 ? 'good' : consistency < 15 ? 'moderate' : 'inconsistent'
                    },
                    keyDifferences: []
                };
                
                // Identify key differences
                const best = raceResults[bestRaceKey];
                const worst = raceResults[worstRaceKey];
                
                if (best.tackEfficiency - worst.tackEfficiency > 10) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Tack Efficiency',
                        difference: `${(best.tackEfficiency - worst.tackEfficiency).toFixed(0)}% better in best race`,
                        impact: 'High - smoother tacks = more speed retention'
                    });
                }
                
                if (Math.abs(best.optimalHeelUp - worst.optimalHeelUp) > 5) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Heel Angle Consistency',
                        difference: `${best.optimalHeelUp}¬∞ vs ${worst.optimalHeelUp}¬∞ - ${Math.abs(best.optimalHeelUp - worst.optimalHeelUp).toFixed(0)}¬∞ variation`,
                        impact: 'Medium - indicates inconsistent technique or conditions'
                    });
                }
                
                if (best.tackTimingScore - worst.tackTimingScore > 20) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Tack Timing',
                        difference: `${(best.tackTimingScore - worst.tackTimingScore).toFixed(0)}% better wind shift awareness`,
                        impact: 'High - tacking on headers is critical for upwind speed'
                    });
                }
                
                console.log(`üèÜ Multi-race: Best=${bestRaceKey} (VMG ${best.avgVMG.toFixed(2)}), Worst=${worstRaceKey} (VMG ${worst.avgVMG.toFixed(2)}), Consistency=${consistency.toFixed(1)}%`);
            }

            console.log("‚úÖ Analysis complete");

            console.log("‚úÖ Analysis complete");
            console.log(`üìà Boat Handling: ${boatHandlingScore.toFixed(0)} (Tack:${tackScore.toFixed(0)} Leeway:${leewayScore.toFixed(0)} Dist:${distScore.toFixed(0)})`);
            console.log(`‚¨ÜÔ∏è Upwind optimal: ${bestHeelUp}¬∞ heel, ${bestTrimUp}¬∞ trim`);
            console.log(`‚¨áÔ∏è Downwind optimal: ${bestHeelDown}¬∞ heel, ${bestTrimDown}¬∞ trim`);
            
            // Hide status and show success
            hideStatus();
            showSuccess(`Analysis complete! ${filteredData.length} points, ${tacks.length} tacks, ${gybes.length} gybes`);
            
            // Show new controls
            document.getElementById('maneuverTuner').style.display = 'block';
            document.getElementById('heelOptions').style.display = 'block';
            document.getElementById('raceDateContainer').style.display = 'block';
            document.getElementById('generatePDF').style.display = 'block';
            document.getElementById('pdfNote').style.display = 'block';
            
            // Set default race date from first timestamp if available
            if (analysis.trackData && analysis.trackData.length > 0) {
                const firstTimestamp = analysis.trackData[0].timestamp;
                if (firstTimestamp) {
                    const raceDate = new Date(firstTimestamp);
                    const dateStr = raceDate.toISOString().split('T')[0];
                    document.getElementById('raceDate').value = dateStr;
                    
                    // Also set in export tab
                    const exportDateInput = document.getElementById('raceDateExport');
                    if (exportDateInput) {
                        exportDateInput.value = dateStr;
                    }
                    
                    // Sync between the two inputs
                    document.getElementById('raceDate').addEventListener('change', function() {
                        const exportInput = document.getElementById('raceDateExport');
                        if (exportInput) exportInput.value = this.value;
                    });
                    
                    if (exportDateInput) {
                        exportDateInput.addEventListener('change', function() {
                            const sidebarInput = document.getElementById('raceDate');
                            if (sidebarInput) sidebarInput.value = this.value;
                        });
                    }
                }
            }
            
            // Test that button is clickable
            setTimeout(() => {
                const pdfBtn = document.getElementById('generatePDF');
                console.log("üìÑ PDF button element:", pdfBtn);
                console.log("üìÑ Button visible:", pdfBtn.offsetParent !== null);
                console.log("üìÑ Button disabled:", pdfBtn.disabled);
            }, 100);
            
            displayResults();
        }

        function generateSuggestions(metrics) {
            const suggestions = [];

            // Critical issues (score impact > 20 points each)
            if (metrics.avgLeeway > 12) {
                suggestions.push({
                    priority: 'CRITICAL',
                    icon: 'üö®',
                    title: 'Severe Leeway Problem',
                    issue: `${metrics.avgLeeway.toFixed(1)}¬∞ leeway is costing you ~${((metrics.avgLeeway - 5) * 5).toFixed(0)} points`,
                    actions: [
                        'Sail MUCH flatter - target ' + metrics.bestHeelUp + '¬∞ heel (you are probably over 15-20¬∞)',
                        'Check centerboard is FULLY down and not damaged',
                        'Clean bottom immediately - growth adds massive leeway',
                        'Ease sheets 2-3¬∞ and foot off to build speed before pointing'
                    ]
                });
            } else if (metrics.avgLeeway > 8) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: '‚ö†Ô∏è',
                    title: 'High Leeway',
                    issue: `${metrics.avgLeeway.toFixed(1)}¬∞ leeway is costing ${((metrics.avgLeeway - 5) * 5).toFixed(0)} points`,
                    actions: [
                        'Sail flatter - target ' + metrics.bestHeelUp + '¬∞ heel',
                        'Check centerboard position',
                        'Verify sail trim is not too tight'
                    ]
                });
            }

            // Tack efficiency
            if (metrics.tackEfficiency < 75 && metrics.avgTackLoss > 20) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: 'üîÑ',
                    title: 'Poor Tack Execution',
                    issue: `${metrics.tackEfficiency.toFixed(0)}% efficiency, losing ${metrics.avgTackLoss.toFixed(1)}m per tack`,
                    actions: [
                        'Tack from full speed (do not pinch before tacking)',
                        'Smooth helm - count to 3 during turn',
                        'Sheet in AS bow crosses wind (not before, not after)',
                        'Hike immediately as boat flattens on new tack',
                        'Foot off 2-3¬∞ to rebuild speed before pointing'
                    ]
                });
            } else if (metrics.tackEfficiency < 85) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üîÑ',
                    title: 'Tack Efficiency',
                    issue: `${metrics.tackEfficiency.toFixed(0)}% efficiency, ${metrics.avgTackLoss.toFixed(1)}m loss per tack`,
                    actions: [
                        'Practice smooth helmsmanship',
                        'Time sheet trim with wind crossing bow',
                        'Early hiking on exit'
                    ]
                });
            }

            // VMG consistency
            if (metrics.vmgEfficiency < 70) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: 'üìâ',
                    title: 'Inconsistent VMG',
                    issue: `Only ${metrics.vmgEfficiency.toFixed(0)}% of optimal VMG - you CAN sail faster`,
                    actions: [
                        'Your top 10% shows ' + metrics.bestVMG + ' kts VMG is possible',
                        'Maintain ' + metrics.bestHeelUp + '¬∞ heel consistently',
                        'Set optimal trim (' + (metrics.bestTrimUp > 0 ? '+' : '') + metrics.bestTrimUp + '¬∞ bow up/down) and leave it',
                        'Stop pinching - maintain speed over pointing',
                        'Use telltales: both streaming = good, luffing = too tight'
                    ]
                });
            } else if (metrics.vmgEfficiency < 80) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üìä',
                    title: 'VMG Consistency',
                    issue: `${metrics.vmgEfficiency.toFixed(0)}% efficiency - room to improve`,
                    actions: [
                        'Focus on maintaining optimal heel angle',
                        'Minimize steering corrections',
                        'Develop "feel" for optimal groove'
                    ]
                });
            }

            // Time in optimal zone
            if (metrics.timeInZone < 40) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: '‚è±Ô∏è',
                    title: 'Setup Inconsistency',
                    issue: `Only ${metrics.timeInZone.toFixed(0)}% of time in optimal zone`,
                    actions: [
                        'Target: ' + metrics.bestHeelUp + '¬∞ heel ¬±3¬∞',
                        'Target: ' + (metrics.bestTrimUp > 0 ? '+' : '') + metrics.bestTrimUp + '¬∞ trim ¬±3¬∞',
                        'Make SMALL adjustments constantly vs big corrections',
                        'Visual cue: mark optimal heel with tape on boat'
                    ]
                });
            }

            // Distance efficiency
            if (metrics.distanceEfficiency < 65) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üìè',
                    title: 'Poor Course Management',
                    issue: `${metrics.distanceEfficiency.toFixed(0)}% distance efficiency - sailing extra distance`,
                    actions: [
                        'Reduce tack count - plan your shifts',
                        'Do not overstand laylines (approach with 5¬∞ safety margin)',
                        'Tack on headers, sail lifts longer',
                        'Each unnecessary tack costs ' + metrics.avgTackLoss.toFixed(1) + 'm'
                    ]
                });
            }

            // Port/Starboard balance
            if (Math.abs(metrics.portPercent - metrics.starboardPercent) > 20) {
                const favored = metrics.portPercent > metrics.starboardPercent ? 'port' : 'starboard';
                suggestions.push({
                    priority: 'LOW',
                    icon: '‚öñÔ∏è',
                    title: 'Tack Imbalance',
                    issue: `Heavily favored ${favored} tack (${Math.max(metrics.portPercent, metrics.starboardPercent).toFixed(0)}%)`,
                    actions: [
                        'If intentional (persistent shift): Good strategy!',
                        'If unintentional: Sailing wrong angles or missing shifts',
                        'Check for current pushing you to one side'
                    ]
                });
            }

            // Speed ratio
            if (metrics.speedRatio < 1.15) {
                suggestions.push({
                    priority: 'LOW',
                    icon: 'üèÉ',
                    title: 'Weak Downwind Speed',
                    issue: `Speed ratio ${metrics.speedRatio.toFixed(2)}x - not much faster downwind`,
                    actions: [
                        'Ease sheets more downwind',
                        'Sail lower angles (140-160¬∞ TWA)',
                        'May be over-trimming offwind'
                    ]
                });
            }

            // If score is good, congratulate
            if (metrics.boatHandlingScore >= 80) {
                suggestions.push({
                    priority: 'GOOD',
                    icon: 'üèÜ',
                    title: 'Excellent Performance!',
                    issue: 'Score of ' + metrics.boatHandlingScore.toFixed(0) + '/100 is very competitive',
                    actions: [
                        'Keep doing what you are doing',
                        'Focus on marginal gains',
                        'Compare your polar to class targets'
                    ]
                });
            }

            return suggestions.sort((a, b) => {
                const priority = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'GOOD': 4 };
                return priority[a.priority] - priority[b.priority];
            });
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        
        // TAB SWITCHING FUNCTION
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            const selectedTab = document.getElementById(`tab-${tabName}`);
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // Activate corresponding button
            const selectedBtn = document.getElementById(`tab-btn-${tabName}`);
            if (selectedBtn) {
                selectedBtn.classList.add('active');
            }
            
            // Update URL hash without scrolling
            history.replaceState(null, null, `#${tabName}`);
            
            // Save preference
            try {
                localStorage.setItem('sailai-last-tab', tabName);
            } catch (e) {
                // Ignore localStorage errors
            }
            
            // Trigger resize for charts (they need to redraw when container changes)
            setTimeout(() => {
                window.dispatchEvent(new Event('resize'));
            }, 100);
            
            // Load sessions when switching to Sessions tab
            if (tabName === 'sessions') {
                renderSessionLibrary();
            }
            
            // Scroll to top of content
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Handle hash on load
        window.addEventListener('load', () => {
            const hash = window.location.hash.substring(1);
            const validTabs = ['overview', 'polar', 'handling', 'maneuvers', 'wind', 'map', 'analysis', 'export', 'sessions'];
            
            if (hash && validTabs.includes(hash)) {
                setTimeout(() => switchTab(hash), 500);
            } else {
                // Try to restore last tab from localStorage
                try {
                    const lastTab = localStorage.getItem('sailai-last-tab');
                    if (lastTab && validTabs.includes(lastTab)) {
                        setTimeout(() => switchTab(lastTab), 500);
                    }
                } catch (e) {
                    // Ignore
                }
            }
        });
        
        
        // ORGANIZE CONTENT INTO TABS - V0.9.17 FULL REORGANIZATION
        function organizeContentIntoTabs() {
            console.log('üìã Organizing content into tabs (v0.9.20 - FIXED)...');
            
            try {
                // Wait for all content to render in Overview first
                setTimeout(() => {
                    // CRITICAL: Move content TO other tabs FIRST
                    // Do NOT clean Overview until AFTER everything is moved
                    movePolarContent();
                    moveHandlingContent();
                    moveManeuverContent();
                    moveWindContent();
                    moveMapContent();
                    moveRaceAnalysis();
                    
                    // ONLY NOW clean Overview (after content safely moved)
                    createCleanOverview();
                    
                    console.log('‚úÖ Content reorganization complete!');
                }, 500);
            } catch (error) {
                console.error('‚ùå Error organizing content:', error);
            }
        }
        
        function movePolarContent() {
            const polarTab = document.getElementById('tab-polar');
            if (!polarTab) return;
            
            console.log('  üéØ Moving polar content...');
            
            // Tab already has header in HTML, don't add another one
            
            // Find polar diagram ONLY in Overview tab
            const overviewContainers = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .metric-box'));
            
            overviewContainers.forEach(container => {
                const heading = container.querySelector('h4');
                if (heading && heading.textContent.includes('Performance Polar Diagram')) {
                    // Move just the container, NOT the parent grid
                    polarTab.appendChild(container);
                    console.log('    ‚úÖ Moved: Performance Polar Diagram');
                }
            });
            
            // Add intro if we moved content (only once)
            if (polarTab.children.length > 1 && !polarTab.querySelector('.polar-intro')) {
                const intro = document.createElement('div');
                intro.className = 'polar-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>Your Performance Polar:</strong> Green = best 10% speed at each angle. 
                        Yellow = average. Red/Blue markers = optimal VMG angles.
                    </p>
                `;
                polarTab.insertBefore(intro, polarTab.children[1]);
            }
        }
        
        function moveHandlingContent() {
            const handlingTab = document.getElementById('tab-handling');
            if (!handlingTab) return;
            
            console.log('  ‚öì Moving handling content...');
            
            // Tab already has header, don't add duplicate
            
            // ONLY look at .bg-gray-800 and .metric-box sections
            const overviewSections = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .metric-box'));
            
            console.log(`  üîç Found ${overviewSections.length} sections in Overview`);
            
            overviewSections.forEach((section, index) => {
                const heading = section.querySelector('h2, h3, h4, summary');
                const text = heading ? heading.textContent : section.textContent.substring(0, 100);
                
                // Check if it has a table - if yes, DON'T move it (protects detailed metrics)
                const hasTable = section.querySelector('table') !== null;
                
                // Move: VMG vs Heel, VMG vs Trim, Heel Distribution, Speed Distribution, Optimal Heel, Leeway
                const shouldMove = !hasTable && (
                    text.includes('VMG vs Heel') || 
                    text.includes('VMG vs Trim') || 
                    text.includes('Heel Distribution') ||
                    text.includes('Speed Distribution') ||
                    text.includes('Optimal Heel') ||
                    text.includes('Leeway')
                );
                
                if (shouldMove && !handlingTab.contains(section)) {
                    handlingTab.appendChild(section);
                    console.log(`    ‚úÖ Moved: ${text.substring(0, 60)}`);
                } else if (hasTable) {
                    console.log(`    üõ°Ô∏è PROTECTED (table): ${text.substring(0, 60)}`);
                }
            });
            
            // Add single intro text (not repeated)
            if (handlingTab.children.length > 1 && !handlingTab.querySelector('.handling-intro')) {
                const intro = document.createElement('div');
                intro.className = 'handling-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>Optimize Your Trim:</strong> Green lines show optimal heel and trim for maximum VMG.
                    </p>
                `;
                handlingTab.insertBefore(intro, handlingTab.children[1]);
            }
        }
        
        function moveManeuverContent() {
            const maneuverTab = document.getElementById('tab-maneuvers');
            if (!maneuverTab) return;
            
            console.log('  üîÑ Moving maneuver content...');
            
            // Tab already has header, don't add duplicate
            
            // Find ALL sections in Overview
            const overviewSections = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .gradient-accent, #tab-overview details, #tab-overview .metric-box'));
            
            console.log(`  üîç Checking ${overviewSections.length} sections for maneuver content...`);
            
            overviewSections.forEach((section, index) => {
                const heading = section.querySelector('h2, h3, h4, summary');
                const text = heading ? heading.textContent : section.textContent.substring(0, 100);
                
                const shouldMove = 
                    text.includes('Tack') || 
                    text.includes('Gybe') || 
                    text.includes('Learning Curve') ||
                    text.includes('Maneuver') ||
                    text.includes('Performance Analysis') ||
                    text.includes('Speed Analysis') ||
                    text.includes('Individual') ||
                    text.includes('Top Performers') ||
                    text.includes('Need Impr') ||
                    text.includes('Efficiency: Speed');
                
                const shouldExclude = text.includes('GPS Track') ||
                    text.includes('Course Bias') ||
                    text.includes('Wind') ||
                    text.includes('Heel Distribution') ||
                    text.includes('Optimal Heel');
                
                if (shouldMove && !shouldExclude && !maneuverTab.contains(section)) {
                    maneuverTab.appendChild(section);
                    console.log(`    ‚úÖ Moved: ${text.substring(0, 80)}`);
                }
            });
            
            // Add single intro (not repeated)
            if (maneuverTab.children.length > 1 && !maneuverTab.querySelector('.maneuver-intro')) {
                const intro = document.createElement('div');
                intro.className = 'maneuver-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>Tack & Gybe Performance:</strong> Smooth, quick maneuvers minimize distance lost.
                    </p>
                `;
                maneuverTab.insertBefore(intro, maneuverTab.children[1]);
            }
        }
        
        function moveWindContent() {
            const windTab = document.getElementById('tab-wind');
            if (!windTab) return;
            
            console.log('  üí® Moving wind content...');
            
            // Tab already has header, don't add duplicate
            
            // Find wind sections ONLY in Overview
            const overviewSections = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .gradient-accent, #tab-overview .metric-box'));
            
            overviewSections.forEach(section => {
                const heading = section.querySelector('h3, h4');
                if (heading) {
                    const text = heading.textContent;
                    // Wind-specific content only
                    if (text.includes('Wind Shift') || 
                        text.includes('Wind Rose') || 
                        text.includes('TWA Distribution')) {
                        windTab.appendChild(section);
                        console.log(`    ‚úÖ Moved: ${text}`);
                    }
                }
            });
            
            // Add single intro (not repeated)
            if (windTab.children.length > 1 && !windTab.querySelector('.wind-intro')) {
                const intro = document.createElement('div');
                intro.className = 'wind-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>Wind & Tactics:</strong> Wind shift zones (green=lifts, red=headers), 
                        shift timeline, wind rose, and TWA distribution. Tack on headers, extend on lifts.
                    </p>
                `;
                windTab.insertBefore(intro, windTab.children[1]);
            }
        }
        
        function moveMapContent() {
            const mapTab = document.getElementById('tab-map');
            if (!mapTab) return;
            
            console.log('  üó∫Ô∏è Moving map content...');
            
            // Tab already has header, don't add duplicate
            
            // Find map and layline calculator ONLY in Overview
            const mapContainer = document.querySelector('#tab-overview #map')?.closest('.bg-gray-800');
            if (mapContainer) {
                mapTab.appendChild(mapContainer);
                console.log('    ‚úÖ Moved: Interactive GPS Map');
                
                // Make map taller in dedicated tab
                const mapElement = document.getElementById('map');
                if (mapElement) {
                    mapElement.style.minHeight = '700px';
                }
            }
            
            // Also move layline calculator, course bias, GPS Track, and GPS instructions to Map tab
            const overviewSections = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .gradient-accent, #tab-overview details, #tab-overview > *'));
            overviewSections.forEach(section => {
                const heading = section.querySelector('h2, h3, h4, summary');
                const text = heading ? heading.textContent : section.textContent.substring(0, 100);
                
                // Move: Layline, Course Bias, GPS Track, GPS Map instructions
                const shouldMove = text.includes('Layline') || 
                    text.includes('Course Bias') ||
                    text.includes('course bias') ||
                    text.includes('Bias') ||
                    text.includes('GPS Track') ||
                    text.includes('Using the GPS Map') ||
                    text.includes('üó∫Ô∏è') ||
                    text.includes('‚ÑπÔ∏è');
                
                if (shouldMove && !mapTab.contains(section)) {
                    mapTab.appendChild(section);
                    console.log(`    ‚úÖ Moved: ${text.substring(0, 60)}`);
                }
            });
            
            // Add single intro (not repeated)
            if (mapTab.children.length > 1 && !mapTab.querySelector('.map-intro')) {
                const intro = document.createElement('div');
                intro.className = 'map-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>GPS Track & Tactics:</strong> Interactive map with laylines, GPS track analysis, 
                        and course bias calculations. Toggle layers with controls.
                    </p>
                `;
                mapTab.insertBefore(intro, mapTab.children[1]);
            }
        }
        
        function moveRaceAnalysis() {
            const analysisTab = document.getElementById('tab-analysis');
            if (!analysisTab) return;
            
            console.log('  üéì Moving race analysis content...');
            
            // Tab already has header, don't add duplicate
            
            // Find all analysis/coaching content in Overview
            const overviewSections = Array.from(document.querySelectorAll('#tab-overview .bg-gray-800, #tab-overview .gradient-accent, #tab-overview details, #tab-overview > *'));
            
            overviewSections.forEach(section => {
                const heading = section.querySelector('h2, h3, h4, summary');
                const text = heading ? heading.textContent : section.textContent.substring(0, 100);
                
                // EXCLUDE detailed metrics table - MUST stay in Overview
                const isMetricsTable = text.includes('Detailed Metrics') ||
                    text.includes('Performance Breakdown') ||
                    text.includes('Extended Metrics') ||
                    text.includes('Key Metrics') ||
                    text.includes('Race Statistics') ||
                    text.includes('Detailed Performance');
                
                // Move: What To Do Next, Coaching Tips, Suggestions, etc.
                // BUT NOT metrics tables
                const shouldMove = !isMetricsTable && (
                    text.includes('What To Do Next') ||
                    text.includes('Coaching') ||
                    text.includes('Suggestions') ||
                    text.includes('Tips') ||
                    text.includes('üéì')
                );
                
                if (shouldMove && !analysisTab.contains(section)) {
                    analysisTab.appendChild(section);
                    console.log(`    ‚úÖ Moved: ${text.substring(0, 60)}`);
                }
            });
            
            // Add single intro (not repeated)
            if (analysisTab.children.length > 1 && !analysisTab.querySelector('.analysis-intro')) {
                const intro = document.createElement('div');
                intro.className = 'analysis-intro bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6';
                intro.innerHTML = `
                    <p class="text-sm text-gray-300">
                        <strong>Actionable Insights:</strong> Based on your data, here's what to focus on.
                    </p>
                `;
                analysisTab.insertBefore(intro, analysisTab.children[1]);
            }
        }
        
        function createCleanOverview() {
            const overviewTab = document.getElementById('tab-overview');
            if (!overviewTab) return;
            
            console.log('  üßπ Finalizing Overview tab...');
            
            // Hide sections that belong in other tabs (Performance Analysis, Tack/Gybe analysis sections)
            const headersToHide = [
                'Performance Analysis',
                'Tack Speed Analysis',
                'Gybe Speed Analysis',
                'Individual Tack Analysis',
                'Individual Gybe Analysis'
            ];
            
            const allHeaders = overviewTab.querySelectorAll('h3.section-header');
            allHeaders.forEach(header => {
                if (headersToHide.some(text => header.textContent.includes(text))) {
                    // Hide this header and all content until next section-header or section-divider
                    let current = header;
                    let toHide = [header];
                    
                    // Collect all elements to hide (until next major section)
                    while (current.nextElementSibling) {
                        current = current.nextElementSibling;
                        if (current.classList.contains('section-header') || current.classList.contains('section-divider')) {
                            // Stop before next section, but hide divider if it's right before this section
                            if (current.classList.contains('section-divider') && current.previousElementSibling === toHide[toHide.length - 1]) {
                                // Find divider before our section too
                                let prevDiv = header.previousElementSibling;
                                if (prevDiv && prevDiv.classList.contains('section-divider')) {
                                    toHide.unshift(prevDiv);
                                }
                            }
                            break;
                        }
                        toHide.push(current);
                    }
                    
                    // Hide all collected elements
                    toHide.forEach(el => {
                        el.style.display = 'none';
                    });
                    
                    console.log(`    üóëÔ∏è Hid: ${header.textContent}`);
                }
            });
            
            console.log('  ‚úÖ Overview finalized - unwanted sections hidden');
        }
        
        function displayResults() {
            if (!analysis) return;

            document.getElementById('sessionInfo').classList.remove('hidden');
            document.getElementById('dataPoints').textContent = `Data points: ${analysis.dataPoints.toLocaleString()}`;
            
            // Auto-populate session date if empty
            const sessionDateField = document.getElementById('sessionDate');
            if (sessionDateField && !sessionDateField.value) {
                const today = new Date().toISOString().split('T')[0];
                sessionDateField.value = today;
            }
            
            document.getElementById('dataQuality').innerHTML = `
                <div class="text-xs mt-1">Quality: <span class="metric-badge ${analysis.upwindSample.length > 500 ? 'badge-excellent' : analysis.upwindSample.length > 200 ? 'badge-good' : 'badge-moderate'}" style="font-size: 0.65rem !important; padding: 0.125rem 0.5rem !important;">${analysis.upwindSample.length > 500 ? 'EXCELLENT' : analysis.upwindSample.length > 200 ? 'GOOD' : 'LIMITED'}</span></div>
            `;

            const mainContent = document.getElementById('mainContent');
            mainContent.innerHTML = `
                <!-- TAB NAVIGATION -->
                <div class="tab-navigation mb-6">
                    <div class="flex space-x-1 overflow-x-auto">
                        <button class="tab-button active" onclick="switchTab('overview')" id="tab-btn-overview">
                            <span class="hidden sm:inline">üìà Overview</span>
                            <span class="sm:hidden">üìà</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('polar')" id="tab-btn-polar">
                            <span class="hidden sm:inline">üéØ Polar</span>
                            <span class="sm:hidden">üéØ</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('handling')" id="tab-btn-handling">
                            <span class="hidden sm:inline">‚öì Handling</span>
                            <span class="sm:hidden">‚öì</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('maneuvers')" id="tab-btn-maneuvers">
                            <span class="hidden sm:inline">üîÑ Maneuvers</span>
                            <span class="sm:hidden">üîÑ</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('wind')" id="tab-btn-wind">
                            <span class="hidden sm:inline">üí® Wind</span>
                            <span class="sm:hidden">üí®</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('map')" id="tab-btn-map">
                            <span class="hidden sm:inline">üó∫Ô∏è Map</span>
                            <span class="sm:hidden">üó∫Ô∏è</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('analysis')" id="tab-btn-analysis">
                            <span class="hidden sm:inline">üéì Analysis</span>
                            <span class="sm:hidden">üéì</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('export')" id="tab-btn-export">
                            <span class="hidden sm:inline">üìÑ Export</span>
                            <span class="sm:hidden">üìÑ</span>
                        </button>
                        <button class="tab-button" onclick="switchTab('sessions')" id="tab-btn-sessions">
                            <span class="hidden sm:inline">üíæ Sessions</span>
                            <span class="sm:hidden">üíæ</span>
                        </button>
                    </div>
                </div>
                
                <!-- OVERVIEW TAB -->
                <div id="tab-overview" class="tab-content active">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-3xl font-bold text-blue-200">Performance Overview</h2>
                    <button id="pdfButtonMain" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold text-sm shadow-lg">
                        üìÑ PDF Report
                    </button>
                </div>
                
                <p class="text-base text-gray-400 mb-8" style="font-weight: 400;">Data-driven insights from your GPS sailing track</p>
                
                <!-- Top scores -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(30, 58, 95, 0.95), rgba(15, 40, 70, 0.9)); border-color: rgba(96, 165, 250, 0.7);">
                        <div class="text-2xl font-bold text-blue-200 mb-3 flex items-center">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                                <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path>
                                <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path>
                                <path d="M4 22h16"></path>
                                <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path>
                                <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path>
                                <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path>
                            </svg>
                            Boat Handling Score
                            ${createTooltip('boatHandling')}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.boatHandlingScore.toFixed(0)}
                            ${metricBadge(analysis.boatHandlingScore, 80, 70)}
                        </div>
                        <div class="text-xl font-semibold">
                            <span class="metric-badge ${analysis.boatHandlingScore >= 80 ? 'badge-excellent' : analysis.boatHandlingScore >= 60 ? 'badge-good' : 'badge-poor'}">
                                ${analysis.boatHandlingScore >= 80 ? 'EXCELLENT' : analysis.boatHandlingScore >= 60 ? 'GOOD' : 'NEEDS WORK'}
                            </span>
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Combined performance grade</div>
                        ${expandableHelp('How is boat handling scored?', `
                            <p><strong>Formula: Weighted Average</strong></p>
                            <code>Score = 0.4√óTackScore + 0.3√óLeewayScore + 0.3√óDistScore</code>
                            
                            <p><strong>Component Calculations:</strong></p>
                            <ul>
                                <li><strong>Tack Score:</strong> (Tack Efficiency - 70) √ó 3.33, scaled 0-100
                                    <br/>Your tack efficiency: ${analysis.tackEfficiency ? analysis.tackEfficiency.toFixed(0) : 'N/A'}%</li>
                                <li><strong>Leeway Score:</strong> 100 - (Leeway √ó 5), lower leeway = higher score
                                    <br/>Your leeway: ${analysis.leewayAnalysis ? analysis.leewayAnalysis.average.toFixed(1) : 'N/A'}¬∞</li>
                                <li><strong>Distance Score:</strong> Efficiency of course sailed
                                    <br/>Your distance efficiency: ${analysis.distanceEfficiency ? analysis.distanceEfficiency.toFixed(0) : 'N/A'}%</li>
                            </ul>
                            
                            <p><strong>Score Interpretation:</strong></p>
                            <ul>
                                <li><strong>80-100:</strong> Excellent fundamentals, focus on tactics</li>
                                <li><strong>70-80:</strong> Good basics, refine technique</li>
                                <li><strong>60-70:</strong> Competent, room for improvement</li>
                                <li><strong>&lt;60:</strong> Focus on boat handling drills</li>
                            </ul>
                            
                            <p><strong>Your score: ${analysis.boatHandlingScore.toFixed(0)}/100</strong> - ${
                                analysis.boatHandlingScore >= 80 ? 'Excellent handling! Your fundamentals are solid.' :
                                analysis.boatHandlingScore >= 70 ? 'Good handling with room to refine details.' :
                                analysis.boatHandlingScore >= 60 ? 'Competent but focus on improving key areas.' :
                                'Work on fundamentals: smooth tacks, minimize leeway, sail efficient course.'
                            }</p>
                        `)}
                    </div>

                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(30, 58, 95, 0.95), rgba(15, 40, 70, 0.9)); border-color: rgba(96, 165, 250, 0.7);">
                        <div class="text-2xl font-bold text-blue-200 mb-3 flex items-center">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                                <circle cx="12" cy="12" r="10"></circle>
                                <circle cx="12" cy="12" r="6"></circle>
                                <circle cx="12" cy="12" r="2"></circle>
                            </svg>
                            VMG Efficiency
                            ${createTooltip('vmg')}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.vmgEfficiency.toFixed(0)}%
                            ${metricBadge(analysis.vmgEfficiency, 85, 75)}
                        </div>
                        <div class="text-xl font-semibold">
                            <span class="metric-badge ${analysis.vmgEfficiency >= 85 ? 'badge-excellent' : analysis.vmgEfficiency >= 75 ? 'badge-good' : 'badge-poor'}">
                                ${analysis.vmgEfficiency >= 85 ? 'EXCELLENT' : analysis.vmgEfficiency >= 75 ? 'GOOD' : 'FAIR'}
                            </span>
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Avg: ${analysis.avgVMG.toFixed(2)} / Best: ${analysis.bestVMG.toFixed(2)} kts</div>
                        ${expandableHelp('Understanding VMG efficiency', `
                            <p><strong>Formula:</strong></p>
                            <code>Efficiency = (Average VMG / Best VMG) √ó 100</code>
                            
                            <p><strong>Your Numbers:</strong></p>
                            <ul>
                                <li>Best VMG: ${analysis.bestVMG.toFixed(2)} kts (90th percentile)</li>
                                <li>Average VMG: ${analysis.avgVMG.toFixed(2)} kts</li>
                                <li>Efficiency: ${analysis.vmgEfficiency.toFixed(1)}%</li>
                            </ul>
                            
                            <p><strong>What this means:</strong></p>
                            <ul>
                                <li><strong>>85%:</strong> Very consistent, sailing at peak most of the time</li>
                                <li><strong>75-85%:</strong> Good consistency, some room to improve</li>
                                <li><strong>65-75%:</strong> Inconsistent, losing speed in many moments</li>
                                <li><strong>&lt;65%:</strong> Rarely achieving best performance, focus on technique</li>
                            </ul>
                            
                            <p><strong>How to improve:</strong> Identify when VMG drops (lulls? waves? mistakes?) and minimize those moments. The goal is to spend MORE time sailing at your "best VMG" level. Review wind shift timeline and heel consistency to find where you're losing speed.</p>
                            
                            <p><strong>Example:</strong> If you're at 75% efficiency, you're leaving 25% of potential speed on the table. Improving to 85% would gain you ~10 seconds per upwind leg!</p>
                        `)}
                    </div>

                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(30, 58, 95, 0.95), rgba(15, 40, 70, 0.9)); border-color: rgba(96, 165, 250, 0.7);">
                        <div class="text-2xl font-bold text-blue-200 mb-3 flex items-center">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                                <circle cx="12" cy="12" r="10"></circle>
                                <polyline points="12 6 12 12 16 14"></polyline>
                            </svg>
                            Time in Optimal Zone
                            ${createTooltip('timeInZone')}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.timeInZone.toFixed(0)}%
                            ${metricBadge(analysis.timeInZone, 60, 40)}
                        </div>
                        <div class="text-xl font-semibold">
                            <span class="metric-badge ${analysis.timeInZone >= 60 ? 'badge-excellent' : analysis.timeInZone >= 40 ? 'badge-good' : 'badge-poor'}">
                                ${analysis.timeInZone >= 60 ? 'EXCELLENT' : analysis.timeInZone >= 40 ? 'GOOD' : 'FAIR'}
                            </span>
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Within ¬±3¬∞ optimal</div>
                        ${expandableHelp('What is the optimal zone?', `
                            <p><strong>Definition:</strong></p>
                            <ul>
                                <li>Optimal heel: ${analysis.optimalHeelUp}¬∞</li>
                                <li>Optimal trim: ${analysis.optimalTrimUp}¬∞</li>
                                <li>Zone: Within ¬±3¬∞ of both optimal values</li>
                                <li>¬±3¬∞ allows for waves, puffs, steering adjustments</li>
                            </ul>
                            
                            <p><strong>Your Data:</strong></p>
                            <ul>
                                <li>${analysis.timeInZone.toFixed(0)}% of time in optimal zone</li>
                                <li>This means you're sailing with ideal heel/trim ${analysis.timeInZone.toFixed(0)}% of the time</li>
                            </ul>
                            
                            <p><strong>Interpretation:</strong></p>
                            <ul>
                                <li><strong>>60%:</strong> Excellent consistency, technique locked in</li>
                                <li><strong>40-60%:</strong> Good control, some variation</li>
                                <li><strong>20-40%:</strong> Inconsistent heel/trim control</li>
                                <li><strong>&lt;20%:</strong> Heel and trim all over the place, focus here</li>
                            </ul>
                            
                            <p><strong>Why ¬±3¬∞?</strong> This is a reasonable range that accounts for waves, puffs, and steering adjustments while still maintaining good performance. Tighter tolerance (¬±2¬∞) would be unrealistic in real conditions. Wider tolerance (¬±5¬∞) wouldn't be "optimal zone" anymore.</p>
                            
                            <p><strong>How to improve:</strong> Use tactile feedback (crew weight placement, sheet tension) to stay in the zone more consistently. Practice holding ${analysis.optimalHeelUp}¬∞ heel in different conditions until it becomes automatic.</p>
                        `)}
                    </div>
                </div>

                <!-- AUTO-DETECTED WIND DIRECTION (MOVED UP FOR EASY ACCESS WITH SLIDER) -->
                <div class="mb-8 bg-gradient-to-br from-blue-900 to-gray-800 p-5 rounded-xl border-2 border-blue-600 shadow-lg">
                    <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
                        üß≠ Auto-Detected Wind Direction
                        <span class="text-xs font-normal text-gray-400">(Verify with slider above!)</span>
                    </h3>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="bg-gray-900 bg-opacity-40 p-3 rounded-lg">
                            <div class="text-sm text-gray-400">Starboard Tack Heading</div>
                            <div class="text-3xl font-bold text-green-400">${analysis.predominantHeadings.peak1}¬∞</div>
                            <div class="text-xs text-gray-500">${analysis.predominantHeadings.peak1Count} samples</div>
                        </div>
                        <div class="bg-gray-900 bg-opacity-40 p-3 rounded-lg">
                            <div class="text-sm text-gray-400">Port Tack Heading</div>
                            <div class="text-3xl font-bold text-blue-400">${analysis.predominantHeadings.peak2}¬∞</div>
                            <div class="text-xs text-gray-500">${analysis.predominantHeadings.peak2Count} samples</div>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4 p-4 bg-yellow-900 bg-opacity-30 rounded-lg border border-yellow-600">
                        <div>
                            <div class="text-sm text-yellow-300 font-semibold">Wind Direction (FROM)</div>
                            <div class="text-2xl font-bold text-yellow-400">${analysis.predominantHeadings.estimatedWindDir.toFixed(0)}¬∞ ${getCompassDirection(analysis.predominantHeadings.estimatedWindDir)}</div>
                            <div class="text-xs text-gray-400 mt-1">Bisector of tack headings</div>
                        </div>
                        <div>
                            <div class="text-sm text-yellow-300 font-semibold">Average TWA</div>
                            <div class="text-2xl font-bold text-yellow-400">${analysis.predominantHeadings.avgTWA.toFixed(0)}¬∞</div>
                        </div>
                    </div>
                    <div class="mt-3 text-sm ${analysis.predominantHeadings.confidence === 'high' ? 'text-green-400' : analysis.predominantHeadings.confidence === 'medium' ? 'text-yellow-400' : 'text-red-400'}">
                        Confidence: <strong>${analysis.predominantHeadings.confidence.toUpperCase()}</strong> ${analysis.predominantHeadings.confidence !== 'high' ? '‚ö†Ô∏è Verify with wind slider above!' : '‚úÖ High confidence'}
                    </div>
                    <div class="mt-3 p-3 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <div class="text-xs text-yellow-400 font-semibold mb-1">‚ö†Ô∏è ALWAYS VERIFY: Use Wind Direction Slider Above</div>
                        <div class="text-xs text-gray-300">
                            Auto-detection can be wrong due to:
                            <ul class="list-disc ml-4 mt-1">
                                <li>Pre-race maneuvering</li>
                                <li>GPS noise or dropouts</li>
                                <li>Mixed upwind/downwind legs</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Detailed metrics -->
                <div class="section-divider"></div>
                
                <h3 class="section-header text-2xl font-bold mb-6">Detailed Metrics</h3>
                
                <div class="grid grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>Optimal Heel UP', `${analysis.optimalHeelUp}¬∞`, 'COG-based upwind', 'green', 'heel')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>Optimal Heel DOWN', `${analysis.optimalHeelDown}¬∞`, 'COG-based downwind', 'emerald', 'heel')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>Optimal Trim UP', `${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞`, 'Bow up/down upwind', 'teal', 'trim')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>Optimal Trim DOWN', `${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞`, 'Bow up/down downwind', 'cyan', 'trim')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>Best Pointing', `${analysis.bestPointing.toFixed(1)}¬∞`, analysis.bestPointing < 35 ? 'Excellent' : 'Good', 'cyan', 'pointing')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"></path><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"></path><path d="M4 22h16"></path><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"></path><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"></path><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"></path></svg>Leeway', `${analysis.leeway.toFixed(1)}¬∞`, analysis.leeway < 8 ? 'Good' : 'High', 'orange', 'leeway')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>Tack Efficiency', `${analysis.tackEfficiency.toFixed(0)}%`, `${analysis.tacksCount} tacks`, 'yellow', 'tackEfficiency')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>Gybe Efficiency', `${analysis.gybeEfficiency.toFixed(0)}%`, `${analysis.gybesCount} gybes`, 'amber', 'tackEfficiency')}
                    ${createMetricCard('<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.25rem;"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>Distance Eff', `${analysis.distanceEfficiency.toFixed(0)}%`, analysis.distanceEfficiency >= 70 ? '‚úÖ Good' : 'üü° Fair', 'indigo')}
                </div>

                ${analysis.coachingTips && analysis.coachingTips.length > 0 ? `
                <div class="mb-8 bg-gray-800 p-6 rounded-xl border border-gray-700">
                    <h3 class="text-xl font-bold mb-4 flex items-center">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        Coaching Tips
                    </h3>
                    <div class="space-y-3">
                        ${analysis.coachingTips.map(tip => `
                            <div class="coaching-tip pl-4 py-3 bg-gray-700 rounded">
                                <div class="flex justify-between items-start mb-1">
                                    <div class="font-semibold text-sm ${tip.priority === 'high' ? 'text-red-400' : 'text-yellow-400'}">${tip.category}</div>
                                    <div class="text-xs px-2 py-1 rounded ${tip.priority === 'high' ? 'bg-red-900 text-red-300' : 'bg-yellow-900 text-yellow-300'}">${tip.priority}</div>
                                </div>
                                <div class="text-sm text-gray-300 mb-2">${tip.message}</div>
                                <div class="text-xs text-green-400 font-semibold">Potential gain: ${tip.impact}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : `
                <div class="mb-8 bg-gray-800 p-6 rounded-xl border border-green-700">
                    <h3 class="text-xl font-bold mb-4 flex items-center">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        What to do next
                    </h3>
                    <div class="mb-2">
                        <span class="metric-badge badge-excellent">EXCELLENT PERFORMANCE</span>
                        <span class="text-gray-300 ml-2">No critical issues detected.</span>
                    </div>
                    <div class="text-sm text-gray-400">
                        Your sailing metrics look good. Keep refining your technique and focus on:
                        <ul class="list-disc ml-5 mt-2 space-y-1">
                            <li>Maintaining optimal heel angle: ${analysis.optimalHeelUp}¬∞ upwind</li>
                            <li>Consistent tack execution (current avg: ${analysis.tackEfficiency.toFixed(0)}%)</li>
                            <li>Maximizing time on favorable wind shifts</li>
                        </ul>
                    </div>
                </div>
                `}

                <div class="grid grid-cols-2 gap-6 mb-8">
                    <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                        <h3 class="text-lg font-semibold mb-3 flex items-center">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                                <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>
                            </svg>
                            Wind Shift Analysis
                        </h3>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Time on Lifts:</span>
                                <span class="text-green-400 font-semibold">${analysis.windAnalysis.liftPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Time on Headers:</span>
                                <span class="text-red-400 font-semibold">${analysis.windAnalysis.headerPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Avg Lift Angle:</span>
                                <span class="text-white">${analysis.windAnalysis.avgLiftAngle.toFixed(1)}¬∞</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Avg Header Angle:</span>
                                <span class="text-white">${analysis.windAnalysis.avgHeaderAngle.toFixed(1)}¬∞</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                        <h3 class="text-lg font-semibold mb-3">üìä Course Bias</h3>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Port Tack:</span>
                                <span class="font-semibold text-white">${analysis.courseBias.portPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Starboard Tack:</span>
                                <span class="font-semibold text-white">${analysis.courseBias.starboardPct.toFixed(1)}%</span>
                            </div>
                            <div class="mt-3 pt-3 border-t border-gray-600 text-xs text-white opacity-80">
                                ${Math.abs(analysis.courseBias.portPct - 50) > 20 ? 
                                    `‚ö†Ô∏è Significant bias toward ${analysis.courseBias.portPct > 50 ? 'port' : 'starboard'}` : 
                                    '‚úÖ Well balanced course'}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Wind Rose Visualization -->
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4 flex items-center">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>
                        </svg>
                        Heading Distribution (Wind Rose)
                    </h3>
                    <div class="flex justify-center">
                        <canvas id="windRose" width="400" height="400"></canvas>
                    </div>
                    <div class="text-xs text-gray-400 text-center mt-3">
                        Blue = Port tack ‚Ä¢ Green = Starboard tack ‚Ä¢ Yellow arrow = Wind direction
                    </div>
                </div>

                <!-- Laylines Display -->
                ${analysis.laylines ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.5rem;">
                            <line x1="18" y1="20" x2="18" y2="10"></line>
                            <line x1="12" y1="20" x2="12" y2="4"></line>
                            <line x1="6" y1="20" x2="6" y2="14"></line>
                        </svg>
                        Layline Calculator
                        ${helpIcon(`<strong>What's a Layline?</strong><br/>A geographic line extending from the windward mark. When you cross it, tack and sail directly to the mark at your pointing angle (${analysis.laylines.pointingAngle}¬∞) without being overstood or understood.<br/><br/><strong>How it's calculated:</strong><br/>1. Find your best pointing angle (tightest TWA with good VMG)<br/>2. Port layline = Wind direction - pointing angle<br/>3. Starboard layline = Wind direction + pointing angle<br/>4. Lines extend from mark at these headings`)}
                    </h3>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <div class="flex justify-center mb-4">
                                <canvas id="laylinesCanvas" width="300" height="300"></canvas>
                            </div>
                            <div class="text-xs text-gray-400 text-center">
                                Yellow = Wind ‚Ä¢ Blue = Port layline ‚Ä¢ Green = Starboard layline
                            </div>
                        </div>
                        <div class="space-y-4">
                            <div class="p-4 bg-gray-700 rounded">
                                <div class="text-sm text-gray-400">Your Best Pointing Angle</div>
                                <div class="text-3xl font-bold text-yellow-400">
                                    ${analysis.laylines.pointingAngle}¬∞
                                    ${metricBadge(analysis.laylines.pointingAngle, 42, 47, false)}
                                    ${helpIcon(`<strong>Your Best Pointing Angle:</strong> ${analysis.laylines.pointingAngle}¬∞<br/><br/>This is the tightest TWA you can sail while maintaining good VMG (>90% of max). Based on analysis of actual upwind sailing data.`)}
                                </div>
                                <div class="text-xs text-gray-500 mt-1">Tightest TWA with good VMG</div>
                            </div>
                            
                            ${expandableHelp('How is pointing angle determined?', `
                                <p><strong>Method: Tightest angle with good VMG</strong></p>
                                <ul>
                                    <li>Analyzes all upwind sailing at different TWAs (30-55¬∞)</li>
                                    <li>For each angle, calculates average VMG</li>
                                    <li>Finds tightest angle where VMG stays >90% of maximum</li>
                                    <li>Result: ${analysis.laylines.pointingAngle}¬∞ from your actual data</li>
                                </ul>
                                <p><strong>Why this matters:</strong> This is YOUR proven closehauled angle from real sailing, not a theoretical number. Use it for layline calculations and race strategy.</p>
                                <p><strong>Typical values:</strong></p>
                                <ul>
                                    <li>Melges 15: 42-47¬∞ (you're at ${analysis.laylines.pointingAngle}¬∞)</li>
                                    <li>420: 40-45¬∞</li>
                                    <li>Laser: 38-43¬∞</li>
                                </ul>
                            `)}
                            
                            <div class="p-4 bg-blue-900 bg-opacity-30 rounded border border-blue-600">
                                <div class="text-sm font-semibold text-blue-300 mb-2">üìç To Calculate Actual Laylines:</div>
                                <ol class="text-xs text-gray-300 list-decimal ml-4 space-y-1">
                                    <li>Download full version (has GPS map)</li>
                                    <li>Click "Place Windward Mark" button</li>
                                    <li>Click on map where mark is located</li>
                                    <li>Laylines will draw from mark automatically</li>
                                </ol>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-3">
                                <div class="p-3 bg-gray-700 rounded">
                                    <div class="text-xs text-gray-400">When On Port Layline</div>
                                    <div class="text-xl font-bold text-blue-400">Sail ${analysis.laylines.portTackHeading.toFixed(0)}¬∞</div>
                                    <div class="text-xs text-gray-500 mt-1">To reach mark</div>
                                </div>
                                <div class="p-3 bg-gray-700 rounded">
                                    <div class="text-xs text-gray-400">When On Stbd Layline</div>
                                    <div class="text-xl font-bold text-green-400">Sail ${analysis.laylines.starboardTackHeading.toFixed(0)}¬∞</div>
                                    <div class="text-xs text-gray-500 mt-1">To reach mark</div>
                                </div>
                            </div>
                            
                            <div class="text-xs text-gray-400 p-3 bg-gray-700 rounded">
                                <strong>üí° What is a layline?</strong> A geographic line from the mark. When you cross it, you can tack and sail directly to the mark at ${analysis.laylines.pointingAngle}¬∞ TWA without being overstood or understood.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Wind Shift Timeline -->
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">üìà Wind Shift Timeline</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="windShiftTimeline"></canvas>
                    </div>
                    <div class="text-xs text-gray-400 mt-3">
                        <span class="text-green-400">Green peaks</span> = Lifts (favorable) ‚Ä¢ 
                        <span class="text-red-400">Red valleys</span> = Headers (unfavorable) ‚Ä¢ 
                        <span style="background: rgba(16, 185, 129, 0.2); padding: 2px 6px; border-radius: 3px;">Green background</span> = Upwind ‚Ä¢ 
                        <span style="background: rgba(59, 130, 246, 0.2); padding: 2px 6px; border-radius: 3px;">Blue background</span> = Downwind ‚Ä¢
                        <span class="text-yellow-400">T</span> = Tacks ‚Ä¢
                        <span class="text-orange-400">G</span> = Gybes
                    </div>
                </div>

                <!-- Heel by Wind Speed Analysis -->
                ${analysis.heelByWindSpeed && (analysis.heelByWindSpeed.lightAir.samples > 100 || analysis.heelByWindSpeed.moderateAir.samples > 100) ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.5rem;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        Optimal Heel by Wind Strength
                        ${helpIcon(`<strong>Optimal Heel by Condition</strong><br/>Your boat's best heel angle based on actual VMG data, calculated separately for light and moderate air. This accounts for how your boat performs in different wind strengths.`)}
                    </h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Light Air (5-10 kts TWS)</div>
                            <div class="text-3xl font-bold text-blue-400">
                                ${analysis.heelByWindSpeed.lightAir.optimal}¬∞
                                ${metricBadge(analysis.heelByWindSpeed.lightAir.optimal, 18, 22)}
                                ${helpIcon(`<strong>Light Air Heel:</strong> ${analysis.heelByWindSpeed.lightAir.optimal}¬∞<br/><br/>Based on ${analysis.heelByWindSpeed.lightAir.samples} data points in 5-10 kts TWS. This is where your top 10% VMG performance occurs most often in light conditions.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">${analysis.heelByWindSpeed.lightAir.samples} samples</div>
                            <div class="text-xs text-gray-400 mt-2">
                                üí° More heel acceptable in light air - reduces wetted surface, helps sail shape
                            </div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Moderate Air (10-15 kts TWS)</div>
                            <div class="text-3xl font-bold text-green-400">
                                ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞
                                ${metricBadge(analysis.heelByWindSpeed.moderateAir.optimal, 15, 20)}
                                ${helpIcon(`<strong>Moderate Air Heel:</strong> ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞<br/><br/>Based on ${analysis.heelByWindSpeed.moderateAir.samples} data points in 10-15 kts TWS. Typically flatter than light air to minimize leeway and maximize power.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">${analysis.heelByWindSpeed.moderateAir.samples} samples</div>
                            <div class="text-xs text-gray-400 mt-2">
                                üí° Flatter sailing in breeze - minimizes leeway, maximizes righting moment
                            </div>
                        </div>
                    </div>
                    ${expandableHelp('How is optimal heel calculated?', `
                        <p><strong>Method: 90th Percentile Binning by Wind Strength</strong></p>
                        <ul>
                            <li>Data separated by boat speed (proxy for wind strength):
                                <ul>
                                    <li><strong>Light air:</strong> 3-5 kts boat speed ‚âà 5-10 kts TWS</li>
                                    <li><strong>Moderate air:</strong> 5-7 kts boat speed ‚âà 10-15 kts TWS</li>
                                </ul>
                            </li>
                            <li>Heel angles grouped into 2¬∞ bins (0¬∞, 2¬∞, 4¬∞... 24¬∞)</li>
                            <li>For each bin, find the 90th percentile VMG (top 10% performance)</li>
                            <li>Optimal = bin with highest 90th percentile VMG</li>
                            <li>Requires minimum 50 samples per bin for reliability</li>
                        </ul>
                        <p><strong>Why 90th percentile?</strong> Represents your best achievable performance at that heel angle. Filters out poor moments (wind holes, waves, mistakes) while avoiding single outliers that "max" would pick up.</p>
                        <p><strong>Why trust this over theory?</strong> This is YOUR boat with YOUR crew weight (${analysis.heelByWindSpeed ? '~360 lbs for Melges 15' : 'your setup'}) and YOUR technique. Generic advice says 8-12¬∞ but your data shows what actually makes you fastest!</p>
                        <p><strong>Light vs Moderate Air:</strong></p>
                        <ul>
                            <li>Light: More heel OK (reduces wetted surface)</li>
                            <li>Moderate: Flatter sailing (minimizes leeway, maximizes power)</li>
                            <li>Your data: ${analysis.heelByWindSpeed.lightAir.optimal}¬∞ light, ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞ moderate</li>
                        </ul>
                    `)}
                </div>
                ` : ''}

                <!-- Leeway Analysis -->
                ${analysis.leewayAnalysis && analysis.leewayAnalysis.diagnosis.length > 0 ? `
                <div class="bg-gray-800 p-6 rounded-xl border ${analysis.leewayAnalysis.concernLevel === 'critical' ? 'border-red-700' : 'border-yellow-700'} mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 0.5rem;">
                            <circle cx="12" cy="5" r="3"></circle>
                            <line x1="12" y1="22" x2="12" y2="8"></line>
                            <path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>
                        </svg>
                        Leeway Analysis
                        ${helpIcon(`<strong>Leeway:</strong> Difference between heading (where bow points) and COG (where you actually go)<br/><br/><strong>Normal:</strong> 3-8¬∞ for dinghies<br/><strong>Warning:</strong> >15¬∞ usually indicates sensor calibration error, not actual side-slip!`)}
                    </h3>
                    <div class="mb-4 p-4 bg-gray-700 rounded">
                        <div class="text-sm text-gray-400">Average Leeway (COG - Heading)</div>
                        <div class="text-3xl font-bold ${analysis.leewayAnalysis.concernLevel === 'critical' ? 'text-red-400' : analysis.leewayAnalysis.concernLevel === 'moderate' ? 'text-yellow-400' : 'text-green-400'}">
                            ${analysis.leewayAnalysis.average.toFixed(1)}¬∞
                            ${metricBadge(analysis.leewayAnalysis.average, 6, 10, false)}
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Normal range: 3-8¬∞ for well-sailed dinghy</div>
                    </div>
                    ${expandableHelp('How is leeway determined?', `
                        <p><strong>Formula:</strong></p>
                        <code>Leeway = COG - Heading</code>
                        <p>(with 360¬∞ wraparound correction)</p>
                        
                        <p><strong>What it measures:</strong></p>
                        <ul>
                            <li><strong>COG (Course Over Ground):</strong> Your actual GPS track through the water</li>
                            <li><strong>Heading:</strong> Where your bow is pointing from compass</li>
                            <li><strong>Difference:</strong> Side-slip caused by wind force on sails</li>
                        </ul>
                        
                        <p><strong>Your leeway: ${analysis.leewayAnalysis.average.toFixed(1)}¬∞</strong></p>
                        
                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li><strong>3-8¬∞:</strong> Normal for well-sailed dinghy</li>
                            <li><strong>8-15¬∞:</strong> High but possible (excessive heel? centerboard up?)</li>
                            <li><strong>>15¬∞:</strong> Almost certainly sensor calibration error</li>
                        </ul>
                        
                        <p><strong>If leeway seems too high (>15¬∞):</strong></p>
                        <ul>
                            <li>Check Vakaros magnetic declination setting for your location</li>
                            <li>Recalibrate compass (figure-8 pattern while holding Vakaros)</li>
                            <li>Test: Sail straight in light air - should show &lt;5¬∞ leeway</li>
                            <li>NOT actual side-slip if >20¬∞ - that's physically impossible!</li>
                        </ul>
                        
                        <p><strong>Physical reality check:</strong> A boat making 20¬∞ of actual side-slip would be moving almost sideways and would have terrible VMG. If your VMG is good, the leeway reading is wrong (sensor issue).</p>
                    `)}
                    <div class="space-y-3">
                        ${analysis.leewayAnalysis.diagnosis.map(d => `
                            <div class="p-3 bg-gray-700 rounded border-l-4 ${d.severity === 'critical' ? 'border-red-500' : d.severity === 'moderate' ? 'border-yellow-500' : 'border-blue-500'}">
                                <div class="font-semibold text-sm ${d.severity === 'critical' ? 'text-red-400' : d.severity === 'moderate' ? 'text-yellow-400' : 'text-blue-400'}">
                                    ${d.issue}
                                </div>
                                ${d.possibleCauses ? `
                                    <div class="text-xs text-gray-400 mt-2">
                                        <strong>Possible causes:</strong>
                                        <ul class="list-disc ml-5 mt-1 space-y-1">
                                            ${d.possibleCauses.map(cause => `<li>${cause}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                                ${d.data ? `<div class="text-xs text-gray-300 mt-2"><strong>Data:</strong> ${d.data}</div>` : ''}
                                <div class="text-xs text-green-400 mt-2">
                                    <strong>Recommendation:</strong> ${d.recommendation}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                ${!analysis.heelDataQuality.reliable ? `
                <div class="mb-8 bg-yellow-900 bg-opacity-20 border border-yellow-600 p-4 rounded-xl">
                    <div class="flex items-start gap-3">
                        <div class="text-2xl">‚ö†Ô∏è</div>
                        <div>
                            <div class="font-semibold text-yellow-400 mb-1">Limited Data Quality for Heel Optimization</div>
                            <div class="text-sm text-gray-300">Only ${analysis.heelDataQuality.upwindSamples} upwind samples. For reliable heel angle recommendations, you need 500+ samples. The optimal heel of ${analysis.optimalHeelUp}¬∞ may not be accurate. Consider sailing more upwind legs or combining multiple races.</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Tack Timing Analysis -->
                ${analysis.tackTiming && analysis.tackTiming.analysis && analysis.tackTiming.analysis.length > 0 ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        ‚õµ Tack Timing Analysis
                        ${helpIcon(`<strong>Tack Timing</strong><br/>Analyzes whether you tacked on headers (correct) or lifts (incorrect).<br/><br/><strong>Good racing:</strong> >60% of tacks on headers<br/><strong>Your score:</strong> ${analysis.tackTiming ? ((analysis.tackTiming.onHeaders / (analysis.tackTiming.onHeaders + analysis.tackTiming.onLifts + analysis.tackTiming.neutral)) * 100).toFixed(0) : 'N/A'}%`)}
                    </h3>
                    <div class="grid grid-cols-3 gap-4 mb-4">
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Tacks on Headers</div>
                            <div class="text-3xl font-bold text-green-400">
                                ${analysis.tackTiming.onHeaders}
                                ${helpIcon(`<strong>Headers:</strong> Unfavorable wind shifts that force you to point lower. Tacking on headers is CORRECT - you're getting off the bad shift.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Correct timing ‚úì</div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Tacks on Lifts</div>
                            <div class="text-3xl font-bold text-red-400">
                                ${analysis.tackTiming.onLifts}
                                ${helpIcon(`<strong>Lifts:</strong> Favorable wind shifts that let you point higher. Tacking on lifts is WRONG - you're giving up free advantage! Should stay on lift longer.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Avoid this ‚úó</div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Neutral Tacks</div>
                            <div class="text-3xl font-bold text-gray-400">
                                ${analysis.tackTiming.neutral}
                                ${helpIcon(`<strong>Neutral:</strong> Tacks when wind shift was minimal (¬±3¬∞). Usually strategic decisions for laylines, traffic, or other tactical reasons.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Strategic</div>
                        </div>
                    </div>
                    ${expandableHelp('How is tack timing analyzed?', `
                        <p><strong>Method:</strong></p>
                        <ul>
                            <li>For each tack, examines wind conditions 30 seconds before the maneuver</li>
                            <li>Calculates average TWA shift during that window</li>
                            <li>Classifies shift:
                                <ul>
                                    <li><strong>>3¬∞ header:</strong> Correct timing (should tack)</li>
                                    <li><strong>&lt;-3¬∞ lift:</strong> Incorrect timing (should stay)</li>
                                    <li><strong>-3¬∞ to +3¬∞:</strong> Neutral (strategic/tactical)</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <p><strong>Your Results:</strong></p>
                        <ul>
                            <li>Tacks on headers: ${analysis.tackTiming.onHeaders} (‚úì correct)</li>
                            <li>Tacks on lifts: ${analysis.tackTiming.onLifts} (‚úó incorrect)</li>
                            <li>Neutral tacks: ${analysis.tackTiming.neutral}</li>
                            <li>Score: ${((analysis.tackTiming.onHeaders / (analysis.tackTiming.onHeaders + analysis.tackTiming.onLifts + analysis.tackTiming.neutral)) * 100).toFixed(0)}% on headers</li>
                        </ul>
                        
                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li><strong>>70%:</strong> Excellent wind awareness and shift detection</li>
                            <li><strong>60-70%:</strong> Good awareness, catching most shifts</li>
                            <li><strong>50-60%:</strong> Fair awareness, missing opportunities</li>
                            <li><strong>&lt;50%:</strong> Poor awareness, tacking randomly or on wrong shifts</li>
                        </ul>
                        
                        <p><strong>Why this matters:</strong> Tacking on headers is fundamental upwind strategy. If you tack on lifts, you're giving up free pointing advantage. Each tack on a lift vs staying could cost 5-10 boat lengths!</p>
                        
                        <p><strong>How to improve:</strong></p>
                        <ul>
                            <li>Sail longer on each tack to feel the shifts developing</li>
                            <li>Use compass or tell-tales to detect when you're being headed</li>
                            <li>Tack IMMEDIATELY when you feel a significant header</li>
                            <li>Review wind shift timeline to see when you missed opportunities</li>
                        </ul>
                    `)}
                    <div class="space-y-3">
                        ${analysis.tackTiming.analysis.map(item => `
                            <div class="p-3 bg-gray-700 rounded border-l-4 ${
                                item.assessment === 'excellent' ? 'border-green-500' :
                                item.assessment === 'good' ? 'border-blue-500' :
                                item.assessment === 'concerning' ? 'border-red-500' :
                                'border-yellow-500'
                            }">
                                <div class="font-semibold text-sm ${
                                    item.assessment === 'excellent' ? 'text-green-400' :
                                    item.assessment === 'good' ? 'text-blue-400' :
                                    item.assessment === 'concerning' ? 'text-red-400' :
                                    'text-yellow-400'
                                }">
                                    ${item.metric}
                                </div>
                                <div class="text-xs text-gray-300 mt-1">${item.value}</div>
                                <div class="text-xs text-gray-400 mt-2">
                                    <strong>üí° ${item.recommendation}</strong>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- Multi-Race Comparison -->
                ${analysis.multiRaceComparison && analysis.multiRaceComparison.racesAnalyzed > 1 ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-purple-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">üèÜ Multi-Race Comparison (${analysis.multiRaceComparison.racesAnalyzed} Races)</h3>
                    
                    <div class="grid grid-cols-2 gap-4 mb-6">
                        <div class="p-4 bg-green-900 bg-opacity-20 border border-green-600 rounded">
                            <div class="text-sm text-green-400 font-semibold mb-2">ü•á Best Race: #${parseInt(analysis.multiRaceComparison.bestRace.id) + 1}</div>
                            <div class="grid grid-cols-2 gap-2 text-xs">
                                <div><span class="text-gray-400">Avg VMG:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.avgVMG.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Tack Eff:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.tackEfficiency.toFixed(0)}%</span></div>
                                <div><span class="text-gray-400">Speed:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.avgUpwindSpeed.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Handling:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.boatHandlingScore.toFixed(0)}</span></div>
                            </div>
                        </div>
                        <div class="p-4 bg-red-900 bg-opacity-20 border border-red-600 rounded">
                            <div class="text-sm text-red-400 font-semibold mb-2">üìâ Weakest Race: #${parseInt(analysis.multiRaceComparison.worstRace.id) + 1}</div>
                            <div class="grid grid-cols-2 gap-2 text-xs">
                                <div><span class="text-gray-400">Avg VMG:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.avgVMG.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Tack Eff:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.tackEfficiency.toFixed(0)}%</span></div>
                                <div><span class="text-gray-400">Speed:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.avgUpwindSpeed.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Handling:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.boatHandlingScore.toFixed(0)}</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-700 rounded mb-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="text-sm text-gray-400">Consistency</div>
                                <div class="text-xs text-gray-500">VMG variation</div>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-bold ${
                                    analysis.multiRaceComparison.consistency.assessment === 'excellent' ? 'text-green-400' :
                                    analysis.multiRaceComparison.consistency.assessment === 'good' ? 'text-blue-400' :
                                    'text-yellow-400'
                                }">${analysis.multiRaceComparison.consistency.vmgVariation.toFixed(1)}%</div>
                                <div class="text-xs ${
                                    analysis.multiRaceComparison.consistency.assessment === 'excellent' ? 'text-green-400' :
                                    analysis.multiRaceComparison.consistency.assessment === 'good' ? 'text-blue-400' :
                                    'text-yellow-400'
                                }">${analysis.multiRaceComparison.consistency.assessment.toUpperCase()}</div>
                            </div>
                        </div>
                    </div>
                    
                    ${analysis.multiRaceComparison.keyDifferences.length > 0 ? `
                    <div class="space-y-2 mb-4">
                        <div class="text-sm font-semibold text-gray-300">üîç Key Differences:</div>
                        ${analysis.multiRaceComparison.keyDifferences.map(diff => `
                            <div class="p-3 bg-gray-700 rounded text-xs">
                                <div class="font-semibold text-purple-400">${diff.metric}</div>
                                <div class="text-gray-300 mt-1">${diff.difference}</div>
                                <div class="text-gray-400 mt-1"><strong>Impact:</strong> ${diff.impact}</div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    <div class="mt-4">
                        <div class="text-sm font-semibold text-gray-300 mb-2">üìà Performance Trend</div>
                        <div class="chart-container" style="height: 200px;">
                            <canvas id="learningCurveChart"></canvas>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Charts -->
                <div class="section-divider"></div>
                
                <h3 class="section-header text-2xl font-bold mb-6">Performance Analysis</h3>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨ÜÔ∏è VMG vs Heel - UPWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.upwindSample.length} points ‚Ä¢ <strong>Optimal: ${analysis.optimalHeelUp}¬∞</strong><br/>
                            <span class="text-yellow-400">‚óè</span> Yellow curve = Polynomial trend<br/>
                            <span class="text-green-400">- - -</span> Green dashed = Optimal heel line<br/>
                            <details class="mt-1">
                                <summary class="cursor-pointer text-blue-400 hover:text-blue-300">How is optimal determined?</summary>
                                <div class="mt-1 p-2 bg-gray-700 rounded text-xs">
                                    1. Bin heel angles in 2¬∞ buckets (0¬∞, 2¬∞, 4¬∞...)<br/>
                                    2. For each bin, find 90th percentile VMG (top 10% performance)<br/>
                                    3. Optimal = heel angle with highest 90th percentile<br/>
                                    4. Requires 50+ samples per bin for reliability<br/>
                                    <em class="text-gray-500">Note: Aggregated across all wind speeds in session</em>
                                </div>
                            </details>
                        </div>
                        <div class="chart-container"><canvas id="heelVmgUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨áÔ∏è VMG vs Heel - DOWNWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.downwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalHeelDown}¬∞<br/>
                            <span class="text-green-400">Green line</span> = optimal heel angle<br/>
                            <span class="text-yellow-400">Yellow curve</span> = VMG trend with heel angle
                        </div>
                        <div class="chart-container"><canvas id="heelVmgDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨ÜÔ∏è VMG vs Trim - UPWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.upwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞<br/>
                            Positive = bow up, Negative = bow down
                        </div>
                        <div class="chart-container"><canvas id="trimVmgUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨áÔ∏è VMG vs Trim - DOWNWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.downwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞
                        </div>
                        <div class="chart-container"><canvas id="trimVmgDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Where you actually sailed</div>
                        <div class="chart-container"><canvas id="heelDistChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2 flex items-center">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem; flex-shrink: 0;">
                                <circle cx="12" cy="12" r="10"></circle>
                                <circle cx="12" cy="12" r="6"></circle>
                                <circle cx="12" cy="12" r="2"></circle>
                            </svg>
                            Performance Polar Diagram
                        </h4>
                        <div class="text-xs text-gray-400 mb-3">
                            <strong>Speed vs True Wind Angle (TWA)</strong><br/>
                            <span class="text-green-400">‚óè</span> Green = Target speed (90th percentile - best 10%)<br/>
                            <span class="text-yellow-400">- - -</span> Yellow = Average speed<br/>
                            <span class="text-red-400">üî¥</span> Red marker = Optimal upwind VMG angle<br/>
                            <span class="text-blue-400">üîµ</span> Blue marker = Optimal downwind VMG angle<br/>
                            <em class="mt-1 block">Hover over points to see VMG calculations</em>
                        </div>
                        <div class="chart-container" style="min-height: 600px;"><canvas id="polarChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">TWA Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Time at each wind angle</div>
                        <div class="chart-container"><canvas id="twaDistChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Consistency check</div>
                        <div class="chart-container"><canvas id="speedDistChart"></canvas></div>
                    </div>
                </div>

                <!-- New Charts: Separate Upwind/Downwind Distributions -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution - Upwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.heelDistributionUpwind.length} samples ‚Ä¢ Absolute heel angles</div>
                        <div class="chart-container"><canvas id="heelDistUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution - Downwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.heelDistributionDownwind.length} samples ‚Ä¢ Absolute heel angles</div>
                        <div class="chart-container"><canvas id="heelDistDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution - Upwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.speedDistributionUpwind.length} samples ‚Ä¢ Avg: ${(analysis.speedDistributionUpwind.reduce((a,b)=>a+b,0)/analysis.speedDistributionUpwind.length).toFixed(1)} kts</div>
                        <div class="chart-container"><canvas id="speedDistUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution - Downwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.speedDistributionDownwind.length} samples ‚Ä¢ Avg: ${(analysis.speedDistributionDownwind.reduce((a,b)=>a+b,0)/analysis.speedDistributionDownwind.length).toFixed(1)} kts</div>
                        <div class="chart-container"><canvas id="speedDistDownChart"></canvas></div>
                    </div>
                </div>

                ${analysis.maneuvers.length > 0 ? `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    ${analysis.tacks.length > 0 ? `
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Tack Performance</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.tacks.length} tacks ‚Ä¢ Avg efficiency: ${analysis.tackEfficiency.toFixed(0)}%<br/>
                        Color = distance lost (green=best, red=worst)</div>
                        <div class="chart-container"><canvas id="tackScatterChart"></canvas></div>
                    </div>
                    ` : ''}
                    ${analysis.gybes.length > 0 ? `
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Gybe Performance</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.gybes.length} gybes ‚Ä¢ Avg efficiency: ${analysis.gybeEfficiency.toFixed(0)}%<br/>
                        Color = distance lost (green=best, red=worst)</div>
                        <div class="chart-container"><canvas id="gybeScatterChart"></canvas></div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}
                
                <!-- SPEED OVER TIME ANALYSIS (NJORD-STYLE) -->
                ${analysis.tacks.length >= 3 ? `
                <div class="section-divider"></div>
                
                <h3 class="section-header text-2xl font-bold mb-6">Tack Speed Analysis</h3>
                
                <div class="grid grid-cols-1 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Tack Efficiency: Speed Loss and Recovery (${analysis.tacks.length} tacks)</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            Blue lines = Individual tacks ‚Ä¢ <span class="text-pink-400">Pink line = Average tack</span> ‚Ä¢ <span class="text-red-400">Red dashed line = Min speed point</span>
                        </div>
                        <div class="chart-container"><canvas id="tackSpeedOverTime"></canvas></div>
                    </div>
                </div>
                ` : ''}
                
                ${analysis.gybes.length >= 3 ? `
                <h3 class="section-header text-2xl font-bold mb-6">Gybe Speed Analysis</h3>
                
                <div class="grid grid-cols-1 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Gybe Efficiency: Speed Loss and Recovery (${analysis.gybes.length} gybes)</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            Blue lines = Individual gybes ‚Ä¢ <span class="text-pink-400">Pink line = Average gybe</span> ‚Ä¢ <span class="text-red-400">Red dashed line = Min speed point</span>
                        </div>
                        <div class="chart-container"><canvas id="gybeSpeedOverTime"></canvas></div>
                    </div>
                </div>
                ` : ''}
                
                <!-- DETAILED MANEUVER ANALYSIS -->
                ${analysis.tacks.length > 0 ? `
                <div class="section-divider"></div>
                
                <h3 class="section-header text-2xl font-bold mb-6">Individual Tack Analysis</h3>
                
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <div class="mb-4 text-sm text-gray-300">
                        <span class="inline-block px-3 py-1 bg-green-900 rounded mr-2">üèÜ Top Performers</span>
                        <span class="inline-block px-3 py-1 bg-red-900 rounded">‚ö†Ô∏è Need Improvement</span>
                    </div>
                    
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="text-left py-2 px-2">Tack #</th>
                                    <th class="text-right py-2 px-2">Entry Speed</th>
                                    <th class="text-right py-2 px-2">Exit Speed</th>
                                    <th class="text-right py-2 px-2">Efficiency</th>
                                    <th class="text-right py-2 px-2">Distance Lost</th>
                                    <th class="text-right py-2 px-2">Assessment</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${(() => {
                                    // Sort tacks by efficiency (best first)
                                    const sortedTacks = [...analysis.tacks].sort((a, b) => b.efficiency - a.efficiency);
                                    const topTacks = sortedTacks.slice(0, 3).map(t => t.tackNumber);
                                    const worstTacks = sortedTacks.slice(-3).map(t => t.tackNumber);
                                    
                                    return analysis.tacks.map(t => {
                                        const isTop = topTacks.includes(t.tackNumber);
                                        const isWorst = worstTacks.includes(t.tackNumber);
                                        const rowClass = isTop ? 'bg-green-900 bg-opacity-20' : isWorst ? 'bg-red-900 bg-opacity-20' : '';
                                        
                                        let assessment = '';
                                        if (t.efficiency >= 90) assessment = 'Excellent';
                                        else if (t.efficiency >= 80) assessment = 'Good';
                                        else if (t.efficiency >= 70) assessment = 'Fair';
                                        else assessment = 'Poor';
                                        
                                        return `
                                            <tr class="${rowClass} border-b border-gray-700 hover:bg-gray-750">
                                                <td class="py-2 px-2 font-semibold">T${t.tackNumber}</td>
                                                <td class="text-right py-2 px-2">${t.entrySpeed.toFixed(1)} kts</td>
                                                <td class="text-right py-2 px-2">${t.exitSpeed.toFixed(1)} kts</td>
                                                <td class="text-right py-2 px-2 font-semibold">${t.efficiency.toFixed(0)}%</td>
                                                <td class="text-right py-2 px-2">${t.distanceLost.toFixed(1)}m</td>
                                                <td class="text-right py-2 px-2">${assessment}</td>
                                            </tr>
                                        `;
                                    }).join('');
                                })()}
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="mt-4 text-xs text-gray-400">
                        <p><strong>Reading the data:</strong> Efficiency = (Exit Speed / Entry Speed) √ó 100. Target: 85%+</p>
                        <p><strong>Distance Lost:</strong> Estimated meters lost during the maneuver. Lower is better.</p>
                    </div>
                </div>
                ` : ''}
                
                ${analysis.gybes.length > 0 ? `
                <h3 class="section-header text-2xl font-bold mb-6">Individual Gybe Analysis</h3>
                
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <div class="mb-4 text-sm text-gray-300">
                        <span class="inline-block px-3 py-1 bg-green-900 rounded mr-2">üèÜ Top Performers</span>
                        <span class="inline-block px-3 py-1 bg-red-900 rounded">‚ö†Ô∏è Need Improvement</span>
                    </div>
                    
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead>
                                <tr class="border-b border-gray-700">
                                    <th class="text-left py-2 px-2">Gybe #</th>
                                    <th class="text-right py-2 px-2">Entry Speed</th>
                                    <th class="text-right py-2 px-2">Exit Speed</th>
                                    <th class="text-right py-2 px-2">Efficiency</th>
                                    <th class="text-right py-2 px-2">Distance Lost</th>
                                    <th class="text-right py-2 px-2">Assessment</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${(() => {
                                    const sortedGybes = [...analysis.gybes].sort((a, b) => b.efficiency - a.efficiency);
                                    const topGybes = sortedGybes.slice(0, 3).map(g => g.tackNumber);
                                    const worstGybes = sortedGybes.slice(-3).map(g => g.tackNumber);
                                    
                                    return analysis.gybes.map(g => {
                                        const isTop = topGybes.includes(g.tackNumber);
                                        const isWorst = worstGybes.includes(g.tackNumber);
                                        const rowClass = isTop ? 'bg-green-900 bg-opacity-20' : isWorst ? 'bg-red-900 bg-opacity-20' : '';
                                        
                                        let assessment = '';
                                        if (g.efficiency >= 95) assessment = 'Excellent';
                                        else if (g.efficiency >= 85) assessment = 'Good';
                                        else if (g.efficiency >= 75) assessment = 'Fair';
                                        else assessment = 'Poor';
                                        
                                        return `
                                            <tr class="${rowClass} border-b border-gray-700 hover:bg-gray-750">
                                                <td class="py-2 px-2 font-semibold">G${g.tackNumber}</td>
                                                <td class="text-right py-2 px-2">${g.entrySpeed.toFixed(1)} kts</td>
                                                <td class="text-right py-2 px-2">${g.exitSpeed.toFixed(1)} kts</td>
                                                <td class="text-right py-2 px-2 font-semibold">${g.efficiency.toFixed(0)}%</td>
                                                <td class="text-right py-2 px-2">${g.distanceLost.toFixed(1)}m</td>
                                                <td class="text-right py-2 px-2">${assessment}</td>
                                            </tr>
                                        `;
                                    }).join('');
                                })()}
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="mt-4 text-xs text-gray-400">
                        <p><strong>Reading the data:</strong> Efficiency = (Exit Speed / Entry Speed) √ó 100. Target: 90%+</p>
                        <p><strong>Distance Lost:</strong> Estimated meters lost during the maneuver. Lower is better.</p>
                    </div>
                </div>
                ` : ''}

                <!-- Map -->
                <div class="section-divider"></div>
                
                <h3 class="section-header text-2xl font-bold mb-6">üó∫Ô∏è GPS Track</h3>
                
                <!-- GPS Map Instructions -->
                <div class="bg-blue-900/30 border border-blue-700 rounded-lg p-4 mb-4">
                    <div class="text-sm font-semibold text-blue-300 mb-2">üí° Using the GPS Map:</div>
                    <ul class="text-sm text-blue-100 space-y-1 ml-4 list-disc">
                        <li><strong>Track colors</strong> show VMG performance: üü¢ Excellent ‚Üí üî¥ Poor</li>
                        <li><strong>Wind shift markers:</strong> üü¢‚ö™ Lifts (>5¬∞) ‚Ä¢ üî¥‚ö™ Headers (>5¬∞)</li>
                        <li><strong>Maneuvers:</strong> üîµ Tacks ‚Ä¢ üü† Gybes (click circles for details)</li>
                        <li><strong>Optional:</strong> Click buttons below to add start/finish lines and marks</li>
                    </ul>
                </div>
                
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <div id="map"></div>
                    <div class="mt-4 grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-7 gap-2">
                        <button id="drawStartLine" class="px-4 py-3 text-sm bg-blue-600 hover:bg-blue-700 rounded font-semibold">üìè Start Line</button>
                        <button id="drawFinishLine" class="px-4 py-3 text-sm bg-purple-600 hover:bg-purple-700 rounded font-semibold">üèÅ Finish Line</button>
                        <button id="markWindward" class="px-4 py-3 text-sm bg-green-600 hover:bg-green-700 rounded font-semibold">‚óè Windward</button>
                        <button id="markLeeward" class="px-4 py-3 text-sm bg-yellow-600 hover:bg-yellow-700 rounded font-semibold">‚óÜ Leeward</button>
                        <button id="clearMarks" class="px-4 py-3 text-sm bg-red-600 hover:bg-red-700 rounded font-semibold">‚úï Clear</button>
                        <button id="clearStartLine" class="px-4 py-3 text-sm bg-gray-600 hover:bg-gray-700 rounded font-semibold" style="display:none;">‚úï Start</button>
                        <button id="clearFinishLine" class="px-4 py-3 text-sm bg-gray-600 hover:bg-gray-700 rounded font-semibold" style="display:none;">‚úï Finish</button>
                    </div>
                    
                    <!-- Layer Toggle Controls -->
                    <div class="mt-4 bg-gray-900/50 border border-gray-700 rounded-lg p-3">
                        <div class="text-xs font-semibold text-gray-400 mb-2">üéõÔ∏è MAP LAYERS (click to toggle)</div>
                        <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2">
                            <button id="toggleTrack" class="layer-toggle-btn active" data-layer="track">
                                <span>üìç GPS Track</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleUpwindLaylines" class="layer-toggle-btn active" data-layer="upwind-laylines">
                                <span>‚¨ÜÔ∏è Upwind Laylines</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleDownwindLaylines" class="layer-toggle-btn active" data-layer="downwind-laylines">
                                <span>‚¨áÔ∏è Downwind Laylines</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleShiftZones" class="layer-toggle-btn active" data-layer="shift-zones">
                                <span>üåä Wind Zones</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleManeuvers" class="layer-toggle-btn active" data-layer="maneuvers">
                                <span>‚öì Tacks/Gybes</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleShiftMarkers" class="layer-toggle-btn active" data-layer="shift-markers">
                                <span>‚ö™ Shift Markers</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleStartLine" class="layer-toggle-btn active" data-layer="start-line">
                                <span>üìè Start Line</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                            <button id="toggleFinishLine" class="layer-toggle-btn active" data-layer="finish-line">
                                <span>üèÅ Finish Line</span>
                                <span class="toggle-indicator">‚óè</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="mt-3 text-sm text-gray-400 flex gap-6 flex-wrap">
                        <span>üü¢ Excellent VMG</span>
                        <span>üîµ Good VMG</span>
                        <span>üü° Moderate VMG</span>
                        <span>üî¥ Poor VMG</span>
                        <span>üü¢‚ö™ Lifts (>5¬∞)</span>
                        <span>üî¥‚ö™ Headers (>5¬∞)</span>
                        <span>üîµ Tacks ‚Ä¢ üü† Gybes (click for details)</span>
                    </div>
                </div>

                <!-- ACTIONABLE SUGGESTIONS -->
                <div class="section-divider"></div>
                
                <div class="gradient-accent p-6 rounded-xl border mb-6" style="background: linear-gradient(to right, rgba(30, 58, 138, 0.7), rgba(88, 28, 135, 0.7)); border-color: rgba(59, 130, 246, 0.7); box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);">
                    <h3 class="section-header text-2xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        What To Do Next
                    </h3>
                    <div id="suggestionsContainer" class="space-y-4"></div>
                </div>
                </div>
                <!-- END OVERVIEW TAB -->
                
                <!-- POLAR TAB -->
                <div id="tab-polar" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        Performance Polar
                    </h2>
                </div>
                
                <!-- HANDLING TAB -->
                <div id="tab-handling" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <circle cx="12" cy="5" r="3"></circle>
                            <line x1="12" y1="22" x2="12" y2="8"></line>
                            <path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>
                        </svg>
                        Boat Handling
                    </h2>
                </div>
                
                <!-- MANEUVERS TAB -->
                <div id="tab-maneuvers" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                        </svg>
                        Maneuver Analysis
                    </h2>
                </div>
                
                <!-- WIND TAB -->
                <div id="tab-wind" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>
                        </svg>
                        Wind Analysis
                    </h2>
                </div>
                
                <!-- MAP TAB -->
                <div id="tab-map" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                            <circle cx="12" cy="10" r="3"></circle>
                        </svg>
                        GPS Track & Laylines
                    </h2>
                    
                    <!-- Map Instructions -->
                    <div class="bg-blue-900 bg-opacity-30 border border-blue-600 rounded-lg p-4 mb-6">
                        <h3 class="text-lg font-semibold mb-3">üìç How to Use the Interactive Map</h3>
                        <div class="text-sm text-gray-300 space-y-2">
                            <p><strong>Mark Placement:</strong> Click "Mark Windward" or "Mark Leeward" buttons, then click on the map to place marks. Laylines will appear automatically.</p>
                            <p><strong>Start/Finish Lines:</strong> Click "Draw Start Line" or "Draw Finish Line", then click two points on the map to create the line.</p>
                            <p><strong>Layer Controls:</strong> Use the buttons in the top-right of the map to toggle GPS track, laylines, speed heatmap, and other layers.</p>
                            <p><strong>Clear Marks:</strong> Use "Clear Marks" or "Clear Start Line" buttons to remove and start over.</p>
                        </div>
                    </div>
                    
                    <!-- Map content will be moved here dynamically -->
                </div>
                
                <!-- RACE ANALYSIS TAB -->
                <div id="tab-analysis" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6 flex items-center">
                        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#93C5FD" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.75rem; flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <circle cx="12" cy="12" r="6"></circle>
                            <circle cx="12" cy="12" r="2"></circle>
                        </svg>
                        Race Analysis & Insights
                    </h2>
                </div>
                
                <!-- EXPORT TAB -->
                <div id="tab-export" class="tab-content">
                    <h2 class="text-3xl font-bold mb-6">üìÑ Export & Reports</h2>
                    
                    <!-- SAVE SESSION - New Feature -->
                    <div class="bg-gradient-to-r from-blue-900 to-blue-800 rounded-xl p-6 mb-8 border border-blue-600">
                        <div class="flex items-center mb-4">
                            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#60A5FA" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-3">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </svg>
                            <h3 class="text-2xl font-bold">Save This Session</h3>
                        </div>
                        
                        <p class="text-sm text-blue-200 mb-6">
                            Save this analysis to compare with future sessions and track your improvement over time.
                        </p>
                        
                        <div id="saveSessionForm" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                            <!-- Session Name -->
                            <div class="md:col-span-2">
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Session Name *
                                </label>
                                <input 
                                    type="text" 
                                    id="sessionName" 
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                    placeholder="e.g., Spring Series Race 1, Practice Session"
                                />
                            </div>
                            
                            <!-- Date -->
                            <div>
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Date *
                                </label>
                                <input 
                                    type="date" 
                                    id="sessionDate" 
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                />
                            </div>
                            
                            <!-- Venue -->
                            <div>
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Venue
                                </label>
                                <input 
                                    type="text" 
                                    id="sessionVenue" 
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                    placeholder="e.g., Barnegat Bay"
                                />
                            </div>
                            
                            <!-- Wind Speed -->
                            <div>
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Wind Speed (kts)
                                </label>
                                <input 
                                    type="text" 
                                    id="sessionWindSpeed" 
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                    placeholder="e.g., 8-12"
                                />
                            </div>
                            
                            <!-- Boat Type -->
                            <div>
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Boat
                                </label>
                                <input 
                                    type="text" 
                                    id="sessionBoat" 
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                    placeholder="e.g., Melges 15"
                                    value="Melges 15"
                                />
                            </div>
                            
                            <!-- Notes -->
                            <div class="md:col-span-2">
                                <label class="block text-sm font-semibold text-gray-200 mb-2">
                                    Notes
                                </label>
                                <textarea 
                                    id="sessionNotes" 
                                    rows="3"
                                    class="w-full bg-gray-700 text-white px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none"
                                    placeholder="Key takeaways, conditions, what worked well, what to improve..."
                                ></textarea>
                            </div>
                        </div>
                        
                        <button 
                            id="saveSessionBtn" 
                            onclick="saveSession()" 
                            class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-4 rounded-lg text-lg shadow-lg transition-all transform hover:scale-105 flex items-center justify-center"
                        >
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-2">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </svg>
                            Save Session
                        </button>
                        
                        <div id="saveSuccessMessage" class="mt-4 p-4 bg-green-900 bg-opacity-30 rounded border border-green-600 hidden">
                            <div class="flex items-center text-green-200">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="mr-2">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                                <span class="font-semibold">Session saved successfully!</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <!-- Left: PDF Generation -->
                        <div class="bg-gray-800 rounded-xl p-6">
                            <h3 class="text-xl font-semibold mb-4">Generate PDF Report</h3>
                            
                            <div class="space-y-4 mb-6">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-2">üìÖ Race Date (for PDF tracking)</label>
                                    <input type="date" id="raceDateExport" class="w-full bg-gray-700 text-gray-100 px-4 py-2 rounded border border-gray-600 focus:border-blue-500 focus:outline-none">
                                </div>
                            </div>
                            
                            <button id="generatePDF" onclick="generatePDF()" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-4 rounded-lg text-lg shadow-lg transition-all transform hover:scale-105">
                                üìÑ Generate PDF Report
                            </button>
                            
                            <div class="mt-4 p-4 bg-blue-900 bg-opacity-30 rounded border border-blue-600">
                                <p class="text-sm text-blue-200">
                                    <strong>PDF includes:</strong> Performance summary, polar diagram, wind analysis, laylines strategy, and tactical insights.
                                </p>
                            </div>
                        </div>
                        
                        <!-- Right: Export Options -->
                        <div class="bg-gray-800 rounded-xl p-6">
                            <h3 class="text-xl font-semibold mb-4">Export Options</h3>
                            
                            <div class="space-y-4">
                                <div class="p-4 bg-gray-700 rounded-lg">
                                    <div class="font-semibold mb-2">üìä CSV Export</div>
                                    <p class="text-sm text-gray-400 mb-3">Export processed GPS data with calculations</p>
                                    <button class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm opacity-50 cursor-not-allowed" disabled>
                                        Coming Soon
                                    </button>
                                </div>
                                
                                <div class="p-4 bg-gray-700 rounded-lg">
                                    <div class="font-semibold mb-2">üñºÔ∏è Chart Images</div>
                                    <p class="text-sm text-gray-400 mb-3">Export individual charts as PNG</p>
                                    <button class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm opacity-50 cursor-not-allowed" disabled>
                                        Coming Soon
                                    </button>
                                </div>
                                
                                <div class="p-4 bg-gray-700 rounded-lg">
                                    <div class="font-semibold mb-2">üíæ Save Analysis</div>
                                    <p class="text-sm text-gray-400 mb-3">Save for later comparison</p>
                                    <button class="w-full bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm opacity-50 cursor-not-allowed" disabled>
                                        Coming Soon
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- SESSIONS TAB -->
                <div id="tab-sessions" class="tab-content">
                    <div class="flex items-center justify-between mb-6">
                        <h2 class="text-3xl font-bold">üíæ Saved Sessions</h2>
                        <button onclick="renderSessionLibrary()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-semibold text-sm">
                            üîÑ Refresh
                        </button>
                    </div>
                    
                    <p class="text-gray-400 mb-8">
                        Browse and load your saved sailing sessions. Compare performance over time and track your improvement.
                    </p>
                    
                    <div id="sessionLibraryContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Sessions will be rendered here -->
                        <div class="text-center py-12 text-gray-400 md:col-span-2 lg:col-span-3">
                            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" class="mx-auto mb-4 opacity-50">
                                <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                <polyline points="7 3 7 8 15 8"></polyline>
                            </svg>
                            <p class="text-lg font-semibold mb-2">Loading sessions...</p>
                        </div>
                    </div>
                </div>
            `;

            setTimeout(() => {
                // REORGANIZE CONTENT INTO TABS
                organizeContentIntoTabs();
                
                createAllCharts();
                createWindRose();
                createLaylinesCanvas();
                createWindShiftTimeline();
                createLearningCurveChart();
                initMap();
                renderSuggestions();
                
                // Wire up the main PDF button
                const pdfBtnMain = document.getElementById('pdfButtonMain');
                if (pdfBtnMain) {
                    pdfBtnMain.addEventListener('click', function(e) {
                        alert("Button was clicked! Now trying to generate PDF...");
                        console.log("üîµ Main PDF button clicked!");
                        e.preventDefault();
                        generatePDF();
                    });
                    console.log("‚úÖ Main PDF button wired up");
                } else {
                    console.error("‚ùå Could not find pdfButtonMain element!");
                }
                
                // Setup mark placement buttons
                const markWindwardBtn = document.getElementById('markWindward');
                const markLeewardBtn = document.getElementById('markLeeward');
                const clearMarksBtn = document.getElementById('clearMarks');
                const drawStartLineBtn = document.getElementById('drawStartLine');
                const clearStartLineBtn = document.getElementById('clearStartLine');
                const drawFinishLineBtn = document.getElementById('drawFinishLine');
                const clearFinishLineBtn = document.getElementById('clearFinishLine');
                
                if (markWindwardBtn) {
                    markWindwardBtn.addEventListener('click', () => { 
                        markMode = 'windward'; 
                        document.getElementById('map').classList.add('clickable');
                    });
                }
                
                if (markLeewardBtn) {
                    markLeewardBtn.addEventListener('click', () => { 
                        markMode = 'leeward'; 
                        document.getElementById('map').classList.add('clickable');
                    });
                }
                
                if (clearMarksBtn) {
                    clearMarksBtn.addEventListener('click', clearMarks);
                }
                
                if (drawStartLineBtn) {
                    drawStartLineBtn.addEventListener('click', () => {
                        markMode = 'startline';
                        startLinePins = [];
                        document.getElementById('map').classList.add('clickable');
                        alert('Click two points on the map to draw the start line');
                    });
                }
                
                if (clearStartLineBtn) {
                    clearStartLineBtn.addEventListener('click', clearStartLine);
                }
                
                if (drawFinishLineBtn) {
                    drawFinishLineBtn.addEventListener('click', () => {
                        markMode = 'finishline';
                        finishLinePins = [];
                        document.getElementById('map').classList.add('clickable');
                        alert('Click two points on the map to draw the finish line');
                    });
                }
                
                if (clearFinishLineBtn) {
                    clearFinishLineBtn.addEventListener('click', clearFinishLine);
                }
                
                // Setup layer toggle buttons
                try {
                    setupLayerToggles();
                } catch (error) {
                    console.error('‚ùå Error setting up layer toggles:', error);
                }
                
                // Setup map click handler
                setupMarkPlacement();
            }, 100);
        }

        function renderSuggestions() {
            const container = document.getElementById('suggestionsContainer');
            if (!container || !analysis || !analysis.suggestions) return;

            container.innerHTML = ''; // Clear

            analysis.suggestions.forEach(s => {
                const card = document.createElement('div');
                card.className = 'p-4 rounded-lg ' + (
                    s.priority === 'CRITICAL' ? 'bg-red-900/30 border-2 border-red-600' :
                    s.priority === 'HIGH' ? 'bg-orange-900/30 border border-orange-600' :
                    s.priority === 'MEDIUM' ? 'bg-yellow-900/30 border border-yellow-600' :
                    s.priority === 'GOOD' ? 'bg-green-900/30 border border-green-600' :
                    'bg-gray-800 border border-gray-600'
                );

                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-start gap-3';

                const icon = document.createElement('div');
                icon.className = 'text-3xl';
                icon.textContent = s.icon;

                const content = document.createElement('div');
                content.className = 'flex-1';

                const title = document.createElement('div');
                title.className = 'font-bold text-lg mb-1';
                title.textContent = s.title;

                const issue = document.createElement('div');
                issue.className = 'text-sm text-gray-300 mb-3';
                issue.textContent = s.issue;

                const actionsList = document.createElement('div');
                actionsList.className = 'space-y-2';

                s.actions.forEach(actionText => {
                    const actionDiv = document.createElement('div');
                    actionDiv.className = 'text-sm pl-4 border-l-2 border-gray-600 text-gray-200';
                    actionDiv.textContent = '‚ñ∏ ' + actionText;
                    actionsList.appendChild(actionDiv);
                });

                content.appendChild(title);
                content.appendChild(issue);
                content.appendChild(actionsList);

                wrapper.appendChild(icon);
                wrapper.appendChild(content);
                card.appendChild(wrapper);
                container.appendChild(card);
            });
        }

        function createMetricCard(title, value, subtitle, color, tooltipKey = null) {
            // CONSISTENT PROFESSIONAL COLOR SCHEME - all cards same navy/blue
            const colors = {
                'green': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'emerald': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'teal': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'cyan': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'blue': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'indigo': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'purple': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'pink': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'red': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'orange': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'amber': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'yellow': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' },
                'lime': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 95, 0.9), rgba(15, 40, 70, 0.8))', border: 'rgba(96, 165, 250, 0.6)', text: '#93C5FD' }
            };
            
            const c = colors[color] || colors['blue'];
            const tooltip = tooltipKey ? createTooltip(tooltipKey) : '';
            
            return `
                <div class="metric-card p-4 rounded-xl border" style="background: ${c.bg}; border-color: ${c.border};">
                    <div class="text-xl font-bold mb-2 flex items-center" style="color: ${c.text};">
                        ${title}${tooltip}
                    </div>
                    <div class="text-5xl font-bold text-white mb-2">${value}</div>
                    <div class="text-base font-semibold text-white opacity-90">${subtitle}</div>
                </div>
            `;
        }

        function polynomialRegression(data, degree = 2) {
            // Simple polynomial regression for trend lines
            const n = data.length;
            if (n < 10) return null;
            
            // For quadratic (degree 2): y = ax¬≤ + bx + c
            let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0;
            let sumY = 0, sumXY = 0, sumX2Y = 0;

            data.forEach(d => {
                const x = d.x;
                const y = d.y;
                sumX += x;
                sumX2 += x * x;
                sumX3 += x * x * x;
                sumX4 += x * x * x * x;
                sumY += y;
                sumXY += x * y;
                sumX2Y += x * x * y;
            });

            // Solve normal equations (simplified for quadratic)
            const denom = (n * sumX4 - sumX2 * sumX2);
            if (Math.abs(denom) < 0.0001) return null;
            
            const a = (n * sumX2Y - sumX2 * sumY) / denom;
            const b = (sumXY * sumX2 - sumX * sumX2Y) / (sumX * sumX2 - n * sumX3);
            const c = (sumY - b * sumX - a * sumX2) / n;

            return { a, b, c };
        }

        function createAllCharts() {
            console.log("üìä Creating all charts...");
            
            const showBestFit = document.getElementById('showBestFitCheck')?.checked !== false;
            
            // VMG vs Heel - UPWIND with best fit
            const heelUpData = analysis.upwindSample.map(r => ({x: r.vmg, y: Math.abs(r.heel)}));
            const heelUpDatasets = [{
                label: 'Data Points',
                data: heelUpData,
                backgroundColor: 'rgba(16, 185, 129, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(heelUpData);
                if (fit) {
                    const vmgRange = heelUpData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    // Find optimal VMG (where heel = optimal)
                    const optimalHeel = analysis.optimalHeelUp;
                    const optimalVMG = fitLine.reduce((best, point) => {
                        return Math.abs(point.y - optimalHeel) < Math.abs(best.y - optimalHeel) ? point : best;
                    }, fitLine[0]);
                    
                    heelUpDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal heel value (reuse minVMG/maxVMG from above)
                    heelUpDatasets.push({
                        label: `Optimal Heel: ${optimalHeel}¬∞`,
                        data: [
                            { x: minVMG, y: optimalHeel },
                            { x: maxVMG, y: optimalHeel }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('heelVmgUpChart'), {
                type: 'scatter',
                data: { datasets: heelUpDatasets },
                options: getScatterOptions('VMG (kts)', 'Heel (¬∞)', null, null, 0, 25)
            });

            // VMG vs Heel - DOWNWIND with best fit
            const heelDownData = analysis.downwindSample.map(r => ({x: Math.abs(r.vmg), y: Math.abs(r.heel)}));
            const heelDownDatasets = [{
                label: 'Data Points',
                data: heelDownData,
                backgroundColor: 'rgba(59, 130, 246, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(heelDownData);
                if (fit) {
                    const vmgRange = heelDownData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    heelDownDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal heel value (reuse minVMG/maxVMG from above)
                    const optimalHeel = analysis.optimalHeelDown;
                    heelDownDatasets.push({
                        label: `Optimal Heel: ${optimalHeel}¬∞`,
                        data: [
                            { x: minVMG, y: optimalHeel },
                            { x: maxVMG, y: optimalHeel }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('heelVmgDownChart'), {
                type: 'scatter',
                data: { datasets: heelDownDatasets },
                options: getScatterOptions('VMG (kts)', 'Heel (¬∞)', null, null, 0, 25)
            });

            // VMG vs Trim - UPWIND with best fit
            const trimUpData = analysis.upwindSample.map(r => ({x: r.vmg, y: r.trim}));
            const trimUpDatasets = [{
                label: 'Data Points',
                data: trimUpData,
                backgroundColor: 'rgba(168, 85, 247, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(trimUpData);
                if (fit) {
                    const vmgRange = trimUpData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    trimUpDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal trim value (reuse minVMG/maxVMG from above)
                    const optimalTrim = analysis.optimalTrimUp;
                    trimUpDatasets.push({
                        label: `Optimal Trim: ${optimalTrim}¬∞`,
                        data: [
                            { x: minVMG, y: optimalTrim },
                            { x: maxVMG, y: optimalTrim }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('trimVmgUpChart'), {
                type: 'scatter',
                data: { datasets: trimUpDatasets },
                options: getScatterOptions('VMG (kts)', 'Trim (¬∞ bow up/down)', null, null, -15, 15)
            });

            // VMG vs Trim - DOWNWIND with best fit
            const trimDownData = analysis.downwindSample.map(r => ({x: Math.abs(r.vmg), y: r.trim}));
            const trimDownDatasets = [{
                label: 'Data Points',
                data: trimDownData,
                backgroundColor: 'rgba(251, 191, 36, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(trimDownData);
                if (fit) {
                    const vmgRange = trimDownData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    trimDownDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal trim value (reuse minVMG/maxVMG from above)
                    const optimalTrim = analysis.optimalTrimDown;
                    trimDownDatasets.push({
                        label: `Optimal Trim: ${optimalTrim}¬∞`,
                        data: [
                            { x: minVMG, y: optimalTrim },
                            { x: maxVMG, y: optimalTrim }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('trimVmgDownChart'), {
                type: 'scatter',
                data: { datasets: trimDownDatasets },
                options: getScatterOptions('VMG (kts)', 'Trim (¬∞ bow up/down)', null, null, -15, 15)
            });

            // Other charts
            new Chart(document.getElementById('heelDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.heelDistribution.map(h => `${h.heel}¬∞`),
                    datasets: [{ data: analysis.heelDistribution.map(h => h.count), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Heel Angle', 'Count')
            });

            // ENHANCED POLAR DIAGRAM - Radar style with optimal angle markers
            const polarChart = document.getElementById('polarChart');
            const polarLabels = analysis.polar.map(p => p.twa);
            const polarTarget = analysis.polar.map(p => p.target);
            const polarAvg = analysis.polar.map(p => p.avg);
            
            // Find optimal VMG angles (upwind and downwind)
            const upwindPolar = analysis.polar.filter(p => p.twa <= 90);
            const downwindPolar = analysis.polar.filter(p => p.twa > 90);
            
            let optimalUpwindVMG = { angle: 45, speed: 0, vmg: 0 };
            upwindPolar.forEach(p => {
                const vmg = p.target * Math.cos(p.twa * Math.PI / 180);
                if (vmg > optimalUpwindVMG.vmg) {
                    optimalUpwindVMG = { angle: p.twa, speed: p.target, vmg };
                }
            });
            
            let optimalDownwindVMG = { angle: 135, speed: 0, vmg: 0 };
            downwindPolar.forEach(p => {
                const vmg = p.target * Math.cos((180 - p.twa) * Math.PI / 180);
                if (vmg > optimalDownwindVMG.vmg) {
                    optimalDownwindVMG = { angle: p.twa, speed: p.target, vmg };
                }
            });
            
            new Chart(polarChart, {
                type: 'radar',
                data: {
                    labels: polarLabels,
                    datasets: [
                        {
                            label: 'Target Speed (90th %ile)',
                            data: polarTarget,
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: 'rgba(16, 185, 129, 0.15)',
                            borderWidth: 3,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        },
                        {
                            label: 'Average Speed',
                            data: polarAvg,
                            borderColor: 'rgb(251, 191, 36)',
                            backgroundColor: 'rgba(251, 191, 36, 0.08)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            borderDash: [5, 5]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: Math.ceil(Math.max(...polarTarget) + 1),
                            ticks: {
                                stepSize: 1,
                                color: '#9CA3AF',
                                backdropColor: 'transparent',
                                font: { size: 10 }
                            },
                            grid: { color: 'rgba(107, 114, 128, 0.3)' },
                            pointLabels: {
                                color: '#E5E7EB',
                                font: { size: 11, weight: '500' }
                            },
                            angleLines: { color: 'rgba(107, 114, 128, 0.3)' }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { color: '#E5E7EB', font: { size: 11 }, padding: 10 }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(31, 41, 55, 0.95)',
                            titleColor: '#F3F4F6',
                            bodyColor: '#E5E7EB',
                            borderColor: '#4B5563',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                afterLabel: function(context) {
                                    const idx = context.dataIndex;
                                    const twa = polarLabels[idx];
                                    const speed = context.parsed.r;
                                    const vmg = (speed * Math.cos(twa * Math.PI / 180)).toFixed(2);
                                    return `VMG: ${vmg} kts\nPoints: ${analysis.polar[idx].count}`;
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                optimalUpwind: {
                                    type: 'point',
                                    xValue: optimalUpwindVMG.angle,
                                    yValue: optimalUpwindVMG.speed,
                                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                    borderColor: 'rgb(239, 68, 68)',
                                    borderWidth: 2,
                                    radius: 6,
                                    label: {
                                        content: `‚¨ÜÔ∏è ${optimalUpwindVMG.angle}¬∞`,
                                        enabled: true,
                                        position: 'end',
                                        backgroundColor: 'rgba(239, 68, 68, 0.8)',
                                        color: '#fff',
                                        font: { size: 10, weight: 'bold' },
                                        padding: 4
                                    }
                                },
                                optimalDownwind: {
                                    type: 'point',
                                    xValue: optimalDownwindVMG.angle,
                                    yValue: optimalDownwindVMG.speed,
                                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                                    borderColor: 'rgb(59, 130, 246)',
                                    borderWidth: 2,
                                    radius: 6,
                                    label: {
                                        content: `‚¨áÔ∏è ${optimalDownwindVMG.angle}¬∞`,
                                        enabled: true,
                                        position: 'start',
                                        backgroundColor: 'rgba(59, 130, 246, 0.8)',
                                        color: '#fff',
                                        font: { size: 10, weight: 'bold' },
                                        padding: 4
                                    }
                                }
                            }
                        }
                    }
                }
            });
            
            // Store optimal angles for PDF export
            analysis.optimalAngles = {
                upwind: optimalUpwindVMG,
                downwind: optimalDownwindVMG
            };

            new Chart(document.getElementById('twaDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.twaDist.map(t => `${t.twa}¬∞`),
                    datasets: [{ data: analysis.twaDist.map(t => t.count), backgroundColor: 'rgba(168, 85, 247, 0.7)' }]
                },
                options: getBarOptions('TWA', 'Count')
            });

            new Chart(document.getElementById('speedDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.speedDist.map(s => `${s.speed}`),
                    datasets: [{ data: analysis.speedDist.map(s => s.count), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });

            // NEW: Heel Distribution - Upwind
            const heelBinsUp = {};
            analysis.heelDistributionUpwind.forEach(h => {
                const bin = Math.round(h / 2) * 2;
                heelBinsUp[bin] = (heelBinsUp[bin] || 0) + 1;
            });
            new Chart(document.getElementById('heelDistUpChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(heelBinsUp).sort((a,b) => a-b).map(h => `${h}¬∞`),
                    datasets: [{ data: Object.keys(heelBinsUp).sort((a,b) => a-b).map(h => heelBinsUp[h]), backgroundColor: 'rgba(16, 185, 129, 0.7)' }]
                },
                options: getBarOptions('Heel Angle (¬∞)', 'Count')
            });

            // NEW: Heel Distribution - Downwind
            const heelBinsDown = {};
            analysis.heelDistributionDownwind.forEach(h => {
                const bin = Math.round(h / 2) * 2;
                heelBinsDown[bin] = (heelBinsDown[bin] || 0) + 1;
            });
            new Chart(document.getElementById('heelDistDownChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(heelBinsDown).sort((a,b) => a-b).map(h => `${h}¬∞`),
                    datasets: [{ data: Object.keys(heelBinsDown).sort((a,b) => a-b).map(h => heelBinsDown[h]), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Heel Angle (¬∞)', 'Count')
            });

            // NEW: Speed Distribution - Upwind
            const speedBinsUp = {};
            analysis.speedDistributionUpwind.forEach(s => {
                const bin = Math.round(s * 2) / 2;
                speedBinsUp[bin] = (speedBinsUp[bin] || 0) + 1;
            });
            
            // NEW: Speed Distribution - Downwind
            const speedBinsDown = {};
            analysis.speedDistributionDownwind.forEach(s => {
                const bin = Math.round(s * 2) / 2;
                speedBinsDown[bin] = (speedBinsDown[bin] || 0) + 1;
            });
            
            // Calculate unified speed range for both charts
            const allSpeedBins = [
                ...Object.keys(speedBinsUp).map(Number),
                ...Object.keys(speedBinsDown).map(Number)
            ];
            const minSpeed = Math.floor(Math.min(...allSpeedBins));
            const maxSpeed = Math.ceil(Math.max(...allSpeedBins));
            const speedRange = [];
            for (let s = minSpeed; s <= maxSpeed; s += 0.5) {
                speedRange.push(s.toFixed(1));
            }
            
            new Chart(document.getElementById('speedDistUpChart'), {
                type: 'bar',
                data: {
                    labels: speedRange,
                    datasets: [{ 
                        data: speedRange.map(s => speedBinsUp[parseFloat(s)] || 0), 
                        backgroundColor: 'rgba(16, 185, 129, 0.7)' 
                    }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });
            
            new Chart(document.getElementById('speedDistDownChart'), {
                type: 'bar',
                data: {
                    labels: speedRange,
                    datasets: [{ 
                        data: speedRange.map(s => speedBinsDown[parseFloat(s)] || 0), 
                        backgroundColor: 'rgba(59, 130, 246, 0.7)' 
                    }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });

            // NEW: Tack Performance Scatter Plot (Entry vs Exit Speed, colored by distance lost)
            if (analysis.tacks && analysis.tacks.length > 0) {
                const maxLoss = Math.max(...analysis.tacks.map(t => t.distanceLost));
                const getColorForLoss = (loss) => {
                    const ratio = loss / maxLoss;
                    if (ratio < 0.33) return 'rgba(16, 185, 129, 0.8)';  // Green - good
                    if (ratio < 0.67) return 'rgba(251, 191, 36, 0.8)';  // Yellow - moderate
                    return 'rgba(239, 68, 68, 0.8)';                      // Red - poor
                };
                
                new Chart(document.getElementById('tackScatterChart'), {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Perfect Retention',
                                type: 'line',
                                data: [
                                    {x: 0, y: 0},
                                    {x: 10, y: 10}
                                ],
                                borderColor: 'rgba(156, 163, 175, 0.5)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                label: 'Tacks',
                                data: analysis.tacks.map(t => ({
                                    x: t.entrySpeed,
                                    y: t.exitSpeed,
                                    tackNum: t.tackNumber,
                                    loss: t.distanceLost,
                                    efficiency: t.efficiency
                                })),
                                backgroundColor: analysis.tacks.map(t => getColorForLoss(t.distanceLost)),
                                pointRadius: 8,
                                pointHoverRadius: 10
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { color: '#9CA3AF', font: { size: 11 } }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.datasetIndex === 0) return null; // Skip reference line tooltip
                                        const d = context.raw;
                                        return [
                                            `Tack #${d.tackNum}`,
                                            `Entry: ${d.x.toFixed(1)} kts`,
                                            `Exit: ${d.y.toFixed(1)} kts`,
                                            `Efficiency: ${d.efficiency.toFixed(0)}%`,
                                            `Loss: ${d.loss.toFixed(1)}m`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Entry Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { display: true, text: 'Exit Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            }
                        }
                    }
                });
            }

            // NEW: Gybe Performance Scatter Plot
            if (analysis.gybes && analysis.gybes.length > 0) {
                const maxLoss = Math.max(...analysis.gybes.map(g => g.distanceLost));
                const getColorForLoss = (loss) => {
                    const ratio = loss / maxLoss;
                    if (ratio < 0.33) return 'rgba(16, 185, 129, 0.8)';
                    if (ratio < 0.67) return 'rgba(251, 191, 36, 0.8)';
                    return 'rgba(239, 68, 68, 0.8)';
                };
                
                new Chart(document.getElementById('gybeScatterChart'), {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: 'Perfect Retention',
                                type: 'line',
                                data: [
                                    {x: 0, y: 0},
                                    {x: 10, y: 10}
                                ],
                                borderColor: 'rgba(156, 163, 175, 0.5)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                pointRadius: 0,
                                fill: false
                            },
                            {
                                label: 'Gybes',
                                data: analysis.gybes.map(g => ({
                                    x: g.entrySpeed,
                                    y: g.exitSpeed,
                                    gybeNum: g.tackNumber,
                                    loss: g.distanceLost,
                                    efficiency: g.efficiency
                                })),
                                backgroundColor: analysis.gybes.map(g => getColorForLoss(g.distanceLost)),
                                pointRadius: 8,
                                pointHoverRadius: 10
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { color: '#9CA3AF', font: { size: 11 } }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.datasetIndex === 0) return null; // Skip reference line tooltip
                                        const d = context.raw;
                                        return [
                                            `Gybe #${d.gybeNum}`,
                                            `Entry: ${d.x.toFixed(1)} kts`,
                                            `Exit: ${d.y.toFixed(1)} kts`,
                                            `Efficiency: ${d.efficiency.toFixed(0)}%`,
                                            `Loss: ${d.loss.toFixed(1)}m`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Entry Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { display: true, text: 'Exit Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            }
                        }
                    }
                });
            }

            // NEW: Speed Over Time Charts (Njord-style) - SHOW ALL TACKS
            if (analysis.tacks && analysis.tacks.length >= 3 && document.getElementById('tackSpeedOverTime')) {
                const validTacks = [...analysis.tacks]
                    .filter(t => t.speedOverTime && t.speedOverTime.length > 0);
                
                if (validTacks.length >= 3) {
                    const datasets = [];
                    
                    // Add ALL individual tacks (subtle blue lines)
                    validTacks.forEach((tack) => {
                        datasets.push({
                            label: `T${tack.tackNumber}`,
                            data: tack.speedOverTime.map(d => ({ x: d.time, y: d.speed })),
                            borderColor: 'rgba(59, 130, 246, 0.4)', // Blue, semi-transparent
                            backgroundColor: 'transparent',
                            borderWidth: 2, // Thicker than before (was 3, but individual should be 2)
                            pointRadius: 0,
                            tension: 0.4
                        });
                    });
                    
                    // Calculate AVERAGE tack speed over time - across ALL time points from ALL tacks
                    const allTimePoints = new Set();
                    validTacks.forEach(tack => {
                        tack.speedOverTime.forEach(d => allTimePoints.add(d.time));
                    });
                    const sortedTimePoints = Array.from(allTimePoints).sort((a, b) => a - b);
                    
                    const avgSpeedData = sortedTimePoints.map(time => {
                        const speedsAtTime = validTacks.map(tack => {
                            const point = tack.speedOverTime.find(d => d.time === time);
                            return point ? point.speed : null;
                        }).filter(s => s !== null);
                        
                        // Only include time point if at least 3 tacks have data there
                        if (speedsAtTime.length >= 3) {
                            const avgSpeed = speedsAtTime.reduce((sum, s) => sum + s, 0) / speedsAtTime.length;
                            return { x: time, y: avgSpeed };
                        }
                        return null;
                    }).filter(d => d !== null);
                    
                    // Add AVERAGE line (prominent red/pink)
                    datasets.push({
                        label: 'Average Tack',
                        data: avgSpeedData,
                        borderColor: 'rgba(236, 72, 153, 1)', // Pink/red like Njord
                        backgroundColor: 'transparent',
                        borderWidth: 4, // Thicker for visibility
                        pointRadius: 0,
                        tension: 0.4,
                        order: -1 // Draw on top
                    });
                    
                    new Chart(document.getElementById('tackSpeedOverTime'), {
                        type: 'line',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                annotation: {
                                    annotations: {
                                        minSpeedLine: {
                                            type: 'line',
                                            xMin: 0,
                                            xMax: 0,
                                            borderColor: 'rgba(220, 38, 38, 0.8)', // Red dashed line
                                            borderWidth: 2,
                                            borderDash: [5, 5],
                                            label: {
                                                display: true,
                                                content: 'Min Speed Point',
                                                position: 'start',
                                                backgroundColor: 'rgba(220, 38, 38, 0.8)',
                                                color: '#fff',
                                                font: {
                                                    size: 10
                                                }
                                            }
                                        }
                                    }
                                },
                                legend: { 
                                    display: true,
                                    position: 'top',
                                    labels: { 
                                        color: '#9CA3AF',
                                        font: { size: 11 },
                                        boxWidth: 15,
                                        padding: 8,
                                        filter: function(item) {
                                            // Only show "Average Tack" in legend
                                            return item.text === 'Average Tack';
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            return `Time: ${context[0].parsed.x}s`;
                                        },
                                        label: function(context) {
                                            return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} kts`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: { 
                                        display: true, 
                                        text: 'Seconds from Minimum Speed', 
                                        color: '#9CA3AF' 
                                    },
                                    ticks: { color: '#9CA3AF' },
                                    grid: { 
                                        color: 'rgba(75, 85, 99, 0.3)',
                                        drawTicks: true
                                    }
                                },
                                y: {
                                    title: { 
                                        display: true, 
                                        text: 'Speed (kts)', 
                                        color: '#9CA3AF' 
                                    },
                                    ticks: { color: '#9CA3AF' },
                                    grid: { color: 'rgba(75, 85, 99, 0.3)' }
                                }
                            },
                            interaction: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    });
                }
            }
            
            // Gybe Speed Over Time - SHOW ALL GYBES
            if (analysis.gybes && analysis.gybes.length >= 3 && document.getElementById('gybeSpeedOverTime')) {
                const validGybes = [...analysis.gybes]
                    .filter(g => g.speedOverTime && g.speedOverTime.length > 0);
                
                if (validGybes.length >= 3) {
                    const datasets = [];
                    
                    // Add ALL individual gybes (subtle blue lines)
                    validGybes.forEach((gybe) => {
                        datasets.push({
                            label: `G${gybe.tackNumber}`,
                            data: gybe.speedOverTime.map(d => ({ x: d.time, y: d.speed })),
                            borderColor: 'rgba(59, 130, 246, 0.4)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        });
                    });
                    
                    // Calculate AVERAGE gybe speed over time - across ALL time points from ALL gybes
                    const allTimePoints = new Set();
                    validGybes.forEach(gybe => {
                        gybe.speedOverTime.forEach(d => allTimePoints.add(d.time));
                    });
                    const sortedTimePoints = Array.from(allTimePoints).sort((a, b) => a - b);
                    
                    const avgSpeedData = sortedTimePoints.map(time => {
                        const speedsAtTime = validGybes.map(gybe => {
                            const point = gybe.speedOverTime.find(d => d.time === time);
                            return point ? point.speed : null;
                        }).filter(s => s !== null);
                        
                        // Only include time point if at least 3 gybes have data there
                        if (speedsAtTime.length >= 3) {
                            const avgSpeed = speedsAtTime.reduce((sum, s) => sum + s, 0) / speedsAtTime.length;
                            return { x: time, y: avgSpeed };
                        }
                        return null;
                    }).filter(d => d !== null);
                    
                    // Add AVERAGE line (prominent red/pink)
                    datasets.push({
                        label: 'Average Gybe',
                        data: avgSpeedData,
                        borderColor: 'rgba(236, 72, 153, 1)',
                        backgroundColor: 'transparent',
                        borderWidth: 4,
                        pointRadius: 0,
                        tension: 0.4,
                        order: -1
                    });
                    
                    new Chart(document.getElementById('gybeSpeedOverTime'), {
                        type: 'line',
                        data: { datasets },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                annotation: {
                                    annotations: {
                                        minSpeedLine: {
                                            type: 'line',
                                            xMin: 0,
                                            xMax: 0,
                                            borderColor: 'rgba(220, 38, 38, 0.8)',
                                            borderWidth: 2,
                                            borderDash: [5, 5],
                                            label: {
                                                display: true,
                                                content: 'Min Speed Point',
                                                position: 'start',
                                                backgroundColor: 'rgba(220, 38, 38, 0.8)',
                                                color: '#fff',
                                                font: {
                                                    size: 10
                                                }
                                            }
                                        }
                                    }
                                },
                                legend: { 
                                    display: true,
                                    position: 'top',
                                    labels: { 
                                        color: '#9CA3AF',
                                        font: { size: 11 },
                                        boxWidth: 15,
                                        padding: 8,
                                        filter: function(item) {
                                            return item.text === 'Average Gybe';
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            return `Time: ${context[0].parsed.x}s`;
                                        },
                                        label: function(context) {
                                            return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} kts`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'linear',
                                    title: { 
                                        display: true, 
                                        text: 'Seconds from Minimum Speed', 
                                        color: '#9CA3AF' 
                                    },
                                    ticks: { color: '#9CA3AF' },
                                    grid: { 
                                        color: 'rgba(75, 85, 99, 0.3)',
                                        drawTicks: true
                                    }
                                },
                                y: {
                                    title: { 
                                        display: true, 
                                        text: 'Speed (kts)', 
                                        color: '#9CA3AF' 
                                    },
                                    ticks: { color: '#9CA3AF' },
                                    grid: { color: 'rgba(75, 85, 99, 0.3)' }
                                }
                            },
                            interaction: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    });
                }
            }

            console.log("‚úÖ All charts created");
        }

        function createWindRose() {
            if (!analysis || !analysis.trackData) return;
            
            const canvas = document.getElementById('windRose');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = 150;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create 360 bins (1¬∞ each)
            const headingBins = new Array(360).fill(0);
            analysis.trackData.forEach(d => {
                if (d.speed > 2) { // Only count when moving
                    const heading = Math.round(d.cog || d.heading) % 360;
                    headingBins[heading]++;
                }
            });
            
            // Find max for scaling
            const maxCount = Math.max(...headingBins);
            
            // Draw compass rose background
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.3)';
            ctx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 50; r <= maxRadius; r += 50) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Cardinal directions
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 18 : 14;
            ctx.fillStyle = 'rgba(156, 163, 175, 0.6)';
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('N', centerX, centerY - maxRadius - 20);
            ctx.fillText('E', centerX + maxRadius + 20, centerY);
            ctx.fillText('S', centerX, centerY + maxRadius + 20);
            ctx.fillText('W', centerX - maxRadius - 20, centerY);
            
            // Draw heading bars (grouped in 5¬∞ bins for clarity)
            const peak1 = analysis.predominantHeadings.peak1;
            const peak2 = analysis.predominantHeadings.peak2;
            
            for (let deg = 0; deg < 360; deg += 5) {
                // Sum counts in this 5¬∞ bin
                let count = 0;
                for (let i = 0; i < 5; i++) {
                    count += headingBins[(deg + i) % 360];
                }
                
                if (count === 0) continue;
                
                // Determine color based on proximity to peaks
                let color;
                const distToPeak1 = Math.min(Math.abs(deg - peak1), 360 - Math.abs(deg - peak1));
                const distToPeak2 = Math.min(Math.abs(deg - peak2), 360 - Math.abs(deg - peak2));
                
                if (distToPeak1 < 20) {
                    color = 'rgba(59, 130, 246, 0.8)'; // Blue - port tack
                } else if (distToPeak2 < 20) {
                    color = 'rgba(34, 197, 94, 0.8)'; // Green - starboard tack
                } else {
                    color = 'rgba(156, 163, 175, 0.4)'; // Gray - other
                }
                
                // Calculate bar length
                const barLength = (count / maxCount) * maxRadius;
                
                // Convert to radians (0¬∞ = North = up)
                const angle = (deg - 90) * Math.PI / 180;
                
                // Draw wedge
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * barLength,
                    centerY + Math.sin(angle) * barLength
                );
                ctx.lineTo(
                    centerX + Math.cos(angle + 5 * Math.PI / 180) * barLength,
                    centerY + Math.sin(angle + 5 * Math.PI / 180) * barLength
                );
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            
            // Draw wind direction arrow
            const roseWindDir = analysis.predominantHeadings.estimatedWindDir;
            const windAngle = (roseWindDir - 90) * Math.PI / 180;
            const arrowLength = maxRadius * 1.15;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.lineWidth = 3;
            
            // Arrow shaft
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(windAngle) * arrowLength,
                centerY + Math.sin(windAngle) * arrowLength
            );
            ctx.stroke();
            
            // Arrow head
            const headSize = 15;
            const arrowX = centerX + Math.cos(windAngle) * arrowLength;
            const arrowY = centerY + Math.sin(windAngle) * arrowLength;
            
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - headSize * Math.cos(windAngle - Math.PI / 6),
                arrowY - headSize * Math.sin(windAngle - Math.PI / 6)
            );
            ctx.lineTo(
                arrowX - headSize * Math.cos(windAngle + Math.PI / 6),
                arrowY - headSize * Math.sin(windAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            
            // Wind direction label
            ctx.fillStyle = 'rgba(251, 191, 36, 1)';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(`Wind ${roseWindDir.toFixed(0)}¬∞`, arrowX + 15, arrowY);
            
            console.log("üß≠ Wind rose created");
        }

        function createWindShiftTimeline() {
            if (!analysis || !analysis.trackData) return;
            
            const canvas = document.getElementById('windShiftTimeline');
            if (!canvas) {
                console.warn("‚ö†Ô∏è Wind shift timeline canvas not found");
                return;
            }
            
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.warn("‚ö†Ô∏è Chart.js library blocked - using fallback display");
                canvas.parentElement.innerHTML = `
                    <div class="p-6 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <div class="text-yellow-400 font-semibold mb-2">‚ö†Ô∏è Wind Shift Timeline Unavailable</div>
                        <div class="text-sm text-gray-300 mb-3">Chart library blocked by browser security.</div>
                        <div class="text-xs text-gray-400">
                            <strong>Wind Shift Summary:</strong><br/>
                            ${analysis.windAnalysis ? `
                                ‚Ä¢ ${analysis.windAnalysis.liftPct.toFixed(0)}% of time on lifts<br/>
                                ‚Ä¢ ${(100 - analysis.windAnalysis.liftPct).toFixed(0)}% of time on headers<br/>
                                ‚Ä¢ Avg shift magnitude: ${analysis.windAnalysis.avgShift ? analysis.windAnalysis.avgShift.toFixed(1) : 'N/A'}¬∞
                            ` : 'Wind shift data available in full desktop version'}
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get upwind data with timestamps
            const upwindData = analysis.trackData
                .filter(d => d.speed > 3 && d.timestamp)
                .map((d, idx) => ({
                    time: d.timestamp,
                    twaDeviation: d.shiftAmount || 0,
                    isUpwind: d.isUpwind,  // Use existing isUpwind property
                    isLift: d.isLift,
                    isHeader: d.isHeader,
                    index: idx
                }));
            
            if (upwindData.length < 10) {
                console.warn("‚ö†Ô∏è Not enough data for timeline");
                canvas.parentElement.innerHTML = `
                    <div class="p-4 bg-gray-700 rounded text-center text-gray-400">
                        Not enough sailing data to generate wind shift timeline
                    </div>
                `;
                return;
            }
            
            // Sample every Nth point to avoid overcrowding
            const sampleRate = Math.max(1, Math.floor(upwindData.length / 500));
            const sampledData = upwindData.filter((_, idx) => idx % sampleRate === 0);
            
            // Calculate actual min/max for better scaling
            const deviations = sampledData.map(d => d.twaDeviation);
            const maxDeviation = Math.max(...deviations.map(Math.abs));
            const yScale = Math.ceil(maxDeviation / 5) * 5; // Round up to nearest 5¬∞
            
            // Create time labels
            const labels = sampledData.map(d => {
                try {
                    const date = new Date(d.time);
                    return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                } catch (e) {
                    return '';
                }
            });
            
            // Find upwind/downwind segments for background shading
            const segments = [];
            let currentSegment = { start: 0, isUpwind: sampledData[0].isUpwind };
            
            for (let i = 1; i < sampledData.length; i++) {
                if (sampledData[i].isUpwind !== currentSegment.isUpwind) {
                    currentSegment.end = i;
                    segments.push({...currentSegment});
                    currentSegment = { start: i, isUpwind: sampledData[i].isUpwind };
                }
            }
            currentSegment.end = sampledData.length;
            segments.push(currentSegment);
            
            // Create background boxes for segments
            const backgroundBoxes = segments.map(seg => ({
                type: 'box',
                xMin: seg.start,
                xMax: seg.end,
                yMin: -yScale,
                yMax: yScale,
                backgroundColor: seg.isUpwind ? 'rgba(16, 185, 129, 0.08)' : 'rgba(59, 130, 246, 0.08)',
                borderWidth: 0,
                label: {
                    display: false
                }
            }));
            
            // Add tack markers as vertical lines
            const tackMarkers = [];
            if (analysis.tacks && analysis.tacks.length > 0) {
                analysis.tacks.forEach(tack => {
                    // Find the index in sampledData closest to this tack's timestamp
                    const tackTime = new Date(tack.timestamp).getTime();
                    let closestIdx = -1;
                    let minDiff = Infinity;
                    
                    sampledData.forEach((d, idx) => {
                        const dataTime = new Date(d.time).getTime();
                        const diff = Math.abs(tackTime - dataTime);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = idx;
                        }
                    });
                    
                    if (closestIdx >= 0 && minDiff < 60000) { // Within 60 seconds
                        tackMarkers.push({
                            type: 'line',
                            xMin: closestIdx,
                            xMax: closestIdx,
                            yMin: -yScale,
                            yMax: yScale,
                            borderColor: 'rgba(251, 191, 36, 0.4)', // More subtle yellow
                            borderWidth: 2, // Thinner line
                            borderDash: [5, 5], // Subtle dashes
                            label: {
                                display: true,
                                content: 'T',
                                position: 'start',
                                backgroundColor: 'rgba(251, 191, 36, 0.7)',
                                color: '#000',
                                font: {
                                    size: 10,
                                    weight: 'bold'
                                },
                                padding: 2
                            }
                        });
                    }
                });
            }
            
            // Add gybe markers as vertical lines (orange)
            const gybeMarkers = [];
            if (analysis.gybes && analysis.gybes.length > 0) {
                analysis.gybes.forEach(gybe => {
                    const gybeTime = new Date(gybe.timestamp).getTime();
                    let closestIdx = -1;
                    let minDiff = Infinity;
                    
                    sampledData.forEach((d, idx) => {
                        const dataTime = new Date(d.time).getTime();
                        const diff = Math.abs(gybeTime - dataTime);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = idx;
                        }
                    });
                    
                    if (closestIdx >= 0 && minDiff < 60000) { // Within 60 seconds
                        gybeMarkers.push({
                            type: 'line',
                            xMin: closestIdx,
                            xMax: closestIdx,
                            yMin: -yScale,
                            yMax: yScale,
                            borderColor: 'rgba(251, 146, 60, 0.4)', // More subtle orange
                            borderWidth: 2, // Thinner
                            borderDash: [5, 5],
                            label: {
                                display: true,
                                content: 'G',  // Simple "G" for gybe
                                position: 'start',
                                backgroundColor: 'rgba(251, 146, 60, 0.7)',
                                color: '#000',
                                font: {
                                    size: 10,
                                    weight: 'bold'
                                },
                                padding: 2
                            }
                        });
                    }
                });
            }
            
            // Combine annotations
            const allAnnotations = [...backgroundBoxes, ...tackMarkers, ...gybeMarkers];
            
            try {
                new Chart(canvas, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'TWA Deviation',
                            data: sampledData.map(d => d.twaDeviation),
                            borderColor: 'rgba(156, 163, 175, 0.8)',
                            segment: {
                                borderColor: ctx => {
                                    const curr = ctx.p1.parsed.y;
                                    return curr < -3 ? 'rgba(34, 197, 94, 0.8)' :
                                           curr > 3 ? 'rgba(239, 68, 68, 0.8)' :
                                           'rgba(156, 163, 175, 0.6)';
                                }
                            },
                            backgroundColor: function(context) {
                                const value = context.parsed?.y || 0;
                                return value < 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                            },
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const point = sampledData[idx];
                                        const val = context.parsed.y;
                                        const type = val < -3 ? 'LIFT' : val > 3 ? 'HEADER' : 'Neutral';
                                        const leg = point.isUpwind ? '‚õµ Upwind' : 'üèÑ Downwind';
                                        return `${type}: ${Math.abs(val).toFixed(1)}¬∞ ${val < 0 ? 'favorable' : 'unfavorable'} ‚Ä¢ ${leg}`;
                                    }
                                }
                            },
                            annotation: {
                                annotations: allAnnotations
                            }
                        },
                        scales: {
                            x: {
                                title: { 
                                    display: true, 
                                    text: 'Time', 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 16 : 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: { 
                                    color: '#9CA3AF',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                    font: { 
                                        size: window.innerWidth <= 768 ? 14 : 12
                                    }
                                },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { 
                                    display: true, 
                                    text: 'TWA Deviation (¬∞)', 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 16 : 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: { 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 14 : 12
                                    }
                                },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' },
                                min: -yScale,
                                max: yScale
                            }
                        }
                    }
                });
                
                console.log("üìà Wind shift timeline created with", sampledData.length, "points");
            } catch (error) {
                console.error("‚ùå Error creating wind shift timeline:", error);
                canvas.parentElement.innerHTML = `
                    <div class="p-4 bg-red-900 bg-opacity-20 border border-red-600 rounded text-center">
                        <div class="text-red-400 font-semibold">Error creating timeline chart</div>
                        <div class="text-xs text-gray-400 mt-2">${error.message}</div>
                    </div>
                `;
            }
        }

        function createLaylinesCanvas() {
            if (!analysis || !analysis.laylines) return;
            
            const canvas = document.getElementById('laylinesCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 120;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background circle
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw compass directions
            ctx.fillStyle = 'rgba(156, 163, 175, 0.4)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('N', centerX, centerY - radius - 10);
            ctx.fillText('E', centerX + radius + 15, centerY + 5);
            ctx.fillText('S', centerX, centerY + radius + 20);
            ctx.fillText('W', centerX - radius - 15, centerY + 5);
            
            const laylinesWindDir = analysis.laylines.windDirection;
            const pointingAngle = analysis.laylines.pointingAngle;
            
            // Draw wind direction arrow (pointing FROM)
            const windAngle = (laylinesWindDir - 90) * Math.PI / 180;
            const windLength = radius * 0.8;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(windAngle) * windLength,
                centerY + Math.sin(windAngle) * windLength
            );
            ctx.stroke();
            
            // Wind arrow head
            const arrowX = centerX + Math.cos(windAngle) * windLength;
            const arrowY = centerY + Math.sin(windAngle) * windLength;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 10 * Math.cos(windAngle - Math.PI / 6), arrowY - 10 * Math.sin(windAngle - Math.PI / 6));
            ctx.lineTo(arrowX - 10 * Math.cos(windAngle + Math.PI / 6), arrowY - 10 * Math.sin(windAngle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            // Draw port tack heading (blue) - this is the heading you sail when closehauled on port
            const portAngle = (analysis.laylines.portTackHeading - 90) * Math.PI / 180;
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(portAngle) * radius,
                centerY + Math.sin(portAngle) * radius
            );
            ctx.stroke();
            
            // Draw starboard tack heading (green) - this is the heading you sail when closehauled on starboard
            const stbdAngle = (analysis.laylines.starboardTackHeading - 90) * Math.PI / 180;
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.9)';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(stbdAngle) * radius,
                centerY + Math.sin(stbdAngle) * radius
            );
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw pointing angle arcs
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6, 
                (laylinesWindDir - pointingAngle - 90) * Math.PI / 180,
                (laylinesWindDir - 90) * Math.PI / 180,
                true);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6,
                (laylinesWindDir - 90) * Math.PI / 180,
                (laylinesWindDir + pointingAngle - 90) * Math.PI / 180,
                false);
            ctx.stroke();
            
            // Label pointing angles
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${pointingAngle}¬∞`, centerX - radius * 0.4, centerY - 10);
            ctx.fillText(`${pointingAngle}¬∞`, centerX + radius * 0.4, centerY - 10);
            
            // Labels
            ctx.fillStyle = 'rgba(59, 130, 246, 1)';
            ctx.fillText('Port', 
                centerX + Math.cos(portAngle) * (radius + 25),
                centerY + Math.sin(portAngle) * (radius + 25)
            );
            
            ctx.fillStyle = 'rgba(34, 197, 94, 1)';
            ctx.fillText('Stbd',
                centerX + Math.cos(stbdAngle) * (radius + 25),
                centerY + Math.sin(stbdAngle) * (radius + 25)
            );
            
            console.log("üìê Laylines canvas created");
        }

        function createLearningCurveChart() {
            if (!analysis || !analysis.multiRaceComparison || analysis.multiRaceComparison.racesAnalyzed < 2) return;
            
            const canvas = document.getElementById('learningCurveChart');
            if (!canvas) return;
            
            const improvement = analysis.multiRaceComparison.improvement;
            const labels = improvement.map(r => `Race ${parseInt(r.race) + 1}`);
            
            new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Avg VMG',
                            data: improvement.map(r => r.vmg),
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            yAxisID: 'y',
                            borderWidth: 3,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        },
                        {
                            label: 'Tack Efficiency',
                            data: improvement.map(r => r.tackEff),
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            yAxisID: 'y1',
                            borderWidth: 2,
                            pointRadius: 4,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'Boat Handling',
                            data: improvement.map(r => r.handling),
                            borderColor: 'rgba(251, 191, 36, 1)',
                            backgroundColor: 'rgba(251, 191, 36, 0.1)',
                            yAxisID: 'y1',
                            borderWidth: 2,
                            pointRadius: 4,
                            borderDash: [2, 2]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#9CA3AF', font: { size: 11 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) {
                                        if (context.datasetIndex === 0) {
                                            label += context.parsed.y.toFixed(2) + ' kts';
                                        } else {
                                            label += context.parsed.y.toFixed(0) + '%';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9CA3AF', font: { size: 10 } },
                            grid: { color: 'rgba(75, 85, 99, 0.2)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'VMG (kts)', color: '#9CA3AF' },
                            ticks: { color: '#9CA3AF' },
                            grid: { color: 'rgba(75, 85, 99, 0.3)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Efficiency (%)', color: '#9CA3AF' },
                            ticks: { color: '#9CA3AF' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
            
            console.log("üìà Learning curve chart created");
        }

        function getScatterOptions(xLabel, yLabel, xMin, xMax, yMin, yMax) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            
            const opts = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { 
                        display: false 
                    } 
                },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        },
                        grid: { color: '#374151' },
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        }
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        },
                        grid: { color: '#374151' },
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        }
                    }
                }
            };
            if (xMin !== null) opts.scales.x.min = xMin;
            if (xMax !== null) opts.scales.x.max = xMax;
            if (yMin !== null) opts.scales.y.min = yMin;
            if (yMax !== null) opts.scales.y.max = yMax;
            return opts;
        }

        function getBarOptions(xLabel, yLabel) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        grid: { color: '#374151' }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    }
                }
            };
        }

        function getLineOptions(xLabel, yLabel) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            const legendSize = isMobile ? 15 : 11; // Increased from 13 to 15
            
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { 
                        display: true, 
                        labels: { 
                            color: '#9CA3AF',
                            font: { 
                                size: legendSize,
                                weight: 'bold'
                            },
                            padding: isMobile ? 12 : 10,
                            boxWidth: isMobile ? 20 : 15
                        } 
                    } 
                },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        grid: { color: '#374151' }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    }
                }
            };
        }

        function initMap() {
            if (!analysis || !analysis.trackData) {
                console.error("‚ùå Map init failed: No analysis data");
                return;
            }

            console.log(`üìç Track data length: ${analysis.trackData.length}`);
            console.log(`üìç First track point:`, analysis.trackData[0]);

            const gpsPoints = analysis.trackData
                .map(d => ({ 
                    lat: d.latitude || d.lat, 
                    lon: d.longitude || d.lon, 
                    vmg: d.vmg, 
                    isLift: d.isLift,
                    isHeader: d.isHeader,
                    shiftAmount: d.shiftAmount 
                }))
                .filter(p => p.lat && p.lon && !isNaN(p.lat) && !isNaN(p.lon));

            console.log(`üìç Filtered GPS points: ${gpsPoints.length}`);
            if (gpsPoints.length > 0) {
                console.log(`üìç First GPS point:`, gpsPoints[0]);
            }

            if (gpsPoints.length === 0) {
                document.getElementById('map').innerHTML = '<div class="flex items-center justify-center h-full text-gray-500 p-6" style="min-height: 400px;"><div class="text-center"><div class="text-4xl mb-2">üìç</div><div>No valid GPS coordinates found in data</div><div class="text-sm text-gray-400 mt-2">Check CSV has latitude/longitude columns</div></div></div>';
                console.error("‚ùå No valid GPS points found");
                console.log("üìã Available fields:", Object.keys(analysis.trackData[0] || {}));
                return;
            }

            console.log(`‚úÖ ${gpsPoints.length} GPS points ready for mapping`);

            // Check if Leaflet is available (might be blocked by CSP)
            if (typeof L === 'undefined') {
                console.warn("‚ö†Ô∏è Leaflet library blocked by Content Security Policy");
                document.getElementById('map').innerHTML = `
                    <div class="p-6 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <h4 class="text-yellow-400 font-bold mb-2">‚ö†Ô∏è GPS Map Unavailable in Preview Mode</h4>
                        <p class="text-sm text-gray-300 mb-3">External map library blocked by browser security policy.</p>
                        <p class="text-xs text-gray-400 mb-3"><strong>To view full GPS track visualization:</strong></p>
                        <ol class="text-xs text-gray-400 list-decimal ml-5 space-y-1 mb-4">
                            <li>Click the download button below to save this HTML file</li>
                            <li>Open the downloaded file directly in Chrome or Firefox</li>
                            <li>GPS map will render with full track, laylines, and markers</li>
                        </ol>
                        <div class="mt-4 p-3 bg-gray-800 rounded">
                            <div class="text-xs text-gray-400 font-semibold mb-2">GPS Data Summary (${gpsPoints.length} points):</div>
                            <div class="grid grid-cols-2 gap-2 text-xs text-gray-300">
                                <div>Lat Range: ${Math.min(...gpsPoints.map(p => p.lat)).toFixed(4)}¬∞ to ${Math.max(...gpsPoints.map(p => p.lat)).toFixed(4)}¬∞</div>
                                <div>Lon Range: ${Math.min(...gpsPoints.map(p => p.lon)).toFixed(4)}¬∞ to ${Math.max(...gpsPoints.map(p => p.lon)).toFixed(4)}¬∞</div>
                                <div>Lifts detected: ${gpsPoints.filter(p => p.isLift).length}</div>
                                <div>Headers detected: ${gpsPoints.filter(p => p.isHeader).length}</div>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            console.log(`üó∫Ô∏è Initializing map with ${gpsPoints.length} GPS points`);

            const lats = gpsPoints.map(p => p.lat);
            const lons = gpsPoints.map(p => p.lon);
            const centerLat = (Math.max(...lats) + Math.min(...lats)) / 2;
            const centerLon = (Math.max(...lons) + Math.min(...lons)) / 2;

            if (map) map.remove();
            map = L.map('map').setView([centerLat, centerLon], 14);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap',
                maxZoom: 19
            }).addTo(map);

            // VMG-based coloring
            const vmgValues = gpsPoints.map(p => Math.abs(p.vmg || 0));
            const maxVMG = Math.max(...vmgValues);
            const minVMG = Math.min(...vmgValues);
            const getColor = (vmg) => {
                const absVMG = Math.abs(vmg);
                const ratio = maxVMG > 0 ? (absVMG - minVMG) / (maxVMG - minVMG) : 0;
                if (ratio > 0.75) return '#10B981';  // Green - excellent VMG
                if (ratio > 0.5) return '#3B82F6';   // Blue - good VMG
                if (ratio > 0.25) return '#FBBF24';  // Yellow - moderate VMG
                return '#EF4444';                    // Red - poor VMG
            };

            // Draw GPS track
            for (let i = 0; i < gpsPoints.length - 1; i++) {
                const p1 = gpsPoints[i];
                const p2 = gpsPoints[i + 1];
                const segment = L.polyline([[p1.lat, p1.lon], [p2.lat, p2.lon]], {
                    color: getColor(p1.vmg),
                    weight: 3,
                    opacity: 0.7,
                    className: 'gps-track'
                }).addTo(map);
                mapLayers.track.push(segment);
            }

            // ============================================================
            // WIND SHIFT ZONES - Visual overlay showing lift/header areas
            // ============================================================
            
            /**
             * Detect wind shift zones by grouping consecutive points
             * Returns array of zones with center point, magnitude, duration
             */
            function detectShiftZones(points) {
                const zones = [];
                let currentZone = null;
                
                points.forEach((p, i) => {
                    const hasShift = p.isLift || p.isHeader;
                    const shiftType = p.isLift ? 'lift' : (p.isHeader ? 'header' : null);
                    
                    if (hasShift) {
                        // Start new zone or continue existing
                        if (!currentZone || currentZone.type !== shiftType) {
                            // Save previous zone if it exists
                            if (currentZone && currentZone.points.length >= 3) {
                                zones.push(finalizeZone(currentZone));
                            }
                            // Start new zone
                            currentZone = {
                                type: shiftType,
                                points: [p],
                                shifts: [p.shiftAmount],
                                startIndex: i
                            };
                        } else {
                            // Continue existing zone
                            currentZone.points.push(p);
                            currentZone.shifts.push(p.shiftAmount);
                        }
                    } else {
                        // No shift - close current zone if exists
                        if (currentZone && currentZone.points.length >= 3) {
                            zones.push(finalizeZone(currentZone));
                        }
                        currentZone = null;
                    }
                });
                
                // Don't forget last zone
                if (currentZone && currentZone.points.length >= 3) {
                    zones.push(finalizeZone(currentZone));
                }
                
                return zones;
            }
            
            /**
             * Calculate zone statistics and center point
             */
            function finalizeZone(zone) {
                const avgLat = zone.points.reduce((sum, p) => sum + p.lat, 0) / zone.points.length;
                const avgLon = zone.points.reduce((sum, p) => sum + p.lon, 0) / zone.points.length;
                const avgShift = Math.abs(zone.shifts.reduce((sum, s) => sum + s, 0) / zone.shifts.length);
                const maxShift = Math.max(...zone.shifts.map(s => Math.abs(s)));
                
                // Calculate rough radius based on point spread
                const lats = zone.points.map(p => p.lat);
                const lons = zone.points.map(p => p.lon);
                const latSpread = Math.max(...lats) - Math.min(...lats);
                const lonSpread = Math.max(...lons) - Math.min(...lons);
                const radius = Math.max(latSpread, lonSpread) / 2 * 111000; // Convert to meters
                
                return {
                    type: zone.type,
                    centerLat: avgLat,
                    centerLon: avgLon,
                    avgShift: avgShift,
                    maxShift: maxShift,
                    numPoints: zone.points.length,
                    radius: Math.max(radius, 30), // Minimum 30m radius
                    duration: zone.points.length // Rough duration proxy
                };
            }
            
            /**
             * Draw wind shift zones on map
             */
            function drawWindShiftZones(zones) {
                if (!map || !zones || zones.length === 0) return;
                
                console.log(`üåä Drawing ${zones.length} wind shift zones...`);
                
                zones.forEach((zone, index) => {
                    const isLift = zone.type === 'lift';
                    const color = isLift ? '#10B981' : '#EF4444'; // Green for lift, Red for header
                    const fillOpacity = Math.min(0.15 + (zone.avgShift / 100), 0.3); // Scale with magnitude
                    
                    // Draw circle zone
                    const circle = L.circle([zone.centerLat, zone.centerLon], {
                        radius: zone.radius,
                        color: color,
                        fillColor: color,
                        fillOpacity: fillOpacity,
                        weight: 2,
                        opacity: 0.5,
                        className: 'wind-shift-zone'
                    }).addTo(map);
                    
                    mapLayers.shiftZones.push(circle);  // Track for toggles
                    
                    // Add interactive popup
                    circle.bindPopup(`
                        <div style="text-align: center;">
                            <strong style="color: ${color}; font-size: 14px;">
                                ${isLift ? 'üü¢ LIFT ZONE' : 'üî¥ HEADER ZONE'}
                            </strong><br/>
                            <div style="font-size: 12px; color: #666; margin-top: 6px;">
                                <strong>Avg Shift:</strong> ${zone.avgShift.toFixed(1)}¬∞<br/>
                                <strong>Max Shift:</strong> ${zone.maxShift.toFixed(1)}¬∞<br/>
                                <strong>Duration:</strong> ${zone.numPoints} points<br/>
                                <strong>Zone Size:</strong> ${zone.radius.toFixed(0)}m
                            </div>
                        </div>
                    `);
                    
                    // Add tooltip on hover
                    circle.bindTooltip(`${isLift ? 'Lift' : 'Header'}: ${zone.avgShift.toFixed(1)}¬∞`, {
                        permanent: false,
                        direction: 'top'
                    });
                });
                
                console.log(`‚úÖ Wind shift zones displayed on map`);
            }
            
            // Detect and draw wind shift zones
            const shiftZones = detectShiftZones(gpsPoints);
            drawWindShiftZones(shiftZones);
            
            // Still add individual markers for reference (but less frequently)
            gpsPoints.forEach((p, i) => {
                if (p.isLift && i % 30 === 0) {  // Sample every 30th point to avoid clutter
                    const marker = L.circleMarker([p.lat, p.lon], {
                        radius: 3,
                        fillColor: '#10B981',
                        color: '#ffffff',
                        weight: 1,
                        fillOpacity: 0.8,
                        className: 'shift-marker'
                    }).addTo(map).bindPopup(`<b>Lift</b><br/>${Math.abs(p.shiftAmount).toFixed(1)}¬∞ favorable`);
                    mapLayers.shiftMarkers.push(marker);
                } else if (p.isHeader && i % 30 === 0) {
                    const marker = L.circleMarker([p.lat, p.lon], {
                        radius: 3,
                        fillColor: '#EF4444',
                        color: '#ffffff',
                        weight: 1,
                        fillOpacity: 0.8,
                        className: 'shift-marker'
                    }).addTo(map).bindPopup(`<b>Header</b><br/>${Math.abs(p.shiftAmount).toFixed(1)}¬∞ unfavorable`);
                    mapLayers.shiftMarkers.push(marker);
                }
            });

            // Add maneuver markers
            if (analysis.maneuvers) {
                analysis.maneuvers.forEach((m) => {
                    if (m.lat && m.lon) {
                        const markerColor = m.type === 'Tack' ? '#3B82F6' : '#F59E0B';
                        const marker = L.circleMarker([m.lat, m.lon], {
                            radius: 3,
                            fillColor: '#1F2937',
                            color: markerColor,
                            weight: 1,
                            fillOpacity: 0.8,
                            className: 'maneuver-marker'
                        }).addTo(map).bindPopup(`
                            <b>${m.type} #${m.tackNumber}</b><br/>
                            Efficiency: ${m.efficiency.toFixed(0)}%<br/>
                            Entry: ${m.entrySpeed.toFixed(1)} kts<br/>
                            Exit: ${m.exitSpeed.toFixed(1)} kts<br/>
                            Loss: ${m.distanceLost.toFixed(1)}m
                        `);
                        mapLayers.maneuvers.push(marker);
                    }
                });
            }

            console.log("‚úÖ Map rendered");
        }

        function showError(message) {
            document.getElementById('mainContent').innerHTML = `
                <div class="flex items-center justify-center" style="min-height: 400px;">
                    <div class="text-center text-red-400">
                        <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                        <p class="text-xl">${message}</p>
                    </div>
                </div>
            `;
        }

        // UX Helper Functions for Status Management
        function showStatus(message, details = '') {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const progressDetails = document.getElementById('progressDetails');
            const successMsg = document.getElementById('successMessage');
            const errorDiv = document.getElementById('error');
            
            // Hide other messages
            successMsg.classList.add('hidden');
            errorDiv.classList.add('hidden');
            
            // Show status
            indicator.classList.remove('hidden');
            statusText.textContent = message;
            progressDetails.textContent = details;
            
            console.log(`üìä Status: ${message}${details ? ' - ' + details : ''}`);
        }

        function hideStatus() {
            const indicator = document.getElementById('statusIndicator');
            indicator.classList.add('hidden');
        }

        function showSuccess(message) {
            const indicator = document.getElementById('statusIndicator');
            const successMsg = document.getElementById('successMessage');
            const successText = document.getElementById('successText');
            const errorDiv = document.getElementById('error');
            
            // Hide other messages
            indicator.classList.add('hidden');
            errorDiv.classList.add('hidden');
            
            // Show success
            successMsg.classList.remove('hidden');
            successText.textContent = message;
            
            console.log(`‚úÖ ${message}`);
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                successMsg.classList.add('hidden');
            }, 5000);
        }

        function showErrorMessage(message) {
            const indicator = document.getElementById('statusIndicator');
            const successMsg = document.getElementById('successMessage');
            const errorDiv = document.getElementById('error');
            
            // Hide other messages
            indicator.classList.add('hidden');
            successMsg.classList.add('hidden');
            
            // Show error
            errorDiv.classList.remove('hidden');
            errorDiv.textContent = message;
            
            console.error(`‚ùå ${message}`);
        }

        // ====== SESSION STORAGE FUNCTIONS ======
        
        async function saveSession() {
            console.log('üíæ Saving session...');
            
            // Validate required fields
            const sessionName = document.getElementById('sessionName').value.trim();
            const sessionDate = document.getElementById('sessionDate').value;
            
            if (!sessionName) {
                alert('Please enter a session name');
                return;
            }
            
            if (!sessionDate) {
                alert('Please select a date');
                return;
            }
            
            if (!analysis) {
                alert('No analysis data to save. Please analyze a CSV file first.');
                return;
            }
            
            // Gather metadata
            const metadata = {
                name: sessionName,
                date: sessionDate,
                venue: document.getElementById('sessionVenue').value.trim(),
                windSpeed: document.getElementById('sessionWindSpeed').value.trim(),
                boat: document.getElementById('sessionBoat').value.trim() || 'Melges 15',
                notes: document.getElementById('sessionNotes').value.trim(),
                savedAt: new Date().toISOString(),
                dataPoints: analysis.dataPoints,
                races: races.length
            };
            
            // Create session ID from date and name
            const sessionId = `session_${sessionDate}_${sessionName.replace(/[^a-zA-Z0-9]/g, '_')}`;
            
            // Prepare session data (SUMMARY ONLY - no raw CSV to save space)
            const sessionData = {
                metadata,
                summary: {
                    // Core metrics
                    avgVMG: analysis.avgVMG,
                    optimalHeelUp: analysis.optimalHeelUp,
                    optimalHeelDown: analysis.optimalHeelDown,
                    tackCount: analysis.tacks.length,
                    gybeCount: analysis.gybes.length,
                    bestPointingAngle: analysis.bestPointingAngle,
                    avgLeeway: analysis.avgLeeway,
                    
                    // Additional metrics for trend analysis
                    avgSpeed: analysis.avgSpeed,
                    timeUpwind: analysis.timeUpwind,
                    timeDownwind: analysis.timeDownwind,
                    distanceSailed: analysis.distanceSailed,
                    avgTackLoss: analysis.avgTackLoss,
                    avgGybeLoss: analysis.avgGybeLoss,
                    bestVMGUpwind: analysis.bestVMGUpwind,
                    bestVMGDownwind: analysis.bestVMGDownwind,
                    
                    // Top speeds
                    maxSpeed: analysis.maxSpeed,
                    maxVMG: analysis.maxVMG
                },
                races: races.map(r => ({ start: r.start, end: r.end })), // Just times, not full data
                windDirection: windDir
            };
            
            try {
                // Save to localStorage (works everywhere)
                const dataString = JSON.stringify(sessionData);
                const sizeKB = (dataString.length / 1024).toFixed(1);
                console.log(`üíæ Session size: ${sizeKB} KB`);
                
                localStorage.setItem(sessionId, dataString);
                
                console.log('‚úÖ Session saved:', sessionId);
                
                // Show success message
                const successMsg = document.getElementById('saveSuccessMessage');
                successMsg.classList.remove('hidden');
                setTimeout(() => successMsg.classList.add('hidden'), 3000);
                
                // Clear form (optional)
                    // document.getElementById('sessionNotes').value = '';
                    
            } catch (error) {
                console.error('Error saving session:', error);
                alert('Error saving session: ' + error.message);
            }
        }
        
        async function loadSavedSessions() {
            console.log('üìÇ Loading saved sessions...');
            
            try {
                // Get all sessions from localStorage (they start with 'session_')
                const sessions = [];
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('session_')) {
                        try {
                            const sessionData = JSON.parse(localStorage.getItem(key));
                            sessions.push({
                                id: key,
                                ...sessionData.metadata,
                                summary: sessionData.summary
                            });
                        } catch (err) {
                            console.error(`Error loading session ${key}:`, err);
                        }
                    }
                }
                
                // Sort by date (newest first)
                sessions.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                console.log(`‚úÖ Loaded ${sessions.length} sessions`);
                return sessions;
                
            } catch (error) {
                console.error('Error loading sessions:', error);
                return [];
            }
        }
        
        async function loadSession(sessionId) {
            console.log('üì• Loading session:', sessionId);
            
            try {
                const sessionDataStr = localStorage.getItem(sessionId);
                
                if (!sessionDataStr) {
                    alert('Session not found');
                    return;
                }
                
                const sessionData = JSON.parse(sessionDataStr);
                
                // Show session summary in a nice format
                const metadata = sessionData.metadata;
                const summary = sessionData.summary;
                
                const summaryHTML = `
                    <div style="max-width: 800px; margin: 0 auto;">
                        <h2 style="font-size: 2rem; font-weight: bold; margin-bottom: 1.5rem;">
                            ${metadata.name}
                        </h2>
                        
                        <div style="background: rgba(30, 58, 95, 0.5); border: 2px solid #60A5FA; border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
                                <div>
                                    <div style="color: #93C5FD; font-size: 0.875rem; margin-bottom: 0.25rem;">Date</div>
                                    <div style="font-size: 1.125rem; font-weight: 600;">${new Date(metadata.date).toLocaleDateString()}</div>
                                </div>
                                ${metadata.venue ? `
                                <div>
                                    <div style="color: #93C5FD; font-size: 0.875rem; margin-bottom: 0.25rem;">Venue</div>
                                    <div style="font-size: 1.125rem; font-weight: 600;">${metadata.venue}</div>
                                </div>
                                ` : ''}
                                ${metadata.windSpeed ? `
                                <div>
                                    <div style="color: #93C5FD; font-size: 0.875rem; margin-bottom: 0.25rem;">Wind Speed</div>
                                    <div style="font-size: 1.125rem; font-weight: 600;">${metadata.windSpeed} kts</div>
                                </div>
                                ` : ''}
                                <div>
                                    <div style="color: #93C5FD; font-size: 0.875rem; margin-bottom: 0.25rem;">Boat</div>
                                    <div style="font-size: 1.125rem; font-weight: 600;">${metadata.boat}</div>
                                </div>
                            </div>
                            ${metadata.notes ? `
                                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(96, 165, 250, 0.3);">
                                    <div style="color: #93C5FD; font-size: 0.875rem; margin-bottom: 0.5rem;">Notes</div>
                                    <div style="font-size: 0.9375rem; line-height: 1.6;">${metadata.notes}</div>
                                </div>
                            ` : ''}
                        </div>
                        
                        <h3 style="font-size: 1.5rem; font-weight: bold; margin-bottom: 1rem;">Performance Summary</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Avg VMG</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.avgVMG?.toFixed(2) || 'N/A'} <span style="font-size: 1rem; color: #93C5FD;">kts</span></div>
                            </div>
                            
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Optimal Heel</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.optimalHeelUp || 'N/A'}¬∞ <span style="font-size: 1rem; color: #93C5FD;">up</span> / ${summary.optimalHeelDown || 'N/A'}¬∞ <span style="font-size: 1rem; color: #93C5FD;">dn</span></div>
                            </div>
                            
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Maneuvers</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.tackCount || 0} <span style="font-size: 1rem; color: #93C5FD;">tacks</span></div>
                                <div style="font-size: 1.25rem; font-weight: 600; color: #93C5FD;">${summary.gybeCount || 0} <span style="font-size: 0.875rem;">gybes</span></div>
                            </div>
                            
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Best Pointing</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.bestPointingAngle || 'N/A'}¬∞ <span style="font-size: 1rem; color: #93C5FD;">TWA</span></div>
                            </div>
                            
                            ${summary.avgSpeed ? `
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Avg Speed</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.avgSpeed.toFixed(2)} <span style="font-size: 1rem; color: #93C5FD;">kts</span></div>
                            </div>
                            ` : ''}
                            
                            ${summary.maxSpeed ? `
                            <div style="background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 1rem;">
                                <div style="color: #93C5FD; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">Max Speed</div>
                                <div style="font-size: 1.875rem; font-weight: bold;">${summary.maxSpeed.toFixed(2)} <span style="font-size: 1rem; color: #93C5FD;">kts</span></div>
                            </div>
                            ` : ''}
                        </div>
                        
                        <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid #60A5FA; border-radius: 8px; padding: 1rem; margin-top: 2rem;">
                            <div style="display: flex; align-items-start;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#60A5FA" stroke-width="2" style="margin-right: 0.75rem; margin-top: 0.125rem; flex-shrink: 0;">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <path d="M12 16v-4"></path>
                                    <path d="M12 8h.01"></path>
                                </svg>
                                <div style="font-size: 0.875rem; color: #93C5FD;">
                                    <strong>Note:</strong> This is a saved summary view. To see full analysis with charts and detailed metrics, re-upload the original CSV file for this session.
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Show summary in Overview tab
                const overviewTab = document.getElementById('tab-overview');
                if (overviewTab) {
                    overviewTab.innerHTML = summaryHTML;
                }
                
                // Switch to Overview tab
                switchTab('overview');
                
            } catch (error) {
                console.error('Error loading session:', error);
                alert('Error loading session: ' + error.message);
            }
        }
        
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This cannot be undone.')) {
                return;
            }
            
            try {
                localStorage.removeItem(sessionId);
                console.log('üóëÔ∏è Deleted session:', sessionId);
                
                // Reload session library
                renderSessionLibrary();
                
            } catch (error) {
                console.error('Error deleting session:', error);
                alert('Error deleting session: ' + error.message);
            }
        }
        
        async function renderSessionLibrary() {
            const sessions = await loadSavedSessions();
            const container = document.getElementById('sessionLibraryContainer');
            
            if (!container) return;
            
            if (sessions.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-12 text-gray-400">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" class="mx-auto mb-4 opacity-50">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                            <polyline points="17 21 17 13 7 13 7 21"></polyline>
                            <polyline points="7 3 7 8 15 8"></polyline>
                        </svg>
                        <p class="text-lg font-semibold mb-2">No saved sessions yet</p>
                        <p class="text-sm">Analyze a CSV file and save it to start building your session history</p>
                    </div>
                `;
                return;
            }
            
            // Render sessions
            container.innerHTML = sessions.map(session => `
                <div class="bg-gray-800 rounded-lg p-5 border border-gray-700 hover:border-blue-600 transition-all">
                    <div class="flex justify-between items-start mb-3">
                        <div class="flex-1">
                            <h3 class="text-lg font-bold text-white mb-1">${session.name}</h3>
                            <div class="text-sm text-gray-400">
                                üìÖ ${new Date(session.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                                ${session.venue ? `‚Ä¢ üìç ${session.venue}` : ''}
                            </div>
                        </div>
                        <button 
                            onclick="deleteSession('${session.id}')" 
                            class="text-red-400 hover:text-red-300 p-2"
                            title="Delete session"
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                    
                    ${session.windSpeed ? `<div class="text-sm text-gray-400 mb-2">üí® ${session.windSpeed} kts</div>` : ''}
                    ${session.notes ? `<p class="text-sm text-gray-300 mb-3 line-clamp-2">${session.notes}</p>` : ''}
                    
                    <div class="grid grid-cols-2 gap-2 mb-3 text-xs">
                        ${session.summary ? `
                            <div class="bg-gray-700 rounded p-2">
                                <div class="text-gray-400">Avg VMG</div>
                                <div class="font-semibold">${session.summary.avgVMG?.toFixed(2) || 'N/A'} kts</div>
                            </div>
                            <div class="bg-gray-700 rounded p-2">
                                <div class="text-gray-400">Maneuvers</div>
                                <div class="font-semibold">${session.summary.tackCount || 0} tacks, ${session.summary.gybeCount || 0} gybes</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    <button 
                        onclick="loadSession('${session.id}')" 
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 rounded transition-all"
                    >
                        Load Session
                    </button>
                </div>
            `).join('');
        }

        function generatePDF() {
            console.log("üìÑ PDF generation started");
            
            if (!analysis) {
                alert("No analysis data available. Please load a CSV file first.");
                console.error("‚ùå No analysis data");
                return;
            }
            
            console.log("‚úÖ Analysis data exists:", analysis);
            
            if (typeof window.jspdf === 'undefined') {
                alert("PDF library not loaded. Please refresh the page and try again.");
                console.error("‚ùå jsPDF library not available");
                return;
            }
            
            console.log("‚úÖ jsPDF library loaded");
            
            // Show loading state
            const btn = document.getElementById('generatePDF');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Generating...';
            btn.disabled = true;
            
            try {
                const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            let y = 20;
            
            // Get race date from input field
            const raceDateInput = document.getElementById('raceDate');
            const raceDate = raceDateInput && raceDateInput.value ? 
                new Date(raceDateInput.value).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) :
                'Date not specified';
            
            // TITLE PAGE WITH BRANDING - REDESIGNED
            pdf.setFillColor(15, 23, 42); // Dark blue-gray
            pdf.rect(0, 0, pageWidth, 60, 'F');
            
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(28);
            pdf.setFont(undefined, 'bold');
            pdf.text('SAILING PERFORMANCE REPORT', pageWidth / 2, 25, { align: 'center' });
            
            // Race date
            pdf.setFontSize(12);
            pdf.setFont(undefined, 'normal');
            pdf.text('Race Date: ' + raceDate, pageWidth / 2, 38, { align: 'center' });
            
            // Generated date
            pdf.setFontSize(8);
            pdf.setTextColor(180, 180, 180);
            const generatedDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            pdf.text('Report Generated: ' + generatedDate, pageWidth / 2, 50, { align: 'center' });
            
            y = 70;
            pdf.setTextColor(0, 0, 0);
            
            // PERFORMANCE METRICS - CLEAN 4-BOX GRID LAYOUT
            const boxWidth = 85;
            const boxHeight = 28;
            const gap = 5;
            const startX = 20;
            
            // Row 1: VMG Efficiency & Boat Handling Score
            let boxX = startX;
            let boxY = y;
            
            // Box 1: VMG Efficiency
            pdf.setFillColor(147, 51, 234); // Purple
            pdf.roundedRect(boxX, boxY, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.text('VMG EFFICIENCY', boxX + 4, boxY + 8);
            pdf.setFontSize(22);
            pdf.text(analysis.vmgEfficiency.toFixed(0) + '%', boxX + 4, boxY + 21);
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            pdf.text(`${analysis.avgVMG.toFixed(2)} / ${analysis.bestVMG.toFixed(2)} kts`, boxX + boxWidth - 4, boxY + 25, { align: 'right' });
            
            // Box 2: Boat Handling Score
            boxX += boxWidth + gap;
            const score = analysis.boatHandlingScore;
            const scoreColor = score >= 80 ? [16, 185, 129] : score >= 60 ? [251, 191, 36] : [239, 68, 68];
            pdf.setFillColor(...scoreColor);
            pdf.roundedRect(boxX, boxY, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.text('BOAT HANDLING', boxX + 4, boxY + 8);
            pdf.setFontSize(22);
            pdf.text(score.toFixed(0) + '/100', boxX + 4, boxY + 21);
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            const level = score >= 80 ? 'EXCELLENT' : score >= 60 ? 'GOOD' : 'NEEDS WORK';
            pdf.text(level, boxX + boxWidth - 4, boxY + 25, { align: 'right' });
            
            // Row 2: Tack Efficiency & Leeway
            boxX = startX;
            boxY += boxHeight + gap;
            
            // Box 3: Tack Efficiency
            pdf.setFillColor(234, 179, 8); // Amber
            pdf.roundedRect(boxX, boxY, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.text('TACK EFFICIENCY', boxX + 4, boxY + 8);
            pdf.setFontSize(22);
            pdf.text(analysis.tackEfficiency.toFixed(0) + '%', boxX + 4, boxY + 21);
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            pdf.text(`${analysis.tacksCount} tacks analyzed`, boxX + boxWidth - 4, boxY + 25, { align: 'right' });
            
            // Box 4: Leeway
            boxX += boxWidth + gap;
            const leewayColor = analysis.leeway < 5 ? [16, 185, 129] : analysis.leeway < 8 ? [234, 179, 8] : [239, 68, 68];
            pdf.setFillColor(...leewayColor);
            pdf.roundedRect(boxX, boxY, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'bold');
            pdf.text('LEEWAY', boxX + 4, boxY + 8);
            pdf.setFontSize(22);
            pdf.text(analysis.leeway.toFixed(1) + String.fromCharCode(176), boxX + 4, boxY + 21);
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            const leewayLabel = analysis.leeway < 5 ? 'Excellent' : analysis.leeway < 8 ? 'Good' : 'High';
            pdf.text(leewayLabel, boxX + boxWidth - 4, boxY + 25, { align: 'right' });
            
            y = boxY + boxHeight + 15;
            pdf.setTextColor(0, 0, 0);
            
            // KEY INSIGHTS BOX - NO EMOJIS!
            pdf.setFontSize(12);
            pdf.setFont(undefined, 'bold');
            pdf.text('KEY INSIGHTS', 20, y);
            y += 2;
            pdf.setLineWidth(0.5);
            pdf.setDrawColor(59, 130, 246);
            pdf.line(20, y, 60, y);
            y += 6;
            
            // Generate insights based on data - TEXT ONLY
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            const insights = [];
            
            if (analysis.tackEfficiency >= 85) {
                insights.push('Excellent tack execution - maintaining ' + analysis.tackEfficiency.toFixed(0) + '% speed through maneuvers');
            } else if (analysis.tackEfficiency < 75) {
                insights.push('Tack efficiency at ' + analysis.tackEfficiency.toFixed(0) + '% - focus on smooth helm and timing');
            }
            
            if (analysis.leeway < 5) {
                insights.push('Minimal leeway (' + analysis.leeway.toFixed(1) + String.fromCharCode(176) + ') - excellent boat setup');
            } else if (analysis.leeway > 8) {
                insights.push('High leeway (' + analysis.leeway.toFixed(1) + String.fromCharCode(176) + ') - check heel angle and centerboard');
            }
            
            if (analysis.vmgEfficiency >= 85) {
                insights.push('Consistent VMG performance - sailing at ' + analysis.vmgEfficiency.toFixed(0) + '% of your potential');
            } else if (analysis.vmgEfficiency < 75) {
                insights.push('VMG varies significantly - focus on maintaining optimal angles');
            }
            
            if (analysis.bestPointing < 33) {
                insights.push('Strong pointing ability - ' + analysis.bestPointing.toFixed(1) + String.fromCharCode(176) + ' TWA is competitive');
            }
            
            // Display insights with bullets
            insights.forEach(insight => {
                const lines = pdf.splitTextToSize('- ' + insight, 165);
                lines.forEach(line => {
                    pdf.text(line, 22, y);
                    y += 4;
                });
            });
            
            y += 8;
            
            // QUICK STATS TABLE (Still on page 1!)
            pdf.setFontSize(12);
            pdf.setFont(undefined, 'bold');
            pdf.text('QUICK STATS', 20, y);
            y += 2;
            pdf.setLineWidth(0.5);
            pdf.setDrawColor(59, 130, 246);
            pdf.line(20, y, 60, y);
            y += 8;
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            
            const quickStats = [
                ['Optimal Heel:', analysis.optimalHeelUp + String.fromCharCode(176), 'Best Pointing:', analysis.bestPointing.toFixed(1) + String.fromCharCode(176)],
                ['Optimal Trim:', (analysis.optimalTrimUp > 0 ? '+' : '') + analysis.optimalTrimUp + String.fromCharCode(176), 'Time in Zone:', analysis.timeInZone.toFixed(0) + '%'],
                ['Avg Speed Up:', analysis.avgUpwindSpeed.toFixed(1) + ' kts', 'Avg Speed Down:', analysis.avgDownwindSpeed.toFixed(1) + ' kts'],
                ['Distance Eff:', analysis.distanceEfficiency.toFixed(0) + '%', 'Speed Ratio:', analysis.speedRatio.toFixed(2) + 'x']
            ];
            
            quickStats.forEach(row => {
                pdf.setFont(undefined, 'bold');
                pdf.text(row[0], 22, y);
                pdf.setFont(undefined, 'normal');
                pdf.text(row[1], 52, y);
                pdf.setFont(undefined, 'bold');
                pdf.text(row[2], 105, y);
                pdf.setFont(undefined, 'normal');
                pdf.text(row[3], 140, y);
                y += 5;
            });
            
            // Add page break before next section
            pdf.addPage();
            y = 20;
            
            // PAGE 2: DETAILED METRICS
            pdf.setFontSize(16);
            pdf.setFont(undefined, 'bold');
            pdf.text('DETAILED PERFORMANCE METRICS', 20, y);
            y += 2;
            pdf.setLineWidth(0.5);
            pdf.setDrawColor(59, 130, 246);
            pdf.line(20, y, 100, y);
            y += 10;
            
            // PERFORMANCE METRICS TABLE
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            
            const metrics = [
                ['Metric', 'Upwind', 'Downwind', 'Assessment'],
                ['Optimal Heel Angle', `${analysis.optimalHeelUp}¬∞`, `${analysis.optimalHeelDown}¬∞`, analysis.heelDataQuality.reliable ? '‚úì Reliable' : '‚ö† Limited Data'],
                ['Optimal Trim', `${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞`, `${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞`, ''],
                ['Average Speed', `${analysis.avgUpwindSpeed.toFixed(1)} kts`, `${analysis.avgDownwindSpeed.toFixed(1)} kts`, ''],
                ['Speed Ratio', '-', `${analysis.speedRatio.toFixed(2)}x`, analysis.speedRatio > 1.3 ? 'Good' : 'Fair'],
                ['Best Pointing', `${analysis.bestPointing.toFixed(1)}¬∞`, '-', analysis.bestPointing < 35 ? 'Excellent' : 'Good'],
                ['Average Leeway', `${analysis.leeway.toFixed(1)}¬∞`, '-', analysis.leeway < 8 ? 'Good' : '‚ö† High'],
                ['Distance Efficiency', '-', '-', `${analysis.distanceEfficiency.toFixed(0)}%`],
            ];
            
            const colWidths = [60, 30, 30, 40];
            const rowHeight = 6;
            
            metrics.forEach((row, idx) => {
                let x = 20;
                
                if (idx === 0) {
                    // Header row
                    pdf.setFont(undefined, 'bold');
                    pdf.setFillColor(241, 245, 249);
                    pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight, 'F');
                    pdf.setDrawColor(203, 213, 225);
                    pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight);
                } else {
                    pdf.setFont(undefined, 'normal');
                    if (idx % 2 === 0) {
                        pdf.setFillColor(249, 250, 251);
                        pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight, 'F');
                    }
                }
                
                row.forEach((cell, colIdx) => {
                    pdf.text(cell, x + 2, y);
                    x += colWidths[colIdx];
                });
                
                y += rowHeight;
            });
            
            y += 10;
            
            // VISUAL: GPS Track Representation
            if (y > 220) {
                pdf.addPage();
                y = 20;
            }
            
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('GPS Track Overview', 20, y);
            y += 8;
            
            // Simple track visualization
            const trackData = analysis.trackData.filter(d => d.lat && d.lon);
            if (trackData.length > 100) {
                const lats = trackData.map(d => d.latitude || d.lat);
                const lons = trackData.map(d => d.longitude || d.lon);
                const minLat = Math.min(...lats);
                const maxLat = Math.max(...lats);
                const minLon = Math.min(...lons);
                const maxLon = Math.max(...lons);
                
                // Scale to fit in 160x80mm box
                const boxWidth = 160;
                const boxHeight = 80;
                const startX = 25;
                const startY = y + 5;
                
                // Draw background
                pdf.setFillColor(240, 245, 250);
                pdf.rect(startX, startY, boxWidth, boxHeight, 'F');
                
                // Draw track
                const sample = Math.max(1, Math.floor(trackData.length / 300)); // Sample points
                pdf.setDrawColor(59, 130, 246);
                pdf.setLineWidth(0.3);
                
                for (let i = 0; i < trackData.length - sample; i += sample) {
                    const d1 = trackData[i];
                    const d2 = trackData[i + sample];
                    
                    const x1 = startX + ((d1.longitude || d1.lon) - minLon) / (maxLon - minLon) * boxWidth;
                    const y1 = startY + boxHeight - ((d1.latitude || d1.lat) - minLat) / (maxLat - minLat) * boxHeight;
                    const x2 = startX + ((d2.longitude || d2.lon) - minLon) / (maxLon - minLon) * boxWidth;
                    const y2 = startY + boxHeight - ((d2.latitude || d2.lat) - minLat) / (maxLat - minLat) * boxHeight;
                    
                    // Color by VMG
                    const vmg = Math.abs(d1.vmg || 0);
                    if (vmg > 4) {
                        pdf.setDrawColor(16, 185, 129); // Green
                    } else if (vmg > 3) {
                        pdf.setDrawColor(59, 130, 246); // Blue
                    } else if (vmg > 2) {
                        pdf.setDrawColor(251, 191, 36); // Yellow
                    } else {
                        pdf.setDrawColor(239, 68, 68); // Red
                    }
                    
                    pdf.line(x1, y1, x2, y2);
                }
                
                // Draw maneuver markers
                if (analysis.maneuvers) {
                    analysis.maneuvers.forEach(m => {
                        if (m.lat && m.lon) {
                            const mx = startX + (m.lon - minLon) / (maxLon - minLon) * boxWidth;
                            const my = startY + boxHeight - (m.lat - minLat) / (maxLat - minLat) * boxHeight;
                            const markerColor = m.type === 'Tack' ? [59, 130, 246] : [251, 146, 60];
                            pdf.setFillColor(...markerColor);
                            pdf.circle(mx, my, 1, 'F');
                        }
                    });
                }
                
                // Legend
                y = startY + boxHeight + 8;
                pdf.setFontSize(7);
                pdf.setTextColor(0, 0, 0);
                pdf.text('Track colored by VMG:', startX, y);
                pdf.setFillColor(16, 185, 129);
                pdf.circle(startX + 35, y - 1, 1, 'F');
                pdf.text('Excellent', startX + 37, y);
                pdf.setFillColor(59, 130, 246);
                pdf.circle(startX + 55, y - 1, 1, 'F');
                pdf.text('Good', startX + 57, y);
                pdf.setFillColor(251, 191, 36);
                pdf.circle(startX + 70, y - 1, 1, 'F');
                pdf.text('Moderate', startX + 72, y);
                pdf.setFillColor(239, 68, 68);
                pdf.circle(startX + 90, y - 1, 1, 'F');
                pdf.text('Poor', startX + 92, y);
                
                y += 8;
            }
            
            // VISUAL: Simple Performance Charts
            if (y > 220) {
                pdf.addPage();
                y = 20;
            }
            
            y += 5;
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('Performance Charts', 20, y);
            y += 10;
            
            // Maneuver efficiency comparison (simple bar chart)
            if (analysis.tacks.length > 0 || analysis.gybes.length > 0) {
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('Tack vs Gybe Efficiency', 20, y);
                y += 8;
                
                const barWidth = 60;
                const barHeight = 30;
                const maxEff = 100;
                
                // Tack bar
                pdf.setFillColor(59, 130, 246);
                const tackBarHeight = (analysis.tackEfficiency / maxEff) * barHeight;
                pdf.rect(25, y + barHeight - tackBarHeight, barWidth, tackBarHeight, 'F');
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text(`Tacks: ${analysis.tackEfficiency.toFixed(0)}%`, 27, y + barHeight + 5);
                
                // Gybe bar
                pdf.setFillColor(251, 146, 60);
                const gybeBarHeight = (analysis.gybeEfficiency / maxEff) * barHeight;
                pdf.rect(100, y + barHeight - gybeBarHeight, barWidth, gybeBarHeight, 'F');
                pdf.text(`Gybes: ${analysis.gybeEfficiency.toFixed(0)}%`, 102, y + barHeight + 5);
                
                // Axis
                pdf.setDrawColor(100, 100, 100);
                pdf.setLineWidth(0.5);
                pdf.line(25, y + barHeight, 165, y + barHeight);
                
                y += barHeight + 15;
            }
            
            // VMG Distribution (simple bar chart)
            y += 5;
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Speed Distribution', 20, y);
            y += 8;
            
            const speedBins = [
                { range: '0-3', upwind: 0, downwind: 0 },
                { range: '3-5', upwind: 0, downwind: 0 },
                { range: '5-7', upwind: 0, downwind: 0 },
                { range: '7+', upwind: 0, downwind: 0 }
            ];
            
            analysis.trackData.forEach(d => {
                const s = d.speed || 0;
                const binIdx = s < 3 ? 0 : s < 5 ? 1 : s < 7 ? 2 : 3;
                if (d.isUpwind) {
                    speedBins[binIdx].upwind++;
                } else {
                    speedBins[binIdx].downwind++;
                }
            });
            
            const maxCount = Math.max(...speedBins.flatMap(b => [b.upwind, b.downwind]));
            const chartWidth = 140;
            const chartHeight = 35;
            const barSpacing = 4;
            const groupWidth = chartWidth / speedBins.length;
            
            speedBins.forEach((bin, idx) => {
                const x = 25 + idx * groupWidth;
                
                // Upwind bar
                pdf.setFillColor(16, 185, 129);
                const upwindHeight = (bin.upwind / maxCount) * chartHeight;
                pdf.rect(x, y + chartHeight - upwindHeight, (groupWidth - barSpacing) / 2, upwindHeight, 'F');
                
                // Downwind bar
                pdf.setFillColor(59, 130, 246);
                const downwindHeight = (bin.downwind / maxCount) * chartHeight;
                pdf.rect(x + (groupWidth - barSpacing) / 2, y + chartHeight - downwindHeight, (groupWidth - barSpacing) / 2, downwindHeight, 'F');
                
                // Label
                pdf.setFontSize(7);
                pdf.setTextColor(0, 0, 0);
                pdf.text(bin.range, x + groupWidth / 2 - 3, y + chartHeight + 4);
            });
            
            // Legend
            pdf.setFillColor(16, 185, 129);
            pdf.rect(25, y + chartHeight + 8, 3, 3, 'F');
            pdf.setFontSize(7);
            pdf.text('Upwind', 30, y + chartHeight + 10);
            pdf.setFillColor(59, 130, 246);
            pdf.rect(50, y + chartHeight + 8, 3, 3, 'F');
            pdf.text('Downwind', 55, y + chartHeight + 10);
            
            y += chartHeight + 18;
            
            // COACHING RECOMMENDATIONS
            if (analysis.coachingTips && analysis.coachingTips.length > 0) {
                if (y > 220) {
                    pdf.addPage();
                    y = 20;
                }
                
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Coaching Recommendations', 20, y);
                y += 2;
                pdf.setLineWidth(0.5);
                pdf.setDrawColor(34, 197, 94);
                pdf.line(20, y, 95, y);
                y += 10;
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                
                analysis.coachingTips.forEach((tip, i) => {
                    if (y > 260) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    // Priority badge
                    const badgeColor = tip.priority === 'high' ? [239, 68, 68] : [251, 191, 36];
                    pdf.setFillColor(...badgeColor);
                    pdf.roundedRect(20, y - 3, 18, 5, 1, 1, 'F');
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFontSize(7);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(tip.priority.toUpperCase(), 22, y);
                    
                    // Tip content
                    pdf.setTextColor(0, 0, 0);
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${i + 1}. ${tip.category}`, 41, y);
                    y += 6;
                    
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    const messageLines = pdf.splitTextToSize(tip.message, 165);
                    pdf.text(messageLines, 23, y);
                    y += messageLines.length * 4.5;
                    
                    pdf.setFillColor(240, 253, 244);
                    pdf.roundedRect(23, y, 165, 7, 1, 1, 'F');
                    pdf.setTextColor(22, 163, 74);
                    pdf.setFontSize(8);
                    pdf.text(`‚ö° Potential Performance Gain: ${tip.impact}`, 26, y + 4.5);
                    pdf.setTextColor(0, 0, 0);
                    y += 10;
                });
            }
            
            // WIND & TACTICAL ANALYSIS
            if (y > 200) {
                pdf.addPage();
                y = 20;
            }
            
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('Wind & Tactical Analysis', 20, y);
            y += 2;
            pdf.setDrawColor(234, 179, 8);
            pdf.line(20, y, 85, y);
            y += 10;
            
            // Predominant Headings Box
            pdf.setFillColor(254, 252, 232);
            pdf.setDrawColor(234, 179, 8);
            pdf.setLineWidth(1);
            pdf.roundedRect(20, y, 170, 35, 2, 2, 'FD');
            
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('üß≠ Auto-Detected Wind Direction', 25, y + 7);
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Starboard Tack Heading:`, 25, y + 14);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${analysis.predominantHeadings.peak1}¬∞`, 70, y + 14);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(${analysis.predominantHeadings.peak1Count} samples)`, 85, y + 14);
            
            pdf.text(`Port Tack Heading:`, 25, y + 20);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${analysis.predominantHeadings.peak2}¬∞`, 70, y + 20);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(${analysis.predominantHeadings.peak2Count} samples)`, 85, y + 20);
            
            pdf.setFillColor(37, 99, 235);
            pdf.roundedRect(25, y + 24, 70, 7, 1, 1, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFont(undefined, 'bold');
            pdf.text(`Estimated Wind: ${analysis.predominantHeadings.estimatedWindDir.toFixed(0)}¬∞`, 28, y + 29);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(Avg TWA: ${analysis.predominantHeadings.avgTWA.toFixed(0)}¬∞)`, 75, y + 29);
            
            pdf.setTextColor(0, 0, 0);
            y += 42;
            
            // Wind Shift Statistics
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Wind Shift Performance:', 20, y);
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(9);
            y += 6;
            
            const liftColor = analysis.windAnalysis.liftPct > 45 ? [22, 163, 74] : [234, 179, 8];
            pdf.setTextColor(...liftColor);
            pdf.text(`‚Ä¢ Sailing on Lifts: ${analysis.windAnalysis.liftPct.toFixed(1)}%`, 23, y);
            pdf.setTextColor(0, 0, 0);
            pdf.text(`(avg ${analysis.windAnalysis.avgLiftAngle.toFixed(1)}¬∞ benefit)`, 70, y);
            y += 5;
            
            pdf.setTextColor(239, 68, 68);
            pdf.text(`‚Ä¢ Sailing on Headers: ${analysis.windAnalysis.headerPct.toFixed(1)}%`, 23, y);
            pdf.setTextColor(0, 0, 0);
            pdf.text(`(avg ${analysis.windAnalysis.avgHeaderAngle.toFixed(1)}¬∞ penalty)`, 70, y);
            y += 8;
            
            // Course Bias
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Course Balance:', 20, y);
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(9);
            y += 6;
            
            pdf.text(`‚Ä¢ Port Tack: ${analysis.courseBias.portPct.toFixed(1)}%`, 23, y);
            y += 5;
            pdf.text(`‚Ä¢ Starboard Tack: ${analysis.courseBias.starboardPct.toFixed(1)}%`, 23, y);
            y += 6;
            
            const biasDiff = Math.abs(analysis.courseBias.portPct - 50);
            if (biasDiff > 20) {
                pdf.setFillColor(254, 243, 199);
                pdf.roundedRect(23, y, 165, 8, 1, 1, 'F');
                pdf.setTextColor(180, 83, 9);
                pdf.text(`‚ö† Significant ${biasDiff.toFixed(0)}% bias toward ${analysis.courseBias.portPct > 50 ? 'port' : 'starboard'} - verify if this matches favored side`, 26, y + 5);
                pdf.setTextColor(0, 0, 0);
                y += 10;
            } else {
                pdf.setTextColor(22, 163, 74);
                pdf.text('‚úì Well-balanced course - good tactical execution', 23, y);
                pdf.setTextColor(0, 0, 0);
                y += 7;
            }
            
            // MANEUVER ANALYSIS
            if (analysis.maneuvers && analysis.maneuvers.length > 0) {
                if (y > 200) {
                    pdf.addPage();
                    y = 20;
                }
                
                y += 5;
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Maneuver Analysis', 20, y);
                y += 2;
                pdf.setDrawColor(239, 68, 68);
                pdf.line(20, y, 70, y);
                y += 10;
                
                // Summary boxes
                const boxHeight = 20;
                const boxWidth = 80;
                
                // Tacks box
                if (analysis.tacks.length > 0) {
                    pdf.setFillColor(59, 130, 246);
                    pdf.roundedRect(20, y, boxWidth, boxHeight, 2, 2, 'F');
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFontSize(8);
                    pdf.text('TACKS', 25, y + 6);
                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${analysis.tacks.length}`, 25, y + 14);
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    pdf.text(`Avg: ${analysis.tackEfficiency.toFixed(0)}%`, 45, y + 14);
                    
                    // Gybes box
                    pdf.setFillColor(251, 146, 60);
                    pdf.roundedRect(20 + boxWidth + 5, y, boxWidth, boxHeight, 2, 2, 'F');
                    pdf.setFontSize(8);
                    pdf.text('GYBES', 30 + boxWidth, y + 6);
                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${analysis.gybes.length}`, 30 + boxWidth, y + 14);
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    pdf.text(`Avg: ${analysis.gybeEfficiency.toFixed(0)}%`, 50 + boxWidth, y + 14);
                    
                    y += boxHeight + 10;
                    pdf.setTextColor(0, 0, 0);
                    
                    // Key insights box
                    pdf.setFillColor(241, 245, 249);
                    pdf.roundedRect(20, y, 170, 25, 2, 2, 'F');
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'bold');
                    pdf.text('üìä Performance Insights:', 25, y + 6);
                    pdf.setFont(undefined, 'normal');
                    pdf.setFontSize(8);
                    pdf.text(`‚Ä¢ Entry/Exit scatter plots show direct speed retention through maneuvers`, 25, y + 12);
                    pdf.text(`‚Ä¢ Green dots = minimal distance lost, Red dots = significant loss`, 25, y + 17);
                    pdf.text(`‚Ä¢ View interactive charts in web app for detailed analysis of each maneuver`, 25, y + 22);
                    
                    y += 30;
                }
                
                // Top performers
                const sortedTacks = [...analysis.tacks].sort((a, b) => b.efficiency - a.efficiency);
                const sortedGybes = [...analysis.gybes].sort((a, b) => b.efficiency - a.efficiency);
                
                if (sortedTacks.length > 0) {
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(59, 130, 246);
                    pdf.text('Top 3 Tacks:', 20, y);
                    pdf.setTextColor(0, 0, 0);
                    y += 6;
                    
                    pdf.setFontSize(8);
                    pdf.setFont(undefined, 'normal');
                    sortedTacks.slice(0, 3).forEach((m, i) => {
                        const effColor = m.efficiency >= 90 ? [22, 163, 74] : [234, 179, 8];
                        pdf.setTextColor(...effColor);
                        pdf.text(`T${m.tackNumber}`, 23, y);
                        pdf.setTextColor(0, 0, 0);
                        pdf.text(`${m.efficiency.toFixed(0)}%  ${m.entrySpeed.toFixed(1)}‚Üí${m.exitSpeed.toFixed(1)} kts  -${m.distanceLost.toFixed(0)}m`, 33, y);
                        y += 4;
                    });
                    y += 4;
                }
                
                if (sortedGybes.length > 0) {
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(251, 146, 60);
                    pdf.text('Top 3 Gybes:', 20, y);
                    pdf.setTextColor(0, 0, 0);
                    y += 6;
                    
                    pdf.setFontSize(8);
                    pdf.setFont(undefined, 'normal');
                    sortedGybes.slice(0, 3).forEach((m, i) => {
                        const effColor = m.efficiency >= 90 ? [22, 163, 74] : [234, 179, 8];
                        pdf.setTextColor(...effColor);
                        pdf.text(`G${m.tackNumber}`, 23, y);
                        pdf.setTextColor(0, 0, 0);
                        pdf.text(`${m.efficiency.toFixed(0)}%  ${m.entrySpeed.toFixed(1)}‚Üí${m.exitSpeed.toFixed(1)} kts  -${m.distanceLost.toFixed(0)}m`, 33, y);
                        y += 4;
                    });
                }
            }
            
            // DATA QUALITY & DISCLAIMERS
            if (!analysis.heelDataQuality.reliable) {
                if (y > 230) {
                    pdf.addPage();
                    y = 20;
                }
                
                y += 10;
                pdf.setFillColor(254, 243, 199);
                pdf.setDrawColor(234, 179, 8);
                pdf.setLineWidth(1);
                pdf.roundedRect(20, y, 170, 30, 2, 2, 'FD');
                pdf.setTextColor(180, 83, 9);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('‚ö† Data Quality Notice', 25, y + 7);
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                const warningLines = pdf.splitTextToSize(
                    `This analysis is based on ${analysis.heelDataQuality.upwindSamples} upwind data points. For statistically reliable heel angle optimization, we recommend at least 500 data points. The reported optimal heel angle of ${analysis.optimalHeelUp}¬∞ should be validated with additional sailing sessions. Consider using the "All Races" view to combine multiple sessions for more reliable results.`,
                    160
                );
                pdf.text(warningLines, 25, y + 14);
                pdf.setTextColor(0, 0, 0);
                y += 33;
            }
            
            // ============================================================
            // WIND SHIFT ANALYSIS PAGE
            // ============================================================
            if (analysis.trackData && analysis.trackData.some(p => p.isLift || p.isHeader)) {
                if (y > 200) {
                    pdf.addPage();
                    y = 20;
                } else {
                    y += 15;
                }
                
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('WIND SHIFT ANALYSIS', 20, y);
                y += 2;
                pdf.setLineWidth(0.5);
                pdf.setDrawColor(59, 130, 246);
                pdf.line(20, y, 85, y);
                y += 10;
                
                // Count SHIFT ZONES (not individual points)
                // Group consecutive lift/header points into zones
                const zones = [];
                let currentZone = null;
                
                analysis.trackData.forEach((p, i) => {
                    const hasShift = p.isLift || p.isHeader;
                    const shiftType = p.isLift ? 'lift' : (p.isHeader ? 'header' : null);
                    
                    if (hasShift) {
                        if (!currentZone || currentZone.type !== shiftType) {
                            // Save previous zone if it exists and has enough points
                            if (currentZone && currentZone.points.length >= 3) {
                                zones.push(currentZone);
                            }
                            // Start new zone
                            currentZone = {
                                type: shiftType,
                                points: [p],
                                shifts: [p.shiftAmount]
                            };
                        } else {
                            // Continue existing zone
                            currentZone.points.push(p);
                            currentZone.shifts.push(p.shiftAmount);
                        }
                    } else {
                        // No shift - close current zone if exists
                        if (currentZone && currentZone.points.length >= 3) {
                            zones.push(currentZone);
                        }
                        currentZone = null;
                    }
                });
                
                // Don't forget last zone
                if (currentZone && currentZone.points.length >= 3) {
                    zones.push(currentZone);
                }
                
                const liftZones = zones.filter(z => z.type === 'lift');
                const headerZones = zones.filter(z => z.type === 'header');
                
                const avgLiftMagnitude = liftZones.length > 0 ? 
                    liftZones.reduce((sum, z) => {
                        const zoneAvg = z.shifts.reduce((a, b) => a + Math.abs(b || 0), 0) / z.shifts.length;
                        return sum + zoneAvg;
                    }, 0) / liftZones.length : 0;
                    
                const avgHeaderMagnitude = headerZones.length > 0 ?
                    headerZones.reduce((sum, z) => {
                        const zoneAvg = z.shifts.reduce((a, b) => a + Math.abs(b || 0), 0) / z.shifts.length;
                        return sum + zoneAvg;
                    }, 0) / headerZones.length : 0;
                
                // Wind shift summary boxes
                const boxWidth = 75;
                const boxHeight = 25;
                
                // Lifts box
                pdf.setFillColor(16, 185, 129); // Green
                pdf.roundedRect(20, y, boxWidth, boxHeight, 2, 2, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('LIFTS DETECTED', 23, y + 7);
                pdf.setFontSize(20);
                pdf.text(liftZones.length.toString(), 23, y + 18);
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text('Avg: ' + avgLiftMagnitude.toFixed(1) + String.fromCharCode(176), 45, y + 19);
                
                // Headers box
                pdf.setFillColor(239, 68, 68); // Red
                pdf.roundedRect(105, y, boxWidth, boxHeight, 2, 2, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('HEADERS DETECTED', 108, y + 7);
                pdf.setFontSize(20);
                pdf.text(headerZones.length.toString(), 108, y + 18);
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text('Avg: ' + avgHeaderMagnitude.toFixed(1) + String.fromCharCode(176), 130, y + 19);
                
                y += boxHeight + 10;
                pdf.setTextColor(0, 0, 0);
                
                // Tactical insights
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('Tactical Insights:', 20, y);
                y += 6;
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                
                const shiftInsights = [];
                
                // Shift pattern analysis
                if (liftZones.length > headerZones.length * 1.5) {
                    shiftInsights.push('- Predominantly lifted throughout race - wind shifted in your favor');
                } else if (headerZones.length > liftZones.length * 1.5) {
                    shiftInsights.push('- Predominantly headed - wind shifted against you');
                } else {
                    shiftInsights.push('- Balanced mix of lifts and headers - oscillating wind pattern');
                }
                
                // Magnitude analysis
                if (avgLiftMagnitude > 8 || avgHeaderMagnitude > 8) {
                    shiftInsights.push('- Large shift magnitudes (' + Math.max(avgLiftMagnitude, avgHeaderMagnitude).toFixed(1) + String.fromCharCode(176) + ') - significant wind changes');
                    shiftInsights.push('- Consider tacking on headers and extending on lifts');
                } else {
                    shiftInsights.push('- Moderate shifts - steady breeze with minor oscillations');
                }
                
                // Tack on header analysis
                if (analysis.tackTiming && analysis.tackTiming.onHeaders > analysis.tackTiming.onLifts * 1.5) {
                    shiftInsights.push('- Good tactical awareness - ' + ((analysis.tackTiming.onHeaders / analysis.tacksCount) * 100).toFixed(0) + '% of tacks on headers');
                } else if (analysis.tackTiming && analysis.tackTiming.onLifts > analysis.tackTiming.onHeaders) {
                    shiftInsights.push('- Opportunity: More tacks on lifts than headers - consider tacking on headers');
                }
                
                shiftInsights.forEach(insight => {
                    const lines = pdf.splitTextToSize(insight, 165);
                    lines.forEach(line => {
                        pdf.text(line, 22, y);
                        y += 4.5;
                    });
                });
            }
            
            // ============================================================
            // LAYLINES & MARK STRATEGY (if marks were placed)
            // ============================================================
            if ((analysis.laylines || analysis.downwindLaylines) && y < 220) {
                y += 15;
                
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('LAYLINES & MARK STRATEGY', 20, y);
                y += 2;
                pdf.setLineWidth(0.5);
                pdf.setDrawColor(59, 130, 246);
                pdf.line(20, y, 95, y);
                y += 10;
                
                if (analysis.laylines) {
                    pdf.setFontSize(12);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(16, 185, 129);
                    pdf.text('UPWIND LAYLINES', 20, y);
                    y += 6;
                    pdf.setTextColor(0, 0, 0);
                    
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    
                    const upwindData = [
                        'Pointing Angle: ' + analysis.laylines.pointingAngle + String.fromCharCode(176) + ' TWA',
                        'Wind Direction: ' + analysis.laylines.windDirection.toFixed(0) + String.fromCharCode(176),
                        'Port Layline: ' + analysis.laylines.portTackHeading.toFixed(0) + String.fromCharCode(176) + ' (RED line)',
                        'Starboard Layline: ' + analysis.laylines.starboardTackHeading.toFixed(0) + String.fromCharCode(176) + ' (GREEN line)'
                    ];
                    
                    upwindData.forEach(line => {
                        pdf.text('  - ' + line, 22, y);
                        y += 5;
                    });
                    
                    y += 3;
                }
                
                if (analysis.downwindLaylines) {
                    pdf.setFontSize(12);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(251, 146, 60);
                    pdf.text('DOWNWIND LAYLINES', 20, y);
                    y += 6;
                    pdf.setTextColor(0, 0, 0);
                    
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    
                    const downwindData = [
                        'Reaching Angle: ' + analysis.downwindLaylines.reachingAngle + String.fromCharCode(176) + ' TWA (asymmetric)',
                        'Wind Direction: ' + analysis.downwindLaylines.windDirection.toFixed(0) + String.fromCharCode(176),
                        'Port Gybe Layline: ' + analysis.downwindLaylines.portGybeHeading.toFixed(0) + String.fromCharCode(176) + ' (ORANGE line)',
                        'Starboard Gybe Layline: ' + analysis.downwindLaylines.starboardGybeHeading.toFixed(0) + String.fromCharCode(176) + ' (PURPLE line)'
                    ];
                    
                    downwindData.forEach(line => {
                        pdf.text('  - ' + line, 22, y);
                        y += 5;
                    });
                    
                    y += 3;
                    
                    // Strategy tip
                    pdf.setFontSize(8);
                    pdf.setTextColor(100, 100, 100);
                    const strategyText = 'Strategy: Cross the layline -> gybe immediately to minimize distance to mark. Your optimal reaching angle of ' + analysis.downwindLaylines.reachingAngle + String.fromCharCode(176) + ' was detected from your actual sailing data.';
                    const strategyLines = pdf.splitTextToSize(strategyText, 165);
                    strategyLines.forEach(line => {
                        pdf.text(line, 22, y);
                        y += 4;
                    });
                    pdf.setTextColor(0, 0, 0);
                }
            }
            
            // ============================================================
            // PERFORMANCE POLAR DIAGRAM PAGE
            // ============================================================
            if (analysis.optimalAngles) {
                pdf.addPage();
                y = 20;
                
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('PERFORMANCE POLAR DIAGRAM', 20, y);
                y += 2;
                pdf.setLineWidth(0.5);
                pdf.setDrawColor(59, 130, 246);
                pdf.line(20, y, 100, y);
                y += 10;
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(80, 80, 80);
                pdf.text('Speed vs True Wind Angle (TWA) - Data from your actual sailing performance', 20, y);
                y += 10;
                pdf.setTextColor(0, 0, 0);
                
                // Optimal angle boxes
                const boxWidth = 82;
                const boxHeight = 30;
                const gap = 6;
                
                // Upwind VMG angle
                pdf.setFillColor(239, 68, 68); // Red
                pdf.roundedRect(20, y, boxWidth, boxHeight, 2, 2, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('OPTIMAL UPWIND VMG', 23, y + 7);
                pdf.setFontSize(18);
                pdf.text(analysis.optimalAngles.upwind.angle + String.fromCharCode(176) + ' TWA', 23, y + 18);
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text('Speed: ' + analysis.optimalAngles.upwind.speed.toFixed(2) + ' kts', 23, y + 25);
                pdf.text('VMG: ' + analysis.optimalAngles.upwind.vmg.toFixed(2) + ' kts', 60, y + 25);
                
                // Downwind VMG angle
                pdf.setFillColor(59, 130, 246); // Blue
                pdf.roundedRect(20 + boxWidth + gap, y, boxWidth, boxHeight, 2, 2, 'F');
                pdf.setTextColor(255, 255, 255);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('OPTIMAL DOWNWIND VMG', 23 + boxWidth + gap, y + 7);
                pdf.setFontSize(18);
                pdf.text(analysis.optimalAngles.downwind.angle + String.fromCharCode(176) + ' TWA', 23 + boxWidth + gap, y + 18);
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text('Speed: ' + analysis.optimalAngles.downwind.speed.toFixed(2) + ' kts', 23 + boxWidth + gap, y + 25);
                pdf.text('VMG: ' + analysis.optimalAngles.downwind.vmg.toFixed(2) + ' kts', 60 + boxWidth + gap, y + 25);
                
                y += boxHeight + 12;
                pdf.setTextColor(0, 0, 0);
                
                // Performance data table
                pdf.setFontSize(11);
                pdf.setFont(undefined, 'bold');
                pdf.text('Speed Targets by Angle:', 20, y);
                y += 7;
                
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(100, 100, 100);
                pdf.text('TWA', 25, y);
                pdf.text('Target', 50, y);
                pdf.text('Average', 75, y);
                pdf.text('Points', 105, y);
                pdf.text('TWA', 135, y);
                pdf.text('Target', 160, y);
                pdf.text('Average', 185, y, { align: 'right' });
                
                y += 5;
                pdf.setLineWidth(0.3);
                pdf.setDrawColor(200, 200, 200);
                pdf.line(20, y, 190, y);
                y += 4;
                
                // Split polar data into two columns for better space usage
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0, 0, 0);
                
                const halfLength = Math.ceil(analysis.polar.length / 2);
                for (let i = 0; i < halfLength; i++) {
                    const left = analysis.polar[i];
                    const right = analysis.polar[i + halfLength];
                    
                    // Left column
                    pdf.text(left.twa + String.fromCharCode(176), 25, y);
                    pdf.text(left.target.toFixed(2), 50, y);
                    pdf.text(left.avg.toFixed(2), 75, y);
                    pdf.text(left.count.toString(), 105, y);
                    
                    // Right column (if exists)
                    if (right) {
                        pdf.text(right.twa + String.fromCharCode(176), 135, y);
                        pdf.text(right.target.toFixed(2), 160, y);
                        pdf.text(right.avg.toFixed(2), 185, y, { align: 'right' });
                    }
                    
                    y += 4.5;
                    
                    // Page break if needed
                    if (y > 260) {
                        pdf.addPage();
                        y = 20;
                        
                        // Continue table headers
                        pdf.setFontSize(8);
                        pdf.setFont(undefined, 'bold');
                        pdf.setTextColor(100, 100, 100);
                        pdf.text('TWA', 25, y);
                        pdf.text('Target', 50, y);
                        pdf.text('Average', 75, y);
                        pdf.text('Points', 105, y);
                        pdf.text('TWA', 135, y);
                        pdf.text('Target', 160, y);
                        pdf.text('Average', 185, y, { align: 'right' });
                        y += 5;
                        pdf.setLineWidth(0.3);
                        pdf.setDrawColor(200, 200, 200);
                        pdf.line(20, y, 190, y);
                        y += 4;
                        pdf.setFont(undefined, 'normal');
                        pdf.setTextColor(0, 0, 0);
                    }
                }
                
                y += 8;
                
                // Key insights
                if (y > 230) {
                    pdf.addPage();
                    y = 20;
                }
                
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('Key Insights:', 20, y);
                y += 6;
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                
                const polarInsights = [];
                
                // Compare to typical Melges 15 targets (if known)
                const typicalUpwindTWA = 42; // Typical for Melges 15
                const typicalDownwindTWA = 135;
                
                if (Math.abs(analysis.optimalAngles.upwind.angle - typicalUpwindTWA) > 5) {
                    polarInsights.push('- Your optimal upwind angle (' + analysis.optimalAngles.upwind.angle + String.fromCharCode(176) + ') differs from typical target (' + typicalUpwindTWA + String.fromCharCode(176) + ') - this reflects your actual conditions');
                } else {
                    polarInsights.push('- Optimal upwind angle (' + analysis.optimalAngles.upwind.angle + String.fromCharCode(176) + ') aligns well with typical targets');
                }
                
                if (Math.abs(analysis.optimalAngles.downwind.angle - typicalDownwindTWA) > 10) {
                    polarInsights.push('- Downwind angle (' + analysis.optimalAngles.downwind.angle + String.fromCharCode(176) + ') suggests conditions favored ' + 
                        (analysis.optimalAngles.downwind.angle < typicalDownwindTWA ? 'tighter reaching' : 'deeper angles'));
                }
                
                // Speed variance analysis
                const avgSpeedGap = analysis.polar.reduce((sum, p) => sum + (p.target - p.avg), 0) / analysis.polar.length;
                if (avgSpeedGap > 0.5) {
                    polarInsights.push('- Large gap between target and average speeds (' + avgSpeedGap.toFixed(2) + ' kts) indicates inconsistent performance');
                    polarInsights.push('- Focus on consistency: Your top 10% performance shows what\'s possible at each angle');
                } else {
                    polarInsights.push('- Consistent performance: Small gap between target and average speeds');
                }
                
                polarInsights.forEach(insight => {
                    const lines = pdf.splitTextToSize(insight, 165);
                    lines.forEach(line => {
                        pdf.text(line, 22, y);
                        y += 4.5;
                    });
                });
                
                y += 6;
                
                // Note about data quality
                pdf.setFontSize(7);
                pdf.setTextColor(120, 120, 120);
                pdf.text('Note: Target speeds represent your 90th percentile (top 10%) performance at each angle.', 20, y);
                y += 4;
                pdf.text('This shows what you\'re capable of achieving rather than prescriptive coach targets.', 20, y);
                pdf.setTextColor(0, 0, 0);
            }
            
            // CALL TO ACTION & FOOTER
            if (y > 230) {
                pdf.addPage();
                y = 20;
            }
            
            y += 10;
            pdf.setFillColor(15, 23, 42);
            pdf.roundedRect(20, y, 170, 25, 2, 2, 'F');
            
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(12);
            pdf.setFont(undefined, 'bold');
            pdf.text('Want More Detailed Analysis?', pageWidth / 2, y + 8, { align: 'center' });
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            pdf.text('View interactive charts, GPS track maps, and real-time performance', pageWidth / 2, y + 14, { align: 'center' });
            pdf.text('metrics in the full web application at claude.ai/sailing-coach', pageWidth / 2, y + 19, { align: 'center' });
            
            // Footer
            pdf.setTextColor(128, 128, 128);
            pdf.setFontSize(7);
            pdf.text('Generated by Sailing Coach Analysis Tool  ‚Ä¢  Data-driven performance optimization for competitive sailors', pageWidth / 2, pageHeight - 10, { align: 'center' });
            
            console.log("‚úÖ PDF ready to save");
            pdf.save('sailing-performance-report.pdf');
            console.log("‚úÖ PDF saved successfully");
            
            // Restore button
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            alert("‚úÖ PDF generated successfully! Check your Downloads folder.");
            
            } catch (error) {
                console.error("‚ùå PDF generation error:", error);
                console.error("Error stack:", error.stack);
                
                // Restore button
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                alert("‚ùå Error generating PDF: " + error.message + "\n\nTry:\n1. Use Chrome or Safari (not in-app browser)\n2. Disable content blockers\n3. Check browser console for details");
            }
        }

        function setupMarkPlacement() {
            if (!map) {
                console.error('‚ùå Cannot setup mark placement - map is null');
                return;
            }
            
            map.on('click', function(e) {
                if (markMode === 'startline') {
                    // Start line drawing mode
                    startLinePins.push({lat: e.latlng.lat, lon: e.latlng.lng});
                    
                    if (startLinePins.length === 1) {
                        // Place first pin
                        L.marker([startLinePins[0].lat, startLinePins[0].lon], {
                            icon: L.divIcon({
                                className: 'start-pin',
                                html: '<div style="width: 10px; height: 10px; background: #3B82F6; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Start Line Pin 1');
                    } else if (startLinePins.length === 2) {
                        // Place second pin and draw line
                        L.marker([startLinePins[1].lat, startLinePins[1].lon], {
                            icon: L.divIcon({
                                className: 'start-pin',
                                html: '<div style="width: 10px; height: 10px; background: #3B82F6; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Start Line Pin 2');
                        
                        // Draw start line
                        startLinePolyline = L.polyline([
                            [startLinePins[0].lat, startLinePins[0].lon],
                            [startLinePins[1].lat, startLinePins[1].lon]
                        ], {
                            color: '#3B82F6',
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '10, 8',
                            className: 'start-line'
                        }).addTo(map).bindPopup('<strong>START LINE</strong><br/>Click "‚úï Clear Line" to remove');
                        
                        // Calculate line length
                        const R = 6371; // Earth radius in km
                        const dLat = (startLinePins[1].lat - startLinePins[0].lat) * Math.PI / 180;
                        const dLon = (startLinePins[1].lon - startLinePins[0].lon) * Math.PI / 180;
                        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                Math.cos(startLinePins[0].lat * Math.PI / 180) * Math.cos(startLinePins[1].lat * Math.PI / 180) *
                                Math.sin(dLon/2) * Math.sin(dLon/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                        const distance = R * c * 1000; // in meters
                        
                        console.log(`üìè Start line drawn: ${distance.toFixed(0)}m length`);
                        
                        // Show clear line button
                        document.getElementById('clearStartLine').style.display = 'block';
                        
                        markMode = null;
                        document.getElementById('map').classList.remove('clickable');
                    }
                } else if (markMode === 'finishline') {
                    // Finish line drawing mode
                    finishLinePins.push({lat: e.latlng.lat, lon: e.latlng.lng});
                    
                    if (finishLinePins.length === 1) {
                        // Place first pin
                        L.marker([finishLinePins[0].lat, finishLinePins[0].lon], {
                            icon: L.divIcon({
                                className: 'finish-pin',
                                html: '<div style="width: 10px; height: 10px; background: #A855F7; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Finish Line Pin 1');
                    } else if (finishLinePins.length === 2) {
                        // Place second pin and draw line
                        L.marker([finishLinePins[1].lat, finishLinePins[1].lon], {
                            icon: L.divIcon({
                                className: 'finish-pin',
                                html: '<div style="width: 10px; height: 10px; background: #A855F7; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Finish Line Pin 2');
                        
                        // Draw finish line
                        finishLinePolyline = L.polyline([
                            [finishLinePins[0].lat, finishLinePins[0].lon],
                            [finishLinePins[1].lat, finishLinePins[1].lon]
                        ], {
                            color: '#A855F7',
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '10, 8',
                            className: 'finish-line'
                        }).addTo(map).bindPopup('<strong>FINISH LINE</strong><br/>Click "‚úï Finish" to remove');
                        
                        // Calculate line length
                        const R = 6371; // Earth radius in km
                        const dLat = (finishLinePins[1].lat - finishLinePins[0].lat) * Math.PI / 180;
                        const dLon = (finishLinePins[1].lon - finishLinePins[0].lon) * Math.PI / 180;
                        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                Math.cos(finishLinePins[0].lat * Math.PI / 180) * Math.cos(finishLinePins[1].lat * Math.PI / 180) *
                                Math.sin(dLon/2) * Math.sin(dLon/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                        const distance = R * c * 1000; // in meters
                        
                        console.log(`üèÅ Finish line drawn: ${distance.toFixed(0)}m length`);
                        
                        // Show clear line button
                        document.getElementById('clearFinishLine').style.display = 'block';
                        
                        markMode = null;
                        document.getElementById('map').classList.remove('clickable');
                    }
                } else if (markMode) {
                    // Regular mark placement
                    const mark = {
                        type: markMode,
                        lat: e.latlng.lat,
                        lon: e.latlng.lng
                    };
                    manualMarks.push(mark);
                    addMarkToMap(mark);
                    console.log(`üìç ${mark.type} mark placed at [${mark.lat.toFixed(4)}, ${mark.lon.toFixed(4)}]`);
                    markMode = null;
                    document.getElementById('map').classList.remove('clickable');
                }
            });
        }

        function addMarkToMap(mark) {
            if (!map) {
                console.error('‚ùå Cannot add mark - map is null');
                return;
            }
            
            const colors = {
                start: '#3B82F6',
                windward: '#10B981',
                leeward: '#FBBF24',
                finish: '#A855F7'
            };

            const icons = {
                start: '‚ñ≤',        // Triangle for start
                windward: '‚óè',     // Circle for windward
                leeward: '‚óÜ',      // Diamond for leeward (gate)
                finish: '‚ñ†'        // Square for finish
            };

            const marker = L.marker([mark.lat, mark.lon], {
                icon: L.divIcon({
                    className: 'custom-mark',
                    html: `<div style="background: ${colors[mark.type]}; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.3); border: 2px solid white;">${icons[mark.type]}</div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                }),
                draggable: true  // Make marker draggable
            }).addTo(map);
            
            marker.bindPopup(`<strong>${mark.type.toUpperCase()} MARK</strong><br/><span style="font-size: 11px; color: #666;">Drag to adjust position</span>`);
            
            // Update mark position and redraw laylines when dragged
            marker.on('dragend', function(event) {
                const position = event.target.getLatLng();
                mark.lat = position.lat;
                mark.lon = position.lng;
                
                console.log(`üìç ${mark.type} mark moved to ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`);
                
                // If windward mark, redraw laylines
                if (mark.type === 'windward' && analysis && analysis.laylines) {
                    // Remove old laylines
                    map.eachLayer(layer => {
                        if (layer instanceof L.Polyline && layer.options.className && layer.options.className.includes('layline-upwind')) {
                            map.removeLayer(layer);
                        }
                    });
                    // Draw new laylines from updated position
                    drawLaylines(mark.lat, mark.lon);
                }
                
                // If leeward mark, redraw downwind laylines
                if (mark.type === 'leeward' && analysis && analysis.downwindLaylines) {
                    // Remove old downwind laylines
                    map.eachLayer(layer => {
                        if (layer instanceof L.Polyline && layer.options.className && layer.options.className.includes('layline-downwind')) {
                            map.removeLayer(layer);
                        }
                    });
                    // Draw new laylines from updated position
                    drawDownwindLaylines(mark.lat, mark.lon);
                }
            });
            
            // If windward mark, draw laylines
            if (mark.type === 'windward' && analysis && analysis.laylines) {
                drawLaylines(mark.lat, mark.lon);
            }
            
            // If leeward mark, draw downwind laylines
            if (mark.type === 'leeward' && analysis && analysis.downwindLaylines) {
                drawDownwindLaylines(mark.lat, mark.lon);
            }
        }
        
        /**
         * LAYLINES - Visual Guide for Windward Mark Approach
         * 
         * üèÅ What Laylines Show:
         * 
         *               WINDWARD MARK
         *                     ‚óè
         *                    /|\
         *                   / | \
         *       PORT       /  |  \      STARBOARD
         *       LAYLINE   /   |   \     LAYLINE
         *      (RED)     /    |    \    (GREEN)
         *               /     |     \
         *              /      |      \
         *             /   OPTIMAL     \
         *            /     APPROACH    \
         *           /       ZONE        \
         *          /                     \
         *         /                       \
         *        /                         \
         *       /         YOUR TRACK         \
         *      /      (colored by VMG)        \
         *     üîµTack                     Tacküîµ
         * 
         * Visual Guide:
         * - RED line: Port layline (windDir + 45¬∞)
         * - GREEN line: Starboard layline (windDir - 45¬∞)
         * - Both extend ~1000m from mark
         * 
         * Tactical Use:
         * - Cross layline ‚Üí tack immediately (don't overshoot!)
         * - Inside cone ‚Üí keep sailing
         * - Shows optimal approach corridor
         */
        function drawLaylines(markLat, markLon) {
            if (!map || !analysis || !analysis.laylines) return;
            
            const windDir = analysis.laylines.windDirection;
            const pointingAngle = 45; // Standard 45¬∞ TWA for simplicity
            
            // Calculate layline headings (directions lines extend FROM the mark)
            // Port layline: Wind direction + 45¬∞ (RED)
            // Starboard layline: Wind direction - 45¬∞ (GREEN)
            const portLaylineHeading = (windDir + pointingAngle) % 360;
            const stbdLaylineHeading = (windDir - pointingAngle + 360) % 360;
            
            // Convert headings to radians for trigonometry
            const portAngle = portLaylineHeading * Math.PI / 180;
            const stbdAngle = stbdLaylineHeading * Math.PI / 180;
            
            // Extend laylines ~0.01 degrees (roughly 1km at this latitude)
            const lineLength = 0.01;
            
            // PORT LAYLINE (RED) - extends downwind from mark
            // When you cross this line on starboard tack ‚Üí tack to port
            const portStart = [markLat, markLon];
            const portEnd = [
                markLat - lineLength * Math.cos(portAngle),
                markLon - lineLength * Math.sin(portAngle)
            ];
            
            const portLayline = L.polyline([portStart, portEnd], {
                color: '#EF4444',  // RED - port layline
                weight: 3,
                opacity: 0.8,
                dashArray: '15, 10',
                className: 'layline layline-port layline-upwind'
            }).addTo(map);
            
            mapLayers.upwindLaylines.push(portLayline);  // Track for toggles
            
            portLayline.bindPopup(`
                <div style="text-align: center;">
                    <strong style="color: #EF4444; font-size: 14px;">üî¥ PORT LAYLINE</strong><br/>
                    <span style="font-size: 12px; color: #666;">
                        Cross on starboard ‚Üí tack to port<br/>
                        Sail ${portLaylineHeading.toFixed(0)}¬∞ at 45¬∞ TWA to mark
                    </span>
                </div>
            `);
            
            // STARBOARD LAYLINE (GREEN) - extends downwind from mark
            // When you cross this line on port tack ‚Üí tack to starboard
            const stbdStart = [markLat, markLon];
            const stbdEnd = [
                markLat - lineLength * Math.cos(stbdAngle),
                markLon - lineLength * Math.sin(stbdAngle)
            ];
            
            const stbdLayline = L.polyline([stbdStart, stbdEnd], {
                color: '#10B981',  // GREEN - starboard layline
                weight: 3,
                opacity: 0.8,
                dashArray: '15, 10',
                className: 'layline layline-stbd layline-upwind'
            }).addTo(map);
            
            mapLayers.upwindLaylines.push(stbdLayline);  // Track for toggles
            
            stbdLayline.bindPopup(`
                <div style="text-align: center;">
                    <strong style="color: #10B981; font-size: 14px;">üü¢ STARBOARD LAYLINE</strong><br/>
                    <span style="font-size: 12px; color: #666;">
                        Cross on port ‚Üí tack to starboard<br/>
                        Sail ${stbdLaylineHeading.toFixed(0)}¬∞ at 45¬∞ TWA to mark
                    </span>
                </div>
            `);
            
            console.log(`üìê Laylines drawn from mark [${markLat.toFixed(4)}, ${markLon.toFixed(4)}]:`);
            console.log(`   üî¥ Port: ${portLaylineHeading.toFixed(0)}¬∞ (windDir ${windDir}¬∞ + 45¬∞)`);
            console.log(`   üü¢ Starboard: ${stbdLaylineHeading.toFixed(0)}¬∞ (windDir ${windDir}¬∞ - 45¬∞)`);
        }
        
        /**
         * Remove all laylines from map
         */
        function clearLaylines() {
            if (!map) return;
            map.eachLayer(layer => {
                if (layer.options && layer.options.className && layer.options.className.includes('layline')) {
                    map.removeLayer(layer);
                }
            });
            // Clear tracking arrays
            mapLayers.upwindLaylines = [];
            mapLayers.downwindLaylines = [];
        }
        
        /**
         * DOWNWIND LAYLINES - Visual guide for leeward mark approach
         * For asymmetric spinnaker reaching angles
         */
        function drawDownwindLaylines(markLat, markLon) {
            if (!map || !analysis || !analysis.downwindLaylines) return;
            
            const windDir = analysis.downwindLaylines.windDirection;
            const reachingAngle = analysis.downwindLaylines.reachingAngle;
            
            // Calculate downwind layline headings (lines extend UPWIND from leeward mark)
            // Port gybe layline: Wind direction + reaching angle (ORANGE)
            // Starboard gybe layline: Wind direction - reaching angle (PURPLE)
            const portGybeHeading = (windDir + reachingAngle) % 360;
            const stbdGybeHeading = (windDir - reachingAngle + 360) % 360;
            
            // Convert to radians
            const portAngle = portGybeHeading * Math.PI / 180;
            const stbdAngle = stbdGybeHeading * Math.PI / 180;
            
            // Extend laylines upwind from leeward mark (~1km)
            const lineLength = 0.01;
            
            // PORT GYBE LAYLINE (ORANGE) - extends upwind from mark
            const portStart = [markLat, markLon];
            const portEnd = [
                markLat + lineLength * Math.cos(portAngle),
                markLon + lineLength * Math.sin(portAngle)
            ];
            
            const portGybeLayline = L.polyline([portStart, portEnd], {
                color: '#F97316',  // ORANGE - port gybe layline
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 5',  // Different pattern from upwind
                className: 'layline layline-downwind layline-port-gybe'
            }).addTo(map);
            
            mapLayers.downwindLaylines.push(portGybeLayline);
            
            portGybeLayline.bindPopup(`
                <div style="text-align: center;">
                    <strong style="color: #F97316; font-size: 14px;">üü† PORT GYBE LAYLINE</strong><br/>
                    <span style="font-size: 12px; color: #666;">
                        Cross on starboard gybe ‚Üí gybe to port<br/>
                        Sail ${portGybeHeading.toFixed(0)}¬∞ at ${reachingAngle}¬∞ TWA to mark
                    </span>
                </div>
            `);
            
            // STARBOARD GYBE LAYLINE (PURPLE) - extends upwind from mark
            const stbdStart = [markLat, markLon];
            const stbdEnd = [
                markLat + lineLength * Math.cos(stbdAngle),
                markLon + lineLength * Math.sin(stbdAngle)
            ];
            
            const stbdGybeLayline = L.polyline([stbdStart, stbdEnd], {
                color: '#A855F7',  // PURPLE - starboard gybe layline
                weight: 3,
                opacity: 0.8,
                dashArray: '10, 5',  // Different pattern from upwind
                className: 'layline layline-downwind layline-stbd-gybe'
            }).addTo(map);
            
            mapLayers.downwindLaylines.push(stbdGybeLayline);
            
            stbdGybeLayline.bindPopup(`
                <div style="text-align: center;">
                    <strong style="color: #A855F7; font-size: 14px;">üü£ STARBOARD GYBE LAYLINE</strong><br/>
                    <span style="font-size: 12px; color: #666;">
                        Cross on port gybe ‚Üí gybe to starboard<br/>
                        Sail ${stbdGybeHeading.toFixed(0)}¬∞ at ${reachingAngle}¬∞ TWA to mark
                    </span>
                </div>
            `);
            
            console.log(`üìê Downwind laylines drawn from mark [${markLat.toFixed(4)}, ${markLon.toFixed(4)}]:`);
            console.log(`   üü† Port gybe: ${portGybeHeading.toFixed(0)}¬∞ (windDir ${windDir}¬∞ + ${reachingAngle}¬∞)`);
            console.log(`   üü£ Starboard gybe: ${stbdGybeHeading.toFixed(0)}¬∞ (windDir ${windDir}¬∞ - ${reachingAngle}¬∞)`);
        }

        /**
         * Setup layer toggle functionality
         */
        function setupLayerToggles() {
            const toggleButtons = {
                'toggleTrack': 'track',
                'toggleUpwindLaylines': 'upwind-laylines',
                'toggleDownwindLaylines': 'downwind-laylines',
                'toggleShiftZones': 'shift-zones',
                'toggleManeuvers': 'maneuvers',
                'toggleShiftMarkers': 'shift-markers',
                'toggleStartLine': 'start-line',
                'toggleFinishLine': 'finish-line'
            };
            
            Object.keys(toggleButtons).forEach(buttonId => {
                const button = document.getElementById(buttonId);
                const layerKey = toggleButtons[buttonId];
                
                if (!button) return; // Skip missing buttons
                
                button.addEventListener('click', () => {
                    try {
                        // Toggle visibility state
                        layerVisibility[layerKey] = !layerVisibility[layerKey];
                        
                        // Update button appearance
                        if (layerVisibility[layerKey]) {
                            button.classList.remove('inactive');
                            button.classList.add('active');
                        } else {
                            button.classList.remove('active');
                            button.classList.add('inactive');
                        }
                        
                        // Show/hide layers on map
                        toggleMapLayer(layerKey, layerVisibility[layerKey]);
                    } catch (error) {
                        console.error(`‚ùå Error toggling layer ${layerKey}:`, error);
                    }
                });
            });
        }
        
        /**
         * Toggle visibility of map layers
         */
        function toggleMapLayer(layerKey, visible) {
            if (!map) return;
            
            // Map layer keys to class names
            const layerClassMap = {
                'track': 'gps-track',
                'upwind-laylines': 'layline-upwind',
                'downwind-laylines': 'layline-downwind',
                'shift-zones': 'wind-shift-zone',
                'maneuvers': 'maneuver-marker',
                'shift-markers': 'shift-marker',
                'start-line': 'start-line',
                'finish-line': 'finish-line'
            };
            
            const className = layerClassMap[layerKey];
            if (!className) return;
            
            map.eachLayer(layer => {
                // Check if layer has the class we're looking for
                if (layer.options && layer.options.className && layer.options.className.includes(className)) {
                    if (visible) {
                        layer.setStyle({ opacity: layer.options.originalOpacity || 0.8 });
                        if (layer.setStyle && layer.options.fillOpacity) {
                            layer.setStyle({ fillOpacity: layer.options.originalFillOpacity || 0.2 });
                        }
                    } else {
                        // Store original opacity if not already stored
                        if (!layer.options.originalOpacity) {
                            layer.options.originalOpacity = layer.options.opacity;
                        }
                        if (layer.options.fillOpacity && !layer.options.originalFillOpacity) {
                            layer.options.originalFillOpacity = layer.options.fillOpacity;
                        }
                        // Hide by setting opacity to 0
                        layer.setStyle({ opacity: 0 });
                        if (layer.setStyle && layer.options.fillOpacity !== undefined) {
                            layer.setStyle({ fillOpacity: 0 });
                        }
                    }
                }
                
                // Special handling for CircleMarkers (tacks/gybes/shifts)
                if (layer instanceof L.CircleMarker) {
                    if ((layerKey === 'maneuvers' && (
                        (layer.options.color === '#3B82F6') || // Tack color
                        (layer.options.color === '#F59E0B')    // Gybe color
                    )) || (layerKey === 'shift-markers' && (
                        (layer.options.fillColor === '#10B981') || // Lift color
                        (layer.options.fillColor === '#EF4444')    // Header color
                    ))) {
                        if (visible) {
                            layer.setStyle({ opacity: 1, fillOpacity: layer.options.originalFillOpacity || 0.9 });
                        } else {
                            if (!layer.options.originalFillOpacity) {
                                layer.options.originalFillOpacity = layer.options.fillOpacity;
                            }
                            layer.setStyle({ opacity: 0, fillOpacity: 0 });
                        }
                    }
                }
                
                // Special handling for polylines (start/finish lines)
                if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                    if ((layerKey === 'start-line' && layer === startLinePolyline) ||
                        (layerKey === 'finish-line' && layer === finishLinePolyline)) {
                        if (visible) {
                            layer.setStyle({ opacity: layer.options.originalOpacity || 0.8 });
                        } else {
                            if (!layer.options.originalOpacity) {
                                layer.options.originalOpacity = layer.options.opacity;
                            }
                            layer.setStyle({ opacity: 0 });
                        }
                    }
                }
            });
        }

        function clearMarks() {
            manualMarks = [];
            markMode = null;
            if (map) {
                // Remove all markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker) {
                        map.removeLayer(layer);
                    }
                });
                // Remove laylines
                clearLaylines();
                document.getElementById('map').classList.remove('clickable');
                // Re-render the map to restore maneuver markers
                initMap();
            }
        }

        function clearStartLine() {
            startLinePins = [];
            if (map) {
                // Remove start line polyline
                if (startLinePolyline) {
                    map.removeLayer(startLinePolyline);
                    startLinePolyline = null;
                }
                // Remove start pin markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer.options.icon?.options?.className === 'start-pin') {
                        map.removeLayer(layer);
                    }
                });
                // Hide clear line button
                document.getElementById('clearStartLine').style.display = 'none';
                console.log('üìè Start line cleared');
            }
        }

        function clearFinishLine() {
            finishLinePins = [];
            if (map) {
                // Remove finish line polyline
                if (finishLinePolyline) {
                    map.removeLayer(finishLinePolyline);
                    finishLinePolyline = null;
                }
                // Remove finish pin markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer.options.icon?.options?.className === 'finish-pin') {
                        map.removeLayer(layer);
                    }
                });
                // Hide clear line button
                document.getElementById('clearFinishLine').style.display = 'none';
                console.log('üèÅ Finish line cleared');
            }
        }

        // Mobile menu toggle
        function setupMobileMenu() {
            const menuBtn = document.getElementById('mobileMenuBtn');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay');
            
            if (!menuBtn || !sidebar || !overlay) return;
            
            function toggleMenu(e) {
                e.preventDefault();
                e.stopPropagation();
                sidebar.classList.toggle('open');
                overlay.classList.toggle('active');
            }
            
            function closeMenu(e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
            }
            
            // Support both touch and click events for iPad/mobile
            // Use touchend instead of touchstart for better iOS compatibility
            menuBtn.addEventListener('click', toggleMenu);
            menuBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                toggleMenu(e);
            }, { passive: false });
            
            overlay.addEventListener('click', closeMenu);
            overlay.addEventListener('touchend', function(e) {
                e.preventDefault();
                closeMenu(e);
            }, { passive: false });
            
            // Close menu when clicking a link/button in sidebar
            sidebar.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') {
                    setTimeout(closeMenu, 300); // Delay to allow action to complete
                }
            });
        }

        window.onload = initApp;
        
        // AUTO-UPDATE SERVICE WORKER HANDLER
        let swRegistration = null;
        let updateBannerDismissed = false;

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('‚úÖ Service Worker registered:', registration.scope);
                        swRegistration = registration;
                        
                        // Check for updates every 60 seconds
                        setInterval(() => {
                            console.log('üîÑ Checking for updates...');
                            registration.update();
                        }, 60000);
                        
                        // Listen for service worker updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('üì¶ New service worker found, installing...');
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('‚úÖ New service worker installed! Update available.');
                                    showUpdateBanner();
                                }
                            });
                        });
                    })
                    .catch(err => {
                        console.error('‚ùå Service Worker registration failed:', err);
                    });
                
                // Listen for messages from service worker
                navigator.serviceWorker.addEventListener('message', (event) => {
                    if (event.data && event.data.type === 'SW_UPDATED') {
                        console.log('üì¢ Service worker updated to version:', event.data.version);
                        if (!updateBannerDismissed) {
                            showUpdateBanner();
                        }
                    }
                });
                
                // Detect if controller changed
                let refreshing = false;
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    if (!refreshing) {
                        refreshing = true;
                        console.log('üîÑ Service worker controller changed, reloading...');
                        window.location.reload();
                    }
                });
            });
        }

        function showUpdateBanner() {
            const banner = document.getElementById('updateBanner');
            const updateBtn = document.getElementById('updateBtn');
            const dismissBtn = document.getElementById('dismissBtn');
            
            if (banner) {
                banner.style.display = 'block';
                
                updateBtn.onclick = () => {
                    console.log('üöÄ User clicked Update Now');
                    if (swRegistration && swRegistration.waiting) {
                        swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });
                    }
                    window.location.reload();
                };
                
                dismissBtn.onclick = () => {
                    console.log('‚è≠Ô∏è User dismissed update banner');
                    banner.style.display = 'none';
                    updateBannerDismissed = true;
                };
            }
        }
    </script>
</body>
</html>
