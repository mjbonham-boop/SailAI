<!DOCTYPE html>
<html lang="en">
<head>
    <!-- 
        SailAI - Sailing Performance Coach
        Version: 0.5.0
        Date: January 31, 2025
        Update: Day 5 - PWA Enhancements (Service worker, loading indicator, offline support)
        Author: Mike Bonham
        Repository: https://github.com/mjbonham-boop/SailAI
    -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sailing Coach - Complete Analysis</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; }
        #map { background: #1f2937; min-height: 600px; }
        #map.clickable { cursor: crosshair; }
        .chart-container { position: relative; height: 350px; width: 100%; }
        .metric-card { transition: transform 0.2s; }
        .metric-card:hover { transform: translateY(-2px); }
        .coaching-tip { border-left: 4px solid #10B981; }
        .mark-controls { position: absolute; top: 10px; right: 10px; z-index: 1000; }
        
        /* Help System Styles */
        .help-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background: #374151;
            color: #9CA3AF;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            margin-left: 6px;
            transition: all 0.2s;
            vertical-align: middle;
        }
        
        .help-icon:hover {
            background: #4B5563;
            color: #60A5FA;
            transform: scale(1.1);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 340px;
            background-color: #1F2937;
            color: #F3F4F6;
            text-align: left;
            border-radius: 8px;
            padding: 14px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -170px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #60A5FA;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.4);
            font-size: 13px;
            line-height: 1.6;
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #1F2937 transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .help-section {
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .help-section summary {
            cursor: pointer;
            font-weight: 600;
            color: #60A5FA;
            user-select: none;
        }
        
        .help-section summary:hover {
            color: #93C5FD;
        }
        
        .help-section p {
            margin-top: 8px;
            color: #D1D5DB;
        }
        
        .help-section ul {
            margin-top: 8px;
            margin-left: 20px;
            color: #D1D5DB;
        }
        
        .help-section li {
            margin-top: 4px;
        }
        
        .help-section code {
            background: #374151;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            color: #FCD34D;
        }
        
        .metric-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            margin-left: 8px;
            vertical-align: middle;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .badge-excellent { background: #065F46; color: #6EE7B7; }
        .badge-good { background: #1E3A8A; color: #93C5FD; }
        .badge-moderate { background: #78350F; color: #FCD34D; }
        .badge-poor { background: #7F1D1D; color: #FCA5A5; }
    
        /* Mobile Responsive Styles */
        #sidebar {
            transition: transform 0.3s ease-in-out;
        }
        
        #mobileMenuBtn {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 1001;
            background: #1F2937;
            border: 2px solid #60A5FA;
            border-radius: 0.5rem;
            padding: 0.75rem;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        #mobileMenuBtn:hover {
            background: #374151;
        }
        
        #mobileOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
        
        @media screen and (max-width: 768px) {
            #mobileMenuBtn {
                display: block;
            }
            
            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                bottom: 0;
                z-index: 1000;
                transform: translateX(-100%);
                width: 85vw;
                max-width: 320px;
            }
            
            #sidebar.open {
                transform: translateX(0);
            }
            
            #mobileOverlay.active {
                display: block;
            }
            
            #mainContent {
                padding: 1rem !important;
                padding-top: 4rem !important;
            }
            
            /* Stack charts vertically on mobile */
            .grid {
                grid-template-columns: 1fr !important;
            }
            
            /* Enhanced mobile button styling */
            button {
                min-height: 48px !important;
                font-size: 16px !important;
                font-weight: 600 !important;
                transition: all 0.15s ease !important;
                touch-action: manipulation; /* Prevents double-tap zoom */
            }
            
            /* Visual feedback when tapping buttons */
            button:active {
                transform: scale(0.97) !important;
                opacity: 0.9 !important;
            }
            
            /* Make Auto-Detect and Add Race buttons more prominent */
            #autoDetectRaces {
                padding: 0.875rem 1.25rem !important;
                font-size: 1.125rem !important;
                min-height: 52px !important;
            }
            
            #addRace {
                padding: 0.875rem 1.25rem !important;
                font-size: 1rem !important;
                min-height: 52px !important;
            }
            
            /* Ensure PDF buttons are prominent and easy to tap */
            #generatePDF, #pdfButtonMain {
                min-height: 52px !important;
                font-size: 1.125rem !important;
                padding: 0.875rem 1.25rem !important;
            }
            
            /* Make slider value displays more visible */
            #windDirDisplay {
                font-size: 1.5rem !important;
                font-weight: 700 !important;
                color: #60a5fa !important;
            }
            
            /* Slider labels bigger */
            input[type="range"] + label,
            label[for] {
                font-size: 1rem !important;
                font-weight: 600 !important;
            }
            
            input[type="range"] {
                height: 44px !important;
                -webkit-appearance: none;
                appearance: none;
                background: transparent;
            }
            
            /* Slider track */
            input[type="range"]::-webkit-slider-track {
                height: 8px;
                background: linear-gradient(to right, #3b82f6, #60a5fa);
                border-radius: 4px;
                border: none;
            }
            
            input[type="range"]::-moz-range-track {
                height: 8px;
                background: linear-gradient(to right, #3b82f6, #60a5fa);
                border-radius: 4px;
                border: none;
            }
            
            /* Slider thumb - BIGGER for mobile */
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: white;
                border: 3px solid #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                margin-top: -10px;
            }
            
            input[type="range"]::-moz-range-thumb {
                width: 28px;
                height: 28px;
                border-radius: 50%;
                background: white;
                border: 3px solid #3b82f6;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            }
            
            /* Active state - visual feedback when dragging */
            input[type="range"]:active::-webkit-slider-thumb {
                background: #60a5fa;
                transform: scale(1.1);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.2);
            }
            
            input[type="range"]:active::-moz-range-thumb {
                background: #60a5fa;
                transform: scale(1.1);
                box-shadow: 0 0 0 8px rgba(59, 130, 246, 0.2);
            }
            
            /* Readable text */
            body {
                font-size: 16px;
            }
            
            /* Responsive charts */
            .chart-container {
                height: 250px !important;
            }
            
            /* Better spacing on mobile */
            .mb-8 {
                margin-bottom: 1.5rem !important;
            }
            
            .p-6 {
                padding: 1rem !important;
            }
        }
        
    </style>
</head>
<body class="bg-gray-900 text-gray-100">
    <div id="root">
        <!-- Loading indicator - replaced when app loads -->
        <div id="loadingIndicator" style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #1F2937;">
            <div style="text-align: center;">
                <div style="width: 60px; height: 60px; border: 4px solid #374151; border-top-color: #60A5FA; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1.5rem;"></div>
                <h2 style="color: #60A5FA; font-size: 1.5rem; font-weight: 700; margin-bottom: 0.5rem;">‚õµ SailAI</h2>
                <p style="color: #9CA3AF; font-size: 1rem;">Loading your sailing coach...</p>
            </div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    
    <script>
        let csvData = null;
        let analysis = null;
        let windDir = 225;
        let races = [
            { start: '11:00:00', end: '12:00:00' }
        ];
        let selectedRace = '0';
        let raceWindDirections = {}; // Store auto-detected wind direction per race
        let raceResults = {}; // Store analysis results per race for comparison
        let map = null;
        let manualMarks = [];
        let markMode = null;
        let startLinePins = [];
        let startLinePolyline = null;
        let finishLinePins = [];
        let finishLinePolyline = null;
        
        // Maneuver detection parameters
        let maneuverParams = {
            minAngle: 60,
            timeWindow: 10,
            minSpeed: 2.0
        };

        // Help system helper functions
        function helpIcon(tooltipText) {
            return `
                <span class="tooltip">
                    <span class="help-icon">?</span>
                    <span class="tooltiptext">${tooltipText}</span>
                </span>
            `;
        }

        function metricBadge(value, excellentThreshold, goodThreshold, higherIsBetter = true) {
            let badgeClass, badgeText;
            
            if (higherIsBetter) {
                if (value >= excellentThreshold) {
                    badgeClass = 'badge-excellent';
                    badgeText = 'Excellent';
                } else if (value >= goodThreshold) {
                    badgeClass = 'badge-good';
                    badgeText = 'Good';
                } else if (value >= goodThreshold * 0.8) {
                    badgeClass = 'badge-moderate';
                    badgeText = 'OK';
                } else {
                    badgeClass = 'badge-poor';
                    badgeText = 'Needs Work';
                }
            } else {
                // Lower is better (e.g., leeway)
                if (value <= excellentThreshold) {
                    badgeClass = 'badge-excellent';
                    badgeText = 'Excellent';
                } else if (value <= goodThreshold) {
                    badgeClass = 'badge-good';
                    badgeText = 'Good';
                } else if (value <= goodThreshold * 1.5) {
                    badgeClass = 'badge-moderate';
                    badgeText = 'OK';
                } else {
                    badgeClass = 'badge-poor';
                    badgeText = 'Needs Work';
                }
            }
            
            return `<span class="metric-badge ${badgeClass}">${badgeText}</span>`;
        }

        function expandableHelp(title, content) {
            return `
                <details class="help-section">
                    <summary>üí° ${title}</summary>
                    ${content}
                </details>
            `;
        }

        function getCompassDirection(degrees) {
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return directions[index];
        }

        // Download HTML function
        function downloadHTML() {
            const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `sailing-analysis-${new Date().toISOString().split('T')[0]}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Check if in preview/iframe mode and show download button
        window.addEventListener('DOMContentLoaded', () => {
            if (typeof L === 'undefined' || typeof Chart === 'undefined') {
                const btn = document.getElementById('downloadBtn');
                if (btn) btn.classList.remove('hidden');
            }
        });

        function initApp() {
            document.getElementById('root').innerHTML = `
                <!-- Mobile Menu Button -->
                <button id="mobileMenuBtn" aria-label="Toggle Menu">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                
                <!-- Mobile Overlay -->
                <div id="mobileOverlay"></div>
                
                <div class="flex h-screen">
                    <div id="sidebar" class="w-80 bg-gray-800 p-6 overflow-y-auto border-r border-gray-700">
                        <h1 class="text-2xl font-bold mb-2">‚õµ Sailing Coach</h1>
                        <div class="text-xs text-green-400 mb-2 px-2 py-1 bg-green-900 bg-opacity-20 rounded border border-green-700">
                            ‚úÖ COG-based VMG ‚Ä¢ Complete Analysis
                        </div>
                        <div class="text-xs text-blue-300 mb-2 px-2 py-1 bg-blue-900 bg-opacity-10 rounded border border-blue-700">
                            üí° Roadmap: Multi-boat fleet comparison
                        </div>
                        <div class="text-xs text-yellow-300 mb-3 px-2 py-1 bg-yellow-900 bg-opacity-10 rounded border border-yellow-700">
                            ‚ö†Ô∏è GPS map & charts may be limited in preview mode
                        </div>
                        <button id="downloadBtn" onclick="downloadHTML()" class="w-full mb-4 px-4 py-2 bg-green-600 hover:bg-green-700 rounded text-sm font-semibold text-white hidden">
                            üì• Download Full Version (GPS Map + All Features)
                        </button>

                        <div class="mb-6">
                            <label class="block text-sm font-medium mb-2">üì§ Upload CSV</label>
                            <input type="file" accept=".csv" id="fileInput" class="w-full p-2 bg-gray-700 border border-gray-600 rounded text-sm" />
                            <div class="text-xs text-gray-500 mt-1">Vakaros GPS data ‚Ä¢ Future: multi-file support planned</div>
                            <div id="error" class="mt-2 text-xs text-red-400 hidden"></div>
                        </div>

                        <div class="mb-6">
                            <label class="block text-sm font-medium mb-2">üå¨Ô∏è Wind Direction: <span id="windDirDisplay">${windDir}</span>¬∞</label>
                            <input type="range" min="0" max="359" value="${windDir}" id="windDirSlider" class="w-full" />
                            <div class="text-xs text-yellow-400 mt-2">‚ö†Ô∏è Auto-detected - verify against your on-water experience!</div>
                        </div>

                        <div class="mb-6">
                            <label class="block text-sm font-medium mb-2">Race Times</label>
                            <div id="racesContainer"></div>
                            <div class="mt-2 grid grid-cols-2 gap-2">
                                <button id="autoDetectRaces" class="p-2 bg-purple-600 hover:bg-purple-700 rounded text-sm font-semibold">
                                    ü§ñ Auto-Detect
                                </button>
                                <button id="addRace" class="p-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                                    + Manual Add
                                </button>
                            </div>
                            <div class="mt-2 text-xs text-gray-500 italic">
                                Auto-detect finds races from GPS gaps (>3 min between points)
                            </div>
                        </div>

                        <div class="mb-6" id="raceSelector" style="display:none;">
                            <label class="block text-sm font-medium mb-2">Select Race</label>
                            <select id="raceSelect" class="w-full p-2 bg-gray-700 border border-gray-600 rounded text-sm">
                                <option value="all">All Races (Combined)</option>
                            </select>
                            <div class="text-xs text-gray-400 mt-1">Note: "All Races" combines all data points from all races into a single analysis.</div>
                        </div>

                        <div class="mb-6" id="maneuverTuner" style="display:none;">
                            <div class="text-sm font-medium mb-3 border-b border-gray-600 pb-2">üéõÔ∏è Maneuver Detection</div>
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Min Angle: <span id="minAngleDisplay">${maneuverParams.minAngle}</span>¬∞</label>
                                <input type="range" min="30" max="120" value="${maneuverParams.minAngle}" id="minAngleSlider" class="w-full" />
                            </div>
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Time Window: <span id="timeWindowDisplay">${maneuverParams.timeWindow}</span>s</label>
                                <input type="range" min="5" max="30" value="${maneuverParams.timeWindow}" id="timeWindowSlider" class="w-full" />
                            </div>
                            <div class="mb-3">
                                <label class="block text-xs mb-1">Min Speed: <span id="minSpeedDisplay">${maneuverParams.minSpeed}</span> kts</label>
                                <input type="range" min="0" max="5" step="0.5" value="${maneuverParams.minSpeed}" id="minSpeedSlider" class="w-full" />
                            </div>
                        </div>

                        <div class="mb-6" id="heelOptions" style="display:none;">
                            <div class="text-sm font-medium mb-3 border-b border-gray-600 pb-2">‚öñÔ∏è Heel Analysis</div>
                            <label class="flex items-center text-xs mb-2">
                                <input type="checkbox" id="absHeelCheck" class="mr-2" />
                                Use Absolute Heel
                            </label>
                            <label class="flex items-center text-xs">
                                <input type="checkbox" id="showBestFitCheck" class="mr-2" checked />
                                Show Best Fit Curve
                            </label>
                        </div>

                        <div id="sessionInfo" class="text-xs text-gray-400 p-3 bg-gray-700 rounded hidden">
                            <div class="font-semibold mb-2">Session Info</div>
                            <div id="dataPoints"></div>
                            <div id="dataQuality" class="mt-2"></div>
                        </div>

                        <button id="generatePDF" class="w-full p-3 bg-green-600 hover:bg-green-700 rounded font-semibold text-base mt-4 shadow-lg" style="display:none;">
                            üìÑ Generate PDF Report
                        </button>
                        <div class="text-xs text-yellow-400 mt-2 px-2" id="pdfNote" style="display:none;">
                            üí° Scroll down in the sidebar to find this button after uploading data
                        </div>
                    </div>

                    <div class="flex-1 overflow-y-auto p-8" id="mainContent">
                        <div class="flex items-center justify-center" style="min-height: 400px;">
                            <div class="text-center text-gray-400">
                                <div class="text-6xl mb-4">üì§</div>
                                <p class="text-xl">Upload your Vakaros CSV file</p>
                                <p class="text-sm mt-2 text-gray-500">Complete performance analysis with all metrics</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            renderRaces();
            
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            document.getElementById('windDirSlider').addEventListener('input', (e) => {
                const oldWindDir = windDir;
                windDir = parseInt(e.target.value);
                document.getElementById('windDirDisplay').textContent = windDir;
                
                // Update stored wind direction for current race
                const raceKey = selectedRace === 'all' ? 'all' : `race_${selectedRace}`;
                raceWindDirections[raceKey] = windDir;
                
                console.log(`üéöÔ∏è Wind direction slider changed: ${oldWindDir}¬∞ ‚Üí ${windDir}¬∞ (stored for ${raceKey}, re-analyzing...)`);
                if (csvData) analyzeData();
            });
            document.getElementById('addRace').addEventListener('click', addRace);
            document.getElementById('autoDetectRaces').addEventListener('click', autoDetectRaces);
            
            // Maneuver tuner listeners
            document.getElementById('minAngleSlider').addEventListener('input', (e) => {
                maneuverParams.minAngle = parseInt(e.target.value);
                document.getElementById('minAngleDisplay').textContent = maneuverParams.minAngle;
                if (csvData) analyzeData();
            });
            document.getElementById('timeWindowSlider').addEventListener('input', (e) => {
                maneuverParams.timeWindow = parseInt(e.target.value);
                document.getElementById('timeWindowDisplay').textContent = maneuverParams.timeWindow;
                if (csvData) analyzeData();
            });
            document.getElementById('minSpeedSlider').addEventListener('input', (e) => {
                maneuverParams.minSpeed = parseFloat(e.target.value);
                document.getElementById('minSpeedDisplay').textContent = maneuverParams.minSpeed;
                if (csvData) analyzeData();
            });
            
            // Heel options
            document.getElementById('absHeelCheck').addEventListener('change', () => {
                if (csvData) renderCharts();
            });
            document.getElementById('showBestFitCheck').addEventListener('change', () => {
                if (csvData) renderCharts();
            });
            
            // PDF generation
            document.getElementById('generatePDF').addEventListener('click', function(e) {
                console.log("üîµ PDF button clicked!");
                e.preventDefault();
                generatePDF();
            });
            
            // Setup mobile menu
            setupMobileMenu();
        }

        function renderRaces() {
            const container = document.getElementById('racesContainer');
            container.innerHTML = races.map((race, idx) => {
                const raceKey = `race_${idx}`;
                const raceWind = raceWindDirections[raceKey] || windDir;
                
                // Show confidence badge if auto-detected
                const confidenceBadge = race.autoDetected ? `
                    <span class="text-xs px-2 py-1 rounded ${
                        race.confidence === 'HIGH' ? 'bg-green-900 text-green-300' :
                        race.confidence === 'MEDIUM' ? 'bg-blue-900 text-blue-300' :
                        'bg-yellow-900 text-yellow-300'
                    }">
                        ü§ñ ${race.confidence}
                    </span>
                ` : '';
                
                const raceInfo = race.autoDetected ? `
                    <div class="text-xs text-gray-500 mt-1">
                        ${race.durationMin} min ‚Ä¢ ${race.points} GPS points ‚Ä¢ ${race.avgSpeed} kts avg
                    </div>
                ` : '';
                
                return `
                <div class="p-3 bg-gray-700 rounded border border-gray-600 mb-2">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                            <div class="text-xs text-gray-400">Race ${idx + 1}</div>
                            ${confidenceBadge}
                        </div>
                        ${races.length > 1 ? `<button data-remove-race="${idx}" class="remove-race-btn text-red-400 text-xs hover:text-red-300">‚úï</button>` : ''}
                    </div>
                    <div class="flex gap-2 mb-2">
                        <div class="flex-1">
                            <label class="text-xs text-gray-400 mb-1 block">Start (HH:MM:SS)</label>
                            <input type="time" step="1" value="${race.start}" 
                                   data-race-idx="${idx}" data-field="start"
                                   class="race-time-input w-full p-2 bg-gray-600 border border-gray-500 rounded text-sm text-white" />
                        </div>
                        <div class="flex-1">
                            <label class="text-xs text-gray-400 mb-1 block">End (HH:MM:SS)</label>
                            <input type="time" step="1" value="${race.end}"
                                   data-race-idx="${idx}" data-field="end"
                                   class="race-time-input w-full p-2 bg-gray-600 border border-gray-500 rounded text-sm text-white" />
                        </div>
                    </div>
                    ${raceInfo}
                    <div class="mt-2 p-2 bg-gray-800 rounded">
                        <label class="text-xs text-gray-400">
                            Wind (FROM): <span id="raceWind_${idx}" class="text-white font-semibold">${Math.round(raceWind)}¬∞</span>
                            <span class="text-gray-500">${getCompassDirection(Math.round(raceWind))}</span>
                        </label>
                        <input type="range" min="0" max="359" value="${Math.round(raceWind)}"
                               data-race-idx="${idx}"
                               class="race-wind-slider w-full mt-1" 
                               style="height: 6px;" />
                        <div class="text-xs text-yellow-400 mt-1">‚ö†Ô∏è Verify auto-detected wind!</div>
                    </div>
                </div>
                `;
            }).join('');

            // Add event listeners using delegation
            container.querySelectorAll('.remove-race-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.dataset.removeRace);
                    removeRace(idx);
                });
            });

            container.querySelectorAll('.race-time-input').forEach(input => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    const field = e.target.dataset.field;
                    updateRace(idx, field, e.target.value);
                });
            });

            // Add wind slider listeners
            container.querySelectorAll('.race-wind-slider').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const idx = parseInt(e.target.dataset.raceIdx);
                    const value = parseInt(e.target.value);
                    const raceKey = `race_${idx}`;
                    raceWindDirections[raceKey] = value;
                    document.getElementById(`raceWind_${idx}`).textContent = value + '¬∞';
                    
                    // If this is the currently selected race, update global wind and re-analyze
                    if (selectedRace === String(idx)) {
                        windDir = value;
                        document.getElementById('windDirSlider').value = value;
                        document.getElementById('windDirDisplay').textContent = value;
                        if (csvData) analyzeData();
                    }
                });
            });

            // Update race selector
            const selector = document.getElementById('raceSelect');
            if (selector) {
                selector.innerHTML = '<option value="all">All Races</option>' +
                    races.map((_, idx) => `<option value="${idx}">Race ${idx + 1}</option>`).join('');
                selector.value = selectedRace;
            }

            if (races.length > 1) {
                document.getElementById('raceSelector').style.display = 'block';
                const raceSelect = document.getElementById('raceSelect');
                // Remove old listener if exists
                const newSelect = raceSelect.cloneNode(true);
                raceSelect.parentNode.replaceChild(newSelect, raceSelect);
                newSelect.addEventListener('change', (e) => {
                    const oldRace = selectedRace;
                    selectedRace = e.target.value;
                    
                    // Restore stored wind direction for this race, or keep current if not stored yet
                    const raceKey = selectedRace === 'all' ? 'all' : `race_${selectedRace}`;
                    if (raceWindDirections[raceKey]) {
                        windDir = Math.round(raceWindDirections[raceKey]);
                        document.getElementById('windDirSlider').value = windDir;
                        document.getElementById('windDirDisplay').textContent = windDir;
                        console.log(`üîÑ Switched from race ${oldRace} to ${selectedRace}, restored wind direction: ${windDir}¬∞`);
                    } else {
                        console.log(`üîÑ Switched to race ${selectedRace}, will auto-detect wind direction`);
                    }
                    
                    if (csvData) analyzeData();
                });
            } else {
                document.getElementById('raceSelector').style.display = 'none';
            }
        }

        function addRace() {
            races.push({ start: '12:00:00', end: '13:00:00' });
            renderRaces();
            if (csvData) analyzeData();
        }

        function autoDetectRaces() {
            if (!csvData || csvData.length === 0) {
                alert('Please upload CSV data first!');
                return;
            }
            
            console.log('ü§ñ Auto-detecting races from GPS gaps...');
            console.log(`üìä Total data points: ${csvData.length}`);
            
            // Parse timestamps and sort data
            const dataWithTime = csvData
                .map(row => {
                    const timestamp = new Date(row.timestamp);
                    return {
                        timestamp,
                        time: timestamp.getTime(),
                        speed: parseFloat(row.speed) || 0
                    };
                })
                .filter(d => !isNaN(d.time))
                .sort((a, b) => a.time - b.time);
            
            if (dataWithTime.length < 10) {
                alert('Not enough GPS data to detect races');
                return;
            }
            
            console.log(`‚úÖ Valid timestamps: ${dataWithTime.length}`);
            console.log(`üìÖ Data range: ${dataWithTime[0].timestamp.toLocaleString()} to ${dataWithTime[dataWithTime.length-1].timestamp.toLocaleString()}`);
            
            // MORE LENIENT: Detect gaps (>2 minutes = 120,000 ms between points)
            const minGapMs = 2 * 60 * 1000; // Changed from 3 to 2 minutes
            const minRaceDurationMs = 5 * 60 * 1000; // Changed from 10 to 5 minutes minimum
            const maxRaceDurationMs = 120 * 60 * 1000; // 2 hours max race
            
            // Find all gaps in the data
            const gaps = [];
            for (let i = 1; i < dataWithTime.length; i++) {
                const timeDiff = dataWithTime[i].time - dataWithTime[i-1].time;
                if (timeDiff > minGapMs) {
                    gaps.push({
                        index: i,
                        gapMinutes: (timeDiff / 60000).toFixed(1),
                        before: dataWithTime[i-1].timestamp.toLocaleTimeString(),
                        after: dataWithTime[i].timestamp.toLocaleTimeString()
                    });
                }
            }
            
            console.log(`üîç Found ${gaps.length} gaps >2 minutes:`);
            gaps.forEach(g => {
                console.log(`  Gap at ${g.before} ‚Üí ${g.after} (${g.gapMinutes} min)`);
            });
            
            const segments = [];
            let currentSegment = {
                start: dataWithTime[0].timestamp,
                end: dataWithTime[0].timestamp,
                points: 1,
                avgSpeed: dataWithTime[0].speed
            };
            
            for (let i = 1; i < dataWithTime.length; i++) {
                const timeDiff = dataWithTime[i].time - dataWithTime[i-1].time;
                
                if (timeDiff > minGapMs) {
                    // Gap detected - finish current segment
                    const duration = currentSegment.end.getTime() - currentSegment.start.getTime();
                    segments.push({...currentSegment, duration});
                    console.log(`  Segment: ${currentSegment.start.toLocaleTimeString()} - ${currentSegment.end.toLocaleTimeString()} (${(duration/60000).toFixed(1)} min, ${currentSegment.points} pts)`);
                    
                    // Start new segment
                    currentSegment = {
                        start: dataWithTime[i].timestamp,
                        end: dataWithTime[i].timestamp,
                        points: 1,
                        avgSpeed: dataWithTime[i].speed
                    };
                } else {
                    // Continue current segment
                    currentSegment.end = dataWithTime[i].timestamp;
                    currentSegment.points++;
                    currentSegment.avgSpeed = (currentSegment.avgSpeed * (currentSegment.points - 1) + dataWithTime[i].speed) / currentSegment.points;
                }
            }
            
            // Add final segment
            const duration = currentSegment.end.getTime() - currentSegment.start.getTime();
            segments.push({...currentSegment, duration});
            console.log(`  Segment: ${currentSegment.start.toLocaleTimeString()} - ${currentSegment.end.toLocaleTimeString()} (${(duration/60000).toFixed(1)} min, ${currentSegment.points} pts)`);
            
            console.log(`üì¶ Total segments: ${segments.length}`);
            
            // Filter segments by duration
            const validSegments = segments.filter(seg => {
                const durationMin = seg.duration / 60000;
                const valid = seg.duration >= minRaceDurationMs && seg.duration <= maxRaceDurationMs;
                if (!valid) {
                    console.log(`  ‚ùå Filtered out: ${seg.start.toLocaleTimeString()} - ${seg.end.toLocaleTimeString()} (${durationMin.toFixed(1)} min - ${durationMin < 5 ? 'too short' : 'too long'})`);
                }
                return valid;
            });
            
            console.log(`‚úÖ Valid segments (5-120 min): ${validSegments.length}`);
            
            if (validSegments.length === 0) {
                const message = segments.length === 0 
                    ? 'No gaps detected in data. Data appears continuous.\n\nPossible causes:\n‚Ä¢ Races were back-to-back (<2 min apart)\n‚Ä¢ Single continuous sailing session\n‚Ä¢ Need to manually enter race times'
                    : `Found ${segments.length} segment(s) but none were 5-120 minutes long.\n\nSegments found:\n${segments.map(s => `‚Ä¢ ${s.start.toLocaleTimeString()} - ${s.end.toLocaleTimeString()} (${(s.duration/60000).toFixed(1)} min)`).join('\n')}\n\nTry manual race entry instead.`;
                    
                alert(message);
                console.log('‚ö†Ô∏è No valid races detected');
                return;
            }
            
            // Calculate confidence based on data quality
            const detectedRaces = validSegments.map((seg, idx) => {
                const durationMin = seg.duration / 60000;
                const pointsPerMinute = seg.points / durationMin;
                
                // Confidence scoring:
                // HIGH: >30 min race, >0.8 points/min (good GPS coverage)
                // MEDIUM: 20-30 min race OR 0.5-0.8 points/min
                // LOW: <20 min race OR <0.5 points/min
                let confidence = 'LOW';
                if (durationMin >= 30 && pointsPerMinute >= 0.8) {
                    confidence = 'HIGH';
                } else if (durationMin >= 20 && pointsPerMinute >= 0.5) {
                    confidence = 'MEDIUM';
                }
                
                return {
                    start: seg.start.toTimeString().slice(0, 8),
                    end: seg.end.toTimeString().slice(0, 8),
                    confidence,
                    autoDetected: true,
                    durationMin: Math.round(durationMin),
                    points: seg.points,
                    avgSpeed: seg.avgSpeed.toFixed(1)
                };
            });
            
            // Store original races in case user cancels
            const originalRaces = [...races];
            
            // Replace current races with detected ones
            races = detectedRaces;
            
            console.log(`‚úÖ Detected ${races.length} races:`);
            races.forEach((r, idx) => {
                console.log(`  Race ${idx + 1}: ${r.start} - ${r.end} (${r.durationMin} min, ${r.points} pts, ${r.confidence} confidence)`);
            });
            
            // Alert user
            const raceList = races.map((r, idx) => 
                `Race ${idx + 1}: ${r.start}-${r.end} (${r.durationMin}min, ${r.confidence})`
            ).join('\n');
            
            const confirmed = confirm(
                `ü§ñ Auto-detected ${races.length} race(s):\n\n${raceList}\n\nClick OK to use these races, or Cancel to keep manual entries.`
            );
            
            if (confirmed) {
                renderRaces();
                if (csvData) analyzeData();
                alert('‚úÖ Races updated! You can still edit times manually if needed.');
            } else {
                // Restore original races
                races = originalRaces;
                alert('Auto-detection cancelled. Manual races preserved.');
            }
        }

        function removeRace(idx) {
            races.splice(idx, 1);
            renderRaces();
            if (csvData) analyzeData();
        }

        function updateRace(idx, field, value) {
            races[idx][field] = value;
            if (csvData) analyzeData();
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    csvData = parseCSV(event.target.result);
                    console.log(`‚úÖ Parsed ${csvData.length} rows`);
                    document.getElementById('error').classList.add('hidden');
                    analyzeData();
                } catch (err) {
                    console.error("‚ùå Parse error:", err);
                    document.getElementById('error').textContent = err.message;
                    document.getElementById('error').classList.remove('hidden');
                }
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            if (lines.length < 2) throw new Error('CSV must have header and data');

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            console.log("üìã CSV Headers:", headers.join(', '));
            
            const data = lines.slice(1).map(line => {
                const values = line.split(',');
                const row = {};
                headers.forEach((h, i) => {
                    const val = values[i]?.trim();
                    if (!val || val === '') { row[h] = null; return; }
                    const num = parseFloat(val);
                    row[h] = (!isNaN(num) && h !== 'timestamp' && h !== 'time') ? num : val;
                });
                return row;
            });

            if (data.length > 0) {
                console.log("üìã First data row:", data[0]);
                console.log("üìç GPS fields present:", {
                    latitude: !!data[0].latitude,
                    lat: !!data[0].lat,
                    longitude: !!data[0].longitude,
                    lon: !!data[0].lon
                });
            }

            return data.filter(row => Object.values(row).some(v => v !== null && v !== '' && v !== 0));
        }

        function analyzeData() {
            if (!csvData) return;
            console.log("üîÑ Starting comprehensive analysis...");

            // Filter by race times
            let filteredData = csvData;
            
            if (selectedRace !== 'all') {
                const raceIdx = parseInt(selectedRace);
                const race = races[raceIdx];
                filteredData = csvData.filter(row => {
                    const ts = row.timestamp || row.time;
                    if (!ts) return false;
                    try {
                        const date = new Date(ts);
                        const h = String(date.getHours()).padStart(2, '0');
                        const m = String(date.getMinutes()).padStart(2, '0');
                        const s = String(date.getSeconds()).padStart(2, '0');
                        const timeStr = `${h}:${m}:${s}`;
                        return timeStr >= race.start && timeStr <= race.end;
                    } catch (e) { return false; }
                });
            }

            console.log(`üìä Filtered to ${filteredData.length} points`);

            if (filteredData.length === 0) {
                showError("No data in selected race time range");
                return;
            }

            // PROCESS DATA
            const processedData = filteredData.map((row, idx) => {
                const speed = row.sog_kts || row.sog || row.speed || 0;
                const heading = row.hdg_true || row.heading || row.hdg || 0;
                const heel = row.heel || 0;
                const trim = row.trim || row.pitch || 0;
                const cog = row.cog || heading;
                
                let rawTWA_cog = (cog - windDir + 180) % 360 - 180;
                const tackSign = Math.sign(rawTWA_cog) || 1;
                const twa_cog = rawTWA_cog + ((Math.abs(heel) * 0.1) * tackSign);
                
                let leeway = cog - heading;
                if (leeway > 180) leeway -= 360;
                if (leeway < -180) leeway += 360;
                
                const isUpwind = Math.abs(twa_cog) < 90;
                const vmg = speed * Math.cos(twa_cog * Math.PI / 180);
                
                let deltaHeading = 0;
                if (idx > 0) {
                    const prevHeading = filteredData[idx-1].hdg_true || filteredData[idx-1].heading || 0;
                    deltaHeading = heading - prevHeading;
                    if (deltaHeading > 180) deltaHeading -= 360;
                    if (deltaHeading < -180) deltaHeading += 360;
                }
                
                return {
                    speed, heading, cog, heel, trim, twa_cog, vmg,
                    leeway: Math.abs(leeway), isUpwind,
                    deltaHeading, rot: Math.abs(deltaHeading),
                    latitude: row.latitude, lat: row.lat,
                    longitude: row.longitude, lon: row.lon,
                    timestamp: row.timestamp
                };
            });

            // DETECT PREDOMINANT HEADINGS TO ESTIMATE TWA
            const headings = processedData.filter(r => r.speed > 3).map(r => r.cog);
            headings.sort((a, b) => a - b);
            
            // Find two peaks in heading distribution (port and starboard tack)
            const headingBins = {};
            headings.forEach(h => {
                const bin = Math.round(h / 5) * 5;
                headingBins[bin] = (headingBins[bin] || 0) + 1;
            });
            
            const sortedBins = Object.entries(headingBins)
                .map(([bin, count]) => ({ bin: parseInt(bin), count }))
                .sort((a, b) => b.count - a.count);
            
            console.log("üß≠ Top 5 heading bins:", sortedBins.slice(0, 5).map(b => `${b.bin}¬∞ (${b.count})`));
            
            // Get the two most common headings (should be port and starboard tack)
            const peak1 = sortedBins[0]?.bin || 0;
            let peak2 = 0;
            for (let i = 1; i < sortedBins.length; i++) {
                if (Math.abs(sortedBins[i].bin - peak1) > 60) {
                    peak2 = sortedBins[i].bin;
                    break;
                }
            }
            
            // Estimate wind direction as midpoint between the two tacks
            // When sailing UPWIND, you point TOWARD the wind, so bisector IS wind direction
            // Handle wraparound for angles near 0/360
            let estimatedWindDir, avgTWA;
            const diff = Math.abs(peak2 - peak1);
            
            if (diff > 180) {
                // Headings wrap around 0/360 (e.g., 350¬∞ and 10¬∞)
                const smallerAngle = Math.min(peak1, peak2);
                const largerAngle = Math.max(peak1, peak2);
                const actualGap = 360 - diff;
                // Bisector is the wind direction when sailing upwind
                estimatedWindDir = (largerAngle + actualGap / 2) % 360;
                avgTWA = actualGap / 2;
            } else {
                // Normal case - headings don't wrap around
                // Bisector is the wind direction when sailing upwind
                estimatedWindDir = (peak1 + peak2) / 2;
                avgTWA = diff / 2;
            }
            
            console.log(`üß≠ Auto-detected: Peak headings ${peak1}¬∞ and ${peak2}¬∞`);
            console.log(`üß≠ Wind FROM (bisector): ${estimatedWindDir.toFixed(0)}¬∞ (TWA ~${avgTWA.toFixed(0)}¬∞)`);
            
            // Store detected wind direction for this race
            const raceKey = selectedRace === 'all' ? 'all' : `race_${selectedRace}`;
            if (!raceWindDirections[raceKey]) {
                raceWindDirections[raceKey] = estimatedWindDir;
                console.log(`üíæ Stored wind direction for ${raceKey}: ${estimatedWindDir.toFixed(0)}¬∞`);
            }
            
            const predominantHeadings = {
                peak1,
                peak2,
                peak1Count: sortedBins[0]?.count || 0,
                peak2Count: peak2 > 0 ? sortedBins.find(b => Math.abs(b.bin - peak2) < 3)?.count || 0 : 0,
                estimatedWindDir,
                avgTWA,
                confidence: sortedBins[0]?.count > 100 ? 'high' : sortedBins[0]?.count > 50 ? 'medium' : 'low'
            };

            // DETECT MANEUVERS (both tacks and gybes)
            const maneuvers = [];
            let tackNumber = 0;

            for (let i = maneuverParams.timeWindow; i < processedData.length - maneuverParams.timeWindow; i++) {
                if (processedData[i].speed < maneuverParams.minSpeed) continue;

                const prevCOG = processedData[i - maneuverParams.timeWindow].cog;
                const nextCOG = processedData[i + maneuverParams.timeWindow].cog;
                let cogChange = Math.abs(nextCOG - prevCOG);
                if (cogChange > 180) cogChange = 360 - cogChange;

                if (cogChange >= maneuverParams.minAngle) {
                    const entrySpeed = processedData.slice(i - 3, i).reduce((sum, r) => sum + r.speed, 0) / 3;
                    const exitSpeed = processedData.slice(i + 1, i + 4).reduce((sum, r) => sum + r.speed, 0) / 3;
                    const speedLoss = entrySpeed - exitSpeed;
                    const timeLost = speedLoss > 0 ? (maneuverParams.timeWindow * 2) * (speedLoss / entrySpeed) : 0;
                    const distanceLost = (entrySpeed * 0.514444) * timeLost;
                    const efficiency = exitSpeed > 0 ? (exitSpeed / entrySpeed) * 100 : 0;
                    
                    // Determine if tack or gybe based on TWA
                    const entryTWA = Math.abs(processedData[i - maneuverParams.timeWindow].twa_cog);
                    const exitTWA = Math.abs(processedData[i + maneuverParams.timeWindow].twa_cog);
                    const avgTWA = (entryTWA + exitTWA) / 2;
                    const maneuverType = avgTWA < 90 ? 'Tack' : 'Gybe';

                    tackNumber++;
                    maneuvers.push({
                        tackNumber,
                        type: maneuverType,
                        cogChange: cogChange.toFixed(1),
                        entrySpeed,
                        exitSpeed,
                        speedLoss,
                        distanceLost: Math.max(0, distanceLost),
                        efficiency,
                        entryTWA,
                        exitTWA,
                        lat: processedData[i].latitude || processedData[i].lat,
                        lon: processedData[i].longitude || processedData[i].lon
                    });

                    i += maneuverParams.timeWindow;
                }
            }
            
            const tacks = maneuvers.filter(m => m.type === 'Tack');
            const gybes = maneuvers.filter(m => m.type === 'Gybe');
            console.log(`‚öì Detected ${tacks.length} tacks and ${gybes.length} gybes`);

            const upwind = processedData.filter(r => r.isUpwind && r.speed > 4.5 && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            const downwind = processedData.filter(r => !r.isUpwind && r.speed > 4.5 && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            
            // For speed/heel distributions, use ALL data (no speed filter)
            const upwindAll = processedData.filter(r => r.isUpwind && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);
            const downwindAll = processedData.filter(r => !r.isUpwind && Math.abs(r.heel) < 25 && Math.abs(r.trim) < 15);

            // CALCULATE OPTIMAL HEEL/TRIM
            const heelBinsUp = {};
            upwind.forEach(r => {
                const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                if (!heelBinsUp[bin]) heelBinsUp[bin] = [];
                heelBinsUp[bin].push(r.vmg);
            });

            let bestHeelUp = 0;
            let bestVMGUp = -999;
            const heelDistribution = [];
            
            for (const [heel, vmgs] of Object.entries(heelBinsUp)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                const avg = vmgs.reduce((a, b) => a + b, 0) / vmgs.length;
                
                heelDistribution.push({ heel: parseInt(heel), count: vmgs.length, p90, avg });
                
                if (p90 > bestVMGUp) {
                    bestVMGUp = p90;
                    bestHeelUp = parseInt(heel);
                }
            }

            const heelBinsDown = {};
            downwind.forEach(r => {
                const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                if (!heelBinsDown[bin]) heelBinsDown[bin] = [];
                heelBinsDown[bin].push(Math.abs(r.vmg));
            });

            let bestHeelDown = 0;
            let bestVMGDown = -999;
            
            for (const [heel, vmgs] of Object.entries(heelBinsDown)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestVMGDown) {
                    bestVMGDown = p90;
                    bestHeelDown = parseInt(heel);
                }
            }

            const trimBinsUp = {};
            upwind.forEach(r => {
                const bin = Math.round(r.trim / 2) * 2;
                if (!trimBinsUp[bin]) trimBinsUp[bin] = [];
                trimBinsUp[bin].push(r.vmg);
            });

            let bestTrimUp = 0;
            let bestTrimVMGUp = -999;
            
            for (const [trim, vmgs] of Object.entries(trimBinsUp)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestTrimVMGUp) {
                    bestTrimVMGUp = p90;
                    bestTrimUp = parseInt(trim);
                }
            }

            const trimBinsDown = {};
            downwind.forEach(r => {
                const bin = Math.round(r.trim / 2) * 2;
                if (!trimBinsDown[bin]) trimBinsDown[bin] = [];
                trimBinsDown[bin].push(Math.abs(r.vmg));
            });

            let bestTrimDown = 0;
            let bestTrimVMGDown = -999;
            
            for (const [trim, vmgs] of Object.entries(trimBinsDown)) {
                if (vmgs.length < 50) continue;
                const sorted = vmgs.sort((a, b) => b - a);
                const p90 = sorted[Math.floor(sorted.length * 0.1)];
                
                if (p90 > bestTrimVMGDown) {
                    bestTrimVMGDown = p90;
                    bestTrimDown = parseInt(trim);
                }
            }

            // OTHER METRICS
            const avgVMG = upwind.reduce((sum, r) => sum + r.vmg, 0) / upwind.length;
            const vmgEfficiency = (avgVMG / bestVMGUp) * 100;

            const inOptimalZone = upwind.filter(r => 
                Math.abs(Math.abs(r.heel) - bestHeelUp) <= 3 && 
                Math.abs(r.trim - bestTrimUp) <= 3
            ).length;
            const timeInZone = (inOptimalZone / upwind.length) * 100;

            const optimalData = upwind.filter(r => Math.abs(Math.abs(r.heel) - bestHeelUp) < 2);
            const avgLeeway = optimalData.reduce((sum, r) => sum + r.leeway, 0) / optimalData.length;

            const upwindGood = processedData.filter(r => r.isUpwind && r.vmg > 3.5 && Math.abs(r.twa_cog) >= 30 && r.speed > 4.5);
            const bestPointing = upwindGood.length > 0 ? Math.min(...upwindGood.map(r => Math.abs(r.twa_cog))) : 0;

            const portTime = processedData.filter(r => r.isUpwind && r.twa_cog < 0).length;
            const starboardTime = processedData.filter(r => r.isUpwind && r.twa_cog > 0).length;
            const totalUpwindTime = portTime + starboardTime;
            const portPercent = (portTime / totalUpwindTime * 100);
            const starboardPercent = (starboardTime / totalUpwindTime * 100);

            const upwindSpeeds = processedData.filter(r => r.isUpwind && r.speed > 2).map(r => r.speed);
            const downwindSpeeds = processedData.filter(r => !r.isUpwind && r.speed > 2).map(r => r.speed);
            const avgUpwindSpeed = upwindSpeeds.reduce((a, b) => a + b, 0) / upwindSpeeds.length;
            const avgDownwindSpeed = downwindSpeeds.reduce((a, b) => a + b, 0) / downwindSpeeds.length;
            const speedRatio = avgDownwindSpeed / avgUpwindSpeed;

            const tackEfficiency = maneuvers.length > 0 
                ? maneuvers.reduce((sum, t) => sum + t.efficiency, 0) / maneuvers.length
                : 0;
            const avgTackLoss = maneuvers.length > 0
                ? maneuvers.reduce((sum, t) => sum + t.distanceLost, 0) / maneuvers.length
                : 0;

            // DISTANCE EFFICIENCY
            if (processedData.length > 1) {
                const firstPoint = processedData[0];
                const lastPoint = processedData[processedData.length - 1];
                const straightLine = haversineDistance(
                    firstPoint.latitude || firstPoint.lat,
                    firstPoint.longitude || firstPoint.lon,
                    lastPoint.latitude || lastPoint.lat,
                    lastPoint.longitude || lastPoint.lon
                );
                
                let totalDistance = 0;
                for (let i = 0; i < processedData.length - 1; i++) {
                    const p1 = processedData[i];
                    const p2 = processedData[i + 1];
                    totalDistance += haversineDistance(
                        p1.latitude || p1.lat, p1.longitude || p1.lon,
                        p2.latitude || p2.lat, p2.longitude || p2.lon
                    );
                }
                
                var distanceEfficiency = (straightLine / totalDistance) * 100;
            } else {
                var distanceEfficiency = 0;
            }

            // BOAT HANDLING SCORE
            const tackScore = Math.max(0, Math.min(100, 100 - (avgTackLoss * 2)));
            const leewayScore = Math.max(0, Math.min(100, 100 - (avgLeeway * 5)));
            const distScore = distanceEfficiency;
            const boatHandlingScore = (tackScore * 0.3 + leewayScore * 0.4 + distScore * 0.3);

            console.log(`üìä Boat Handling Components: Tack=${tackScore.toFixed(0)}, Leeway=${leewayScore.toFixed(0)}, Dist=${distScore.toFixed(0)}`);

            // TWA & SPEED DISTRIBUTIONS
            const twaDistribution = {};
            processedData.forEach(r => {
                const bin = Math.round(r.twa_cog / 5) * 5;
                twaDistribution[bin] = (twaDistribution[bin] || 0) + 1;
            });
            const twaDist = Object.entries(twaDistribution)
                .map(([twa, count]) => ({ twa: parseInt(twa), count }))
                .sort((a, b) => a.twa - b.twa);

            const speedDistribution = {};
            processedData.forEach(r => {
                const bin = Math.round(r.speed * 2) / 2;
                speedDistribution[bin] = (speedDistribution[bin] || 0) + 1;
            });
            const speedDist = Object.entries(speedDistribution)
                .map(([speed, count]) => ({ speed: parseFloat(speed), count }))
                .sort((a, b) => a.speed - b.speed);

            // POLAR DATA
            const polarData = {};
            processedData.forEach(r => {
                const bin = Math.round(Math.abs(r.twa_cog) / 5) * 5;
                // Only include angles from 0-180¬∞
                if (bin >= 0 && bin <= 180) {
                    if (!polarData[bin]) polarData[bin] = [];
                    polarData[bin].push(r.speed);
                }
            });
            
            const polar = Object.entries(polarData)
                .filter(([_, speeds]) => speeds.length > 10)
                .map(([twa, speeds]) => {
                    const sorted = speeds.sort((a, b) => b - a);
                    const target = sorted[Math.floor(sorted.length * 0.1)];
                    const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;
                    return { twa: parseInt(twa), target, avg, count: speeds.length };
                })
                .sort((a, b) => a.twa - b.twa);

            // SAMPLE DATA
            const upwindSample = upwind.filter((_, i) => i % 5 === 0);
            const downwindSample = downwind.filter((_, i) => i % 5 === 0);

            // WIND SHIFT ANALYSIS
            const upwindData = processedData.filter(r => r.isUpwind && r.speed > 2);
            const avgUpwindTWA = upwindData.length > 0 ? upwindData.reduce((sum, r) => sum + Math.abs(r.twa_cog), 0) / upwindData.length : 0;
            let lifts = 0, headers = 0;
            let liftAngles = [], headerAngles = [];
            
            // Mark significant shifts on all data points for map visualization
            processedData.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                const shift = twa - avgUpwindTWA;
                r.isLift = shift < -5;
                r.isHeader = shift > 5;
                r.shiftAmount = shift;
            });
            
            upwindData.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                if (twa < avgUpwindTWA - 3) {
                    lifts++;
                    liftAngles.push(avgUpwindTWA - twa);
                } else if (twa > avgUpwindTWA + 3) {
                    headers++;
                    headerAngles.push(twa - avgUpwindTWA);
                }
            });
            const windAnalysis = {
                lifts,
                headers,
                liftPct: lifts + headers > 0 ? (lifts / (lifts + headers) * 100) : 0,
                headerPct: lifts + headers > 0 ? (headers / (lifts + headers) * 100) : 0,
                avgLiftAngle: liftAngles.length > 0 ? liftAngles.reduce((a,b) => a+b, 0) / liftAngles.length : 0,
                avgHeaderAngle: headerAngles.length > 0 ? headerAngles.reduce((a,b) => a+b, 0) / headerAngles.length : 0,
                avgUpwindTWA
            };

            // COURSE BIAS ANALYSIS
            const courseBias = {
                portTime,
                starboardTime,
                portPct: portPercent,
                starboardPct: starboardPercent
            };

            // COACHING TIPS
            const coachingTips = [];
            if (tackEfficiency < 85 && maneuvers.length > 0) {
                coachingTips.push({
                    category: "Tack Efficiency",
                    message: `Tack efficiency is ${tackEfficiency.toFixed(0)}%. Aim for 90%+ by maintaining speed through tacks`,
                    impact: `~${((90-tackEfficiency)/100 * maneuvers.length * 3).toFixed(0)} seconds per race`,
                    priority: tackEfficiency < 80 ? "high" : "medium"
                });
            }
            if (windAnalysis.liftPct < 40 && upwindData.length > 100) {
                coachingTips.push({
                    category: "Wind Shifts",
                    message: `Only ${windAnalysis.liftPct.toFixed(0)}% on lifts. Tack on headers more aggressively`,
                    impact: "Potentially 30-60 seconds per leg",
                    priority: "high"
                });
            }
            const biasDiff = Math.abs(portPercent - 50);
            if (biasDiff > 20) {
                const favored = portPercent > 50 ? "port" : "starboard";
                coachingTips.push({
                    category: "Course Balance",
                    message: `${biasDiff.toFixed(0)}% bias toward ${favored} tack. Consider if this matches the favored side`,
                    impact: "Strategic - depends on conditions",
                    priority: "medium"
                });
            }

            // GENERATE SUGGESTIONS
            const suggestions = generateSuggestions({
                boatHandlingScore,
                avgLeeway,
                vmgEfficiency,
                timeInZone,
                tackEfficiency,
                avgTackLoss,
                distanceEfficiency,
                bestHeelUp,
                bestTrimUp,
                portPercent,
                starboardPercent,
                speedRatio
            });

            analysis = {
                dataPoints: processedData.length,
                predominantHeadings,
                optimalHeelUp: bestHeelUp,
                optimalHeelDown: bestHeelDown,
                optimalTrimUp: bestTrimUp,
                optimalTrimDown: bestTrimDown,
                vmgEfficiency, avgVMG, bestVMG: bestVMGUp,
                timeInZone,
                leeway: avgLeeway,
                bestPointing,
                portPercent, starboardPercent,
                avgUpwindSpeed, avgDownwindSpeed, speedRatio,
                tacksCount: tacks.length,
                gybesCount: gybes.length,
                tackEfficiency: tacks.length > 0 ? tacks.reduce((sum, t) => sum + t.efficiency, 0) / tacks.length : 0,
                gybeEfficiency: gybes.length > 0 ? gybes.reduce((sum, g) => sum + g.efficiency, 0) / gybes.length : 0,
                avgTackLoss: tacks.length > 0 ? tacks.reduce((sum, t) => sum + t.distanceLost, 0) / tacks.length : 0,
                avgGybeLoss: gybes.length > 0 ? gybes.reduce((sum, g) => sum + g.distanceLost, 0) / gybes.length : 0,
                maneuvers,
                tacks,
                gybes,
                boatHandlingScore,
                distanceEfficiency,
                trackData: processedData,
                heelDistribution: heelDistribution.sort((a, b) => a.heel - b.heel),
                heelDistributionUpwind: upwindAll.map(r => Math.abs(r.heel)),
                heelDistributionDownwind: downwindAll.map(r => Math.abs(r.heel)),
                speedDistributionUpwind: upwindAll.map(r => r.speed),
                speedDistributionDownwind: downwindAll.map(r => r.speed),
                twaDist,
                speedDist,
                polar,
                upwindSample,
                downwindSample,
                windAnalysis,
                courseBias,
                coachingTips,
                suggestions,
                heelDataQuality: {
                    upwindSamples: upwind.length,
                    downwindSamples: downwind.length,
                    minSamplesPerBin: 50,
                    reliable: upwind.length > 500
                }
            };

            // ADDITIONAL ANALYSIS: Heel by wind speed segments
            const lightAir = upwind.filter(r => r.speed >= 3 && r.speed < 5); // ~5-10 kts true wind
            const moderateAir = upwind.filter(r => r.speed >= 5 && r.speed < 7); // ~10-15 kts true wind
            
            let optimalHeelLightAir = bestHeelUp;
            let optimalHeelModerateAir = bestHeelUp;
            
            if (lightAir.length > 100) {
                const heelBinsLight = {};
                lightAir.forEach(r => {
                    const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                    if (!heelBinsLight[bin]) heelBinsLight[bin] = [];
                    heelBinsLight[bin].push(r.vmg);
                });
                
                let bestVMG = -999;
                for (const [heel, vmgs] of Object.entries(heelBinsLight)) {
                    if (vmgs.length < 20) continue;
                    const sorted = vmgs.sort((a, b) => b - a);
                    const p90 = sorted[Math.floor(sorted.length * 0.1)];
                    if (p90 > bestVMG) {
                        bestVMG = p90;
                        optimalHeelLightAir = parseInt(heel);
                    }
                }
            }
            
            if (moderateAir.length > 100) {
                const heelBinsMod = {};
                moderateAir.forEach(r => {
                    const bin = Math.round(Math.abs(r.heel) / 2) * 2;
                    if (!heelBinsMod[bin]) heelBinsMod[bin] = [];
                    heelBinsMod[bin].push(r.vmg);
                });
                
                let bestVMG = -999;
                for (const [heel, vmgs] of Object.entries(heelBinsMod)) {
                    if (vmgs.length < 20) continue;
                    const sorted = vmgs.sort((a, b) => b - a);
                    const p90 = sorted[Math.floor(sorted.length * 0.1)];
                    if (p90 > bestVMG) {
                        bestVMG = p90;
                        optimalHeelModerateAir = parseInt(heel);
                    }
                }
            }
            
            analysis.heelByWindSpeed = {
                lightAir: {
                    samples: lightAir.length,
                    optimal: optimalHeelLightAir,
                    speedRange: '3-5 kts boat speed (~5-10 kts TWS)'
                },
                moderateAir: {
                    samples: moderateAir.length,
                    optimal: optimalHeelModerateAir,
                    speedRange: '5-7 kts boat speed (~10-15 kts TWS)'
                }
            };
            
            // LEEWAY DIAGNOSIS
            const leewayDiagnosis = [];
            if (avgLeeway > 15) {
                leewayDiagnosis.push({
                    severity: 'critical',
                    issue: `Excessive leeway (${avgLeeway.toFixed(0)}¬∞) - Normal range is 3-8¬∞`,
                    possibleCauses: [
                        'Heading sensor calibration error (magnetic declination offset)',
                        'GPS COG lag during maneuvers (not true leeway)',
                        'Centerboard not fully deployed',
                        'Damaged or fouled foils'
                    ],
                    recommendation: 'Most likely: Heading sensor calibration. Test in straight-line light air - true leeway should be <5¬∞.'
                });
            }
            
            analysis.leewayAnalysis = {
                average: avgLeeway,
                diagnosis: leewayDiagnosis,
                concernLevel: avgLeeway > 15 ? 'critical' : avgLeeway > 10 ? 'moderate' : 'good'
            };
            
            // TACK TIMING ANALYSIS - Were tacks on headers?
            const tackTimingAnalysis = [];
            let tacksOnHeaders = 0;
            let tacksOnLifts = 0;
            let tacksNeutral = 0;
            
            maneuvers.filter(m => m.type === 'Tack').forEach(tack => {
                // Find the data point for this tack
                const tackIdx = processedData.findIndex(d => 
                    Math.abs(d.lat - tack.lat) < 0.0001 && Math.abs(d.lon - tack.lon) < 0.0001
                );
                
                if (tackIdx > 5 && tackIdx < processedData.length - 5) {
                    // Check average TWA deviation in 30 seconds before tack
                    const preTackWindow = processedData.slice(Math.max(0, tackIdx - 30), tackIdx);
                    const avgShift = preTackWindow
                        .filter(d => d.isUpwind)
                        .reduce((sum, d) => sum + (d.shiftAmount || 0), 0) / preTackWindow.length;
                    
                    tack.windShift = avgShift;
                    tack.tackTiming = avgShift > 3 ? 'header' : avgShift < -3 ? 'lift' : 'neutral';
                    
                    if (avgShift > 3) tacksOnHeaders++;
                    else if (avgShift < -3) tacksOnLifts++;
                    else tacksNeutral++;
                }
            });
            
            // Calculate tack timing score
            const totalTacks = tacksOnHeaders + tacksOnLifts + tacksNeutral;
            const tackTimingScore = totalTacks > 0 ? (tacksOnHeaders / totalTacks * 100) : 0;
            
            if (tacksOnHeaders + tacksOnLifts > 5) {
                tackTimingAnalysis.push({
                    metric: 'Tacking on Headers',
                    value: `${tacksOnHeaders} of ${totalTacks} tacks (${tackTimingScore.toFixed(0)}%)`,
                    assessment: tackTimingScore > 60 ? 'excellent' : tackTimingScore > 40 ? 'good' : 'needs improvement',
                    recommendation: tackTimingScore < 50 ? 
                        'Tack more aggressively on headers to minimize time on unfavorable tack' :
                        'Good wind shift awareness - keep tacking on headers'
                });
                
                if (tacksOnLifts > tacksOnHeaders) {
                    tackTimingAnalysis.push({
                        metric: 'Tacks on Lifts',
                        value: `${tacksOnLifts} tacks during favorable conditions`,
                        assessment: 'concerning',
                        recommendation: 'Avoid tacking when lifted - stay on the lifted tack as long as possible'
                    });
                }
            }
            
            analysis.tackTiming = {
                onHeaders: tacksOnHeaders,
                onLifts: tacksOnLifts,
                neutral: tacksNeutral,
                score: tackTimingScore,
                analysis: tackTimingAnalysis
            };
            
            console.log(`‚öì Heel by wind: Light ${optimalHeelLightAir}¬∞ (${lightAir.length} pts), Moderate ${optimalHeelModerateAir}¬∞ (${moderateAir.length} pts)`);
            console.log(`‚öì Leeway: ${avgLeeway.toFixed(1)}¬∞ - ${analysis.leewayAnalysis.concernLevel.toUpperCase()}`);

            // CALCULATE POINTING ANGLE (tightest TWA with good VMG)
            const tightUpwind = upwind.filter(r => r.vmg > 0);
            const twaByAngle = {};
            tightUpwind.forEach(r => {
                const twa = Math.abs(r.twa_cog);
                const bin = Math.round(twa / 2) * 2;
                if (!twaByAngle[bin]) twaByAngle[bin] = [];
                twaByAngle[bin].push(r.vmg);
            });
            
            let bestPointingAngle = 45; // Default for Melges 15
            let bestPointingVMG = 0;
            
            // Find tightest angle where we still maintain good VMG (>90% of max)
            for (let angle = 30; angle <= 55; angle += 2) {
                if (!twaByAngle[angle] || twaByAngle[angle].length < 30) continue;
                const avgVMG = twaByAngle[angle].reduce((a, b) => a + b, 0) / twaByAngle[angle].length;
                if (avgVMG > bestPointingVMG * 0.9 && avgVMG > 0) {
                    bestPointingAngle = angle;
                    bestPointingVMG = Math.max(bestPointingVMG, avgVMG);
                }
            }
            
            // Laylines calculation - these are GEOGRAPHIC LINES from a mark
            const detectedWindDir = predominantHeadings.estimatedWindDir;
            
            analysis.laylines = {
                pointingAngle: bestPointingAngle,
                pointingVMG: bestPointingVMG,
                windDirection: detectedWindDir,
                // These are the HEADINGS of the laylines (lines extending from mark)
                portLaylineHeading: (detectedWindDir + bestPointingAngle) % 360,
                starboardLaylineHeading: (detectedWindDir - bestPointingAngle + 360) % 360,
                // These are the headings YOU sail when ON the layline
                portTackHeading: (detectedWindDir + bestPointingAngle) % 360,
                starboardTackHeading: (detectedWindDir - bestPointingAngle + 360) % 360,
                needsMark: true // Indicates user needs to place mark for actual laylines
            };
            
            console.log(`üìê Pointing: Best ${bestPointingAngle}¬∞ TWA @ ${bestPointingVMG.toFixed(2)} VMG`);
            console.log(`‚õµ Tack timing: ${tacksOnHeaders} on headers, ${tacksOnLifts} on lifts, ${tacksNeutral} neutral`);

            // STORE RACE RESULTS FOR COMPARISON
            if (selectedRace !== 'all') {
                raceResults[selectedRace] = {
                    raceId: selectedRace,
                    avgVMG: avgVMG,
                    bestVMG: bestVMGUp,
                    vmgEfficiency: vmgEfficiency,
                    tackEfficiency: analysis.tackEfficiency,
                    avgUpwindSpeed: avgUpwindSpeed,
                    optimalHeelUp: bestHeelUp,
                    leeway: avgLeeway,
                    tacksCount: tacks.length,
                    tackTimingScore: analysis.tackTiming.score,
                    boatHandlingScore: boatHandlingScore,
                    dataPoints: processedData.length
                };
            }

            // MULTI-RACE COMPARISON ANALYSIS
            const raceKeys = Object.keys(raceResults);
            if (raceKeys.length > 1) {
                const sortedByVMG = raceKeys.sort((a, b) => raceResults[b].avgVMG - raceResults[a].avgVMG);
                const bestRaceKey = sortedByVMG[0];
                const worstRaceKey = sortedByVMG[sortedByVMG.length - 1];
                
                const improvement = raceKeys.map((key, idx) => ({
                    race: key,
                    order: idx + 1,
                    vmg: raceResults[key].avgVMG,
                    tackEff: raceResults[key].tackEfficiency,
                    handling: raceResults[key].boatHandlingScore
                }));
                
                // Calculate consistency (coefficient of variation)
                const vmgs = raceKeys.map(k => raceResults[k].avgVMG);
                const avgVMGAll = vmgs.reduce((a, b) => a + b, 0) / vmgs.length;
                const stdDev = Math.sqrt(vmgs.map(v => Math.pow(v - avgVMGAll, 2)).reduce((a, b) => a + b) / vmgs.length);
                const consistency = stdDev / avgVMGAll * 100;
                
                analysis.multiRaceComparison = {
                    racesAnalyzed: raceKeys.length,
                    bestRace: {
                        id: bestRaceKey,
                        ...raceResults[bestRaceKey]
                    },
                    worstRace: {
                        id: worstRaceKey,
                        ...raceResults[worstRaceKey]
                    },
                    improvement: improvement,
                    consistency: {
                        vmgVariation: consistency,
                        assessment: consistency < 5 ? 'excellent' : consistency < 10 ? 'good' : consistency < 15 ? 'moderate' : 'inconsistent'
                    },
                    keyDifferences: []
                };
                
                // Identify key differences
                const best = raceResults[bestRaceKey];
                const worst = raceResults[worstRaceKey];
                
                if (best.tackEfficiency - worst.tackEfficiency > 10) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Tack Efficiency',
                        difference: `${(best.tackEfficiency - worst.tackEfficiency).toFixed(0)}% better in best race`,
                        impact: 'High - smoother tacks = more speed retention'
                    });
                }
                
                if (Math.abs(best.optimalHeelUp - worst.optimalHeelUp) > 5) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Heel Angle Consistency',
                        difference: `${best.optimalHeelUp}¬∞ vs ${worst.optimalHeelUp}¬∞ - ${Math.abs(best.optimalHeelUp - worst.optimalHeelUp).toFixed(0)}¬∞ variation`,
                        impact: 'Medium - indicates inconsistent technique or conditions'
                    });
                }
                
                if (best.tackTimingScore - worst.tackTimingScore > 20) {
                    analysis.multiRaceComparison.keyDifferences.push({
                        metric: 'Tack Timing',
                        difference: `${(best.tackTimingScore - worst.tackTimingScore).toFixed(0)}% better wind shift awareness`,
                        impact: 'High - tacking on headers is critical for upwind speed'
                    });
                }
                
                console.log(`üèÜ Multi-race: Best=${bestRaceKey} (VMG ${best.avgVMG.toFixed(2)}), Worst=${worstRaceKey} (VMG ${worst.avgVMG.toFixed(2)}), Consistency=${consistency.toFixed(1)}%`);
            }

            console.log("‚úÖ Analysis complete");

            console.log("‚úÖ Analysis complete");
            console.log(`üìà Boat Handling: ${boatHandlingScore.toFixed(0)} (Tack:${tackScore.toFixed(0)} Leeway:${leewayScore.toFixed(0)} Dist:${distScore.toFixed(0)})`);
            console.log(`‚¨ÜÔ∏è Upwind optimal: ${bestHeelUp}¬∞ heel, ${bestTrimUp}¬∞ trim`);
            console.log(`‚¨áÔ∏è Downwind optimal: ${bestHeelDown}¬∞ heel, ${bestTrimDown}¬∞ trim`);
            
            // Show new controls
            document.getElementById('maneuverTuner').style.display = 'block';
            document.getElementById('heelOptions').style.display = 'block';
            document.getElementById('generatePDF').style.display = 'block';
            document.getElementById('pdfNote').style.display = 'block';
            
            // Test that button is clickable
            setTimeout(() => {
                const pdfBtn = document.getElementById('generatePDF');
                console.log("üìÑ PDF button element:", pdfBtn);
                console.log("üìÑ Button visible:", pdfBtn.offsetParent !== null);
                console.log("üìÑ Button disabled:", pdfBtn.disabled);
            }, 100);
            
            displayResults();
        }

        function generateSuggestions(metrics) {
            const suggestions = [];

            // Critical issues (score impact > 20 points each)
            if (metrics.avgLeeway > 12) {
                suggestions.push({
                    priority: 'CRITICAL',
                    icon: 'üö®',
                    title: 'Severe Leeway Problem',
                    issue: `${metrics.avgLeeway.toFixed(1)}¬∞ leeway is costing you ~${((metrics.avgLeeway - 5) * 5).toFixed(0)} points`,
                    actions: [
                        'Sail MUCH flatter - target ' + metrics.bestHeelUp + '¬∞ heel (you are probably over 15-20¬∞)',
                        'Check centerboard is FULLY down and not damaged',
                        'Clean bottom immediately - growth adds massive leeway',
                        'Ease sheets 2-3¬∞ and foot off to build speed before pointing'
                    ]
                });
            } else if (metrics.avgLeeway > 8) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: '‚ö†Ô∏è',
                    title: 'High Leeway',
                    issue: `${metrics.avgLeeway.toFixed(1)}¬∞ leeway is costing ${((metrics.avgLeeway - 5) * 5).toFixed(0)} points`,
                    actions: [
                        'Sail flatter - target ' + metrics.bestHeelUp + '¬∞ heel',
                        'Check centerboard position',
                        'Verify sail trim is not too tight'
                    ]
                });
            }

            // Tack efficiency
            if (metrics.tackEfficiency < 75 && metrics.avgTackLoss > 20) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: 'üîÑ',
                    title: 'Poor Tack Execution',
                    issue: `${metrics.tackEfficiency.toFixed(0)}% efficiency, losing ${metrics.avgTackLoss.toFixed(1)}m per tack`,
                    actions: [
                        'Tack from full speed (do not pinch before tacking)',
                        'Smooth helm - count to 3 during turn',
                        'Sheet in AS bow crosses wind (not before, not after)',
                        'Hike immediately as boat flattens on new tack',
                        'Foot off 2-3¬∞ to rebuild speed before pointing'
                    ]
                });
            } else if (metrics.tackEfficiency < 85) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üîÑ',
                    title: 'Tack Efficiency',
                    issue: `${metrics.tackEfficiency.toFixed(0)}% efficiency, ${metrics.avgTackLoss.toFixed(1)}m loss per tack`,
                    actions: [
                        'Practice smooth helmsmanship',
                        'Time sheet trim with wind crossing bow',
                        'Early hiking on exit'
                    ]
                });
            }

            // VMG consistency
            if (metrics.vmgEfficiency < 70) {
                suggestions.push({
                    priority: 'HIGH',
                    icon: 'üìâ',
                    title: 'Inconsistent VMG',
                    issue: `Only ${metrics.vmgEfficiency.toFixed(0)}% of optimal VMG - you CAN sail faster`,
                    actions: [
                        'Your top 10% shows ' + metrics.bestVMG + ' kts VMG is possible',
                        'Maintain ' + metrics.bestHeelUp + '¬∞ heel consistently',
                        'Set optimal trim (' + (metrics.bestTrimUp > 0 ? '+' : '') + metrics.bestTrimUp + '¬∞ bow up/down) and leave it',
                        'Stop pinching - maintain speed over pointing',
                        'Use telltales: both streaming = good, luffing = too tight'
                    ]
                });
            } else if (metrics.vmgEfficiency < 80) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üìä',
                    title: 'VMG Consistency',
                    issue: `${metrics.vmgEfficiency.toFixed(0)}% efficiency - room to improve`,
                    actions: [
                        'Focus on maintaining optimal heel angle',
                        'Minimize steering corrections',
                        'Develop "feel" for optimal groove'
                    ]
                });
            }

            // Time in optimal zone
            if (metrics.timeInZone < 40) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: '‚è±Ô∏è',
                    title: 'Setup Inconsistency',
                    issue: `Only ${metrics.timeInZone.toFixed(0)}% of time in optimal zone`,
                    actions: [
                        'Target: ' + metrics.bestHeelUp + '¬∞ heel ¬±3¬∞',
                        'Target: ' + (metrics.bestTrimUp > 0 ? '+' : '') + metrics.bestTrimUp + '¬∞ trim ¬±3¬∞',
                        'Make SMALL adjustments constantly vs big corrections',
                        'Visual cue: mark optimal heel with tape on boat'
                    ]
                });
            }

            // Distance efficiency
            if (metrics.distanceEfficiency < 65) {
                suggestions.push({
                    priority: 'MEDIUM',
                    icon: 'üìè',
                    title: 'Poor Course Management',
                    issue: `${metrics.distanceEfficiency.toFixed(0)}% distance efficiency - sailing extra distance`,
                    actions: [
                        'Reduce tack count - plan your shifts',
                        'Do not overstand laylines (approach with 5¬∞ safety margin)',
                        'Tack on headers, sail lifts longer',
                        'Each unnecessary tack costs ' + metrics.avgTackLoss.toFixed(1) + 'm'
                    ]
                });
            }

            // Port/Starboard balance
            if (Math.abs(metrics.portPercent - metrics.starboardPercent) > 20) {
                const favored = metrics.portPercent > metrics.starboardPercent ? 'port' : 'starboard';
                suggestions.push({
                    priority: 'LOW',
                    icon: '‚öñÔ∏è',
                    title: 'Tack Imbalance',
                    issue: `Heavily favored ${favored} tack (${Math.max(metrics.portPercent, metrics.starboardPercent).toFixed(0)}%)`,
                    actions: [
                        'If intentional (persistent shift): Good strategy!',
                        'If unintentional: Sailing wrong angles or missing shifts',
                        'Check for current pushing you to one side'
                    ]
                });
            }

            // Speed ratio
            if (metrics.speedRatio < 1.15) {
                suggestions.push({
                    priority: 'LOW',
                    icon: 'üèÉ',
                    title: 'Weak Downwind Speed',
                    issue: `Speed ratio ${metrics.speedRatio.toFixed(2)}x - not much faster downwind`,
                    actions: [
                        'Ease sheets more downwind',
                        'Sail lower angles (140-160¬∞ TWA)',
                        'May be over-trimming offwind'
                    ]
                });
            }

            // If score is good, congratulate
            if (metrics.boatHandlingScore >= 80) {
                suggestions.push({
                    priority: 'GOOD',
                    icon: 'üèÜ',
                    title: 'Excellent Performance!',
                    issue: 'Score of ' + metrics.boatHandlingScore.toFixed(0) + '/100 is very competitive',
                    actions: [
                        'Keep doing what you are doing',
                        'Focus on marginal gains',
                        'Compare your polar to class targets'
                    ]
                });
            }

            return suggestions.sort((a, b) => {
                const priority = { 'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'GOOD': 4 };
                return priority[a.priority] - priority[b.priority];
            });
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const œÜ1 = lat1 * Math.PI / 180;
            const œÜ2 = lat2 * Math.PI / 180;
            const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
            const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        function displayResults() {
            if (!analysis) return;

            document.getElementById('sessionInfo').classList.remove('hidden');
            document.getElementById('dataPoints').textContent = `Data points: ${analysis.dataPoints.toLocaleString()}`;
            document.getElementById('dataQuality').innerHTML = `
                <div class="text-xs mt-1">Quality: ${analysis.upwindSample.length > 500 ? '‚úÖ Excellent' : analysis.upwindSample.length > 200 ? 'üü° Good' : '‚ö†Ô∏è Limited'}</div>
            `;

            const mainContent = document.getElementById('mainContent');
            mainContent.innerHTML = `
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-3xl font-bold">Performance Summary</h2>
                    <button id="pdfButtonMain" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-semibold text-sm shadow-lg">
                        üìÑ PDF Report
                    </button>
                </div>
                
                <!-- Top scores -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(30, 58, 138, 0.9), rgba(30, 64, 175, 0.7)); border-color: rgba(37, 99, 235, 0.8);">
                        <div class="text-2xl font-bold text-blue-300 mb-3">
                            üèÜ Boat Handling Score
                            ${helpIcon(`<strong>Boat Handling: ${analysis.boatHandlingScore.toFixed(0)}/100</strong><br/>Composite score combining:<br/>‚Ä¢ Tack efficiency (40%)<br/>‚Ä¢ Leeway control (30%)<br/>‚Ä¢ Distance efficiency (30%)`)}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.boatHandlingScore.toFixed(0)}
                            ${metricBadge(analysis.boatHandlingScore, 80, 70)}
                        </div>
                        <div class="text-xl font-semibold ${analysis.boatHandlingScore >= 80 ? 'text-green-400' : analysis.boatHandlingScore >= 60 ? 'text-yellow-400' : 'text-orange-400'}">
                            ${analysis.boatHandlingScore >= 80 ? '‚úÖ Excellent' : analysis.boatHandlingScore >= 60 ? 'üü° Good' : '‚ö†Ô∏è Needs Work'}
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Combined performance grade</div>
                        ${expandableHelp('How is boat handling scored?', `
                            <p><strong>Formula: Weighted Average</strong></p>
                            <code>Score = 0.4√óTackScore + 0.3√óLeewayScore + 0.3√óDistScore</code>
                            
                            <p><strong>Component Calculations:</strong></p>
                            <ul>
                                <li><strong>Tack Score:</strong> (Tack Efficiency - 70) √ó 3.33, scaled 0-100
                                    <br/>Your tack efficiency: ${analysis.tackEfficiency ? analysis.tackEfficiency.toFixed(0) : 'N/A'}%</li>
                                <li><strong>Leeway Score:</strong> 100 - (Leeway √ó 5), lower leeway = higher score
                                    <br/>Your leeway: ${analysis.leewayAnalysis ? analysis.leewayAnalysis.average.toFixed(1) : 'N/A'}¬∞</li>
                                <li><strong>Distance Score:</strong> Efficiency of course sailed
                                    <br/>Your distance efficiency: ${analysis.distanceEfficiency ? analysis.distanceEfficiency.toFixed(0) : 'N/A'}%</li>
                            </ul>
                            
                            <p><strong>Score Interpretation:</strong></p>
                            <ul>
                                <li><strong>80-100:</strong> Excellent fundamentals, focus on tactics</li>
                                <li><strong>70-80:</strong> Good basics, refine technique</li>
                                <li><strong>60-70:</strong> Competent, room for improvement</li>
                                <li><strong>&lt;60:</strong> Focus on boat handling drills</li>
                            </ul>
                            
                            <p><strong>Your score: ${analysis.boatHandlingScore.toFixed(0)}/100</strong> - ${
                                analysis.boatHandlingScore >= 80 ? 'Excellent handling! Your fundamentals are solid.' :
                                analysis.boatHandlingScore >= 70 ? 'Good handling with room to refine details.' :
                                analysis.boatHandlingScore >= 60 ? 'Competent but focus on improving key areas.' :
                                'Work on fundamentals: smooth tacks, minimize leeway, sail efficient course.'
                            }</p>
                        `)}
                    </div>

                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(88, 28, 135, 0.9), rgba(107, 33, 168, 0.7)); border-color: rgba(147, 51, 234, 0.8);">
                        <div class="text-2xl font-bold text-purple-300 mb-3">
                            VMG Efficiency
                            ${helpIcon(`<strong>VMG Efficiency: ${analysis.vmgEfficiency.toFixed(1)}%</strong><br/><br/>Your average VMG as % of your best VMG.<br/><br/>Shows consistency: Are you sailing at your peak most of the time?<br/><br/>Avg: ${analysis.avgVMG.toFixed(2)} kts<br/>Best: ${analysis.bestVMG.toFixed(2)} kts`)}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.vmgEfficiency.toFixed(0)}%
                            ${metricBadge(analysis.vmgEfficiency, 85, 75)}
                        </div>
                        <div class="text-xl font-semibold ${analysis.vmgEfficiency >= 85 ? 'text-green-400' : analysis.vmgEfficiency >= 75 ? 'text-yellow-400' : 'text-orange-400'}">
                            ${analysis.vmgEfficiency >= 85 ? '‚úÖ Excellent' : analysis.vmgEfficiency >= 75 ? 'üü° Good' : '‚ö†Ô∏è Fair'}
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Avg: ${analysis.avgVMG.toFixed(2)} / Best: ${analysis.bestVMG.toFixed(2)} kts</div>
                        ${expandableHelp('Understanding VMG efficiency', `
                            <p><strong>Formula:</strong></p>
                            <code>Efficiency = (Average VMG / Best VMG) √ó 100</code>
                            
                            <p><strong>Your Numbers:</strong></p>
                            <ul>
                                <li>Best VMG: ${analysis.bestVMG.toFixed(2)} kts (90th percentile)</li>
                                <li>Average VMG: ${analysis.avgVMG.toFixed(2)} kts</li>
                                <li>Efficiency: ${analysis.vmgEfficiency.toFixed(1)}%</li>
                            </ul>
                            
                            <p><strong>What this means:</strong></p>
                            <ul>
                                <li><strong>>85%:</strong> Very consistent, sailing at peak most of the time</li>
                                <li><strong>75-85%:</strong> Good consistency, some room to improve</li>
                                <li><strong>65-75%:</strong> Inconsistent, losing speed in many moments</li>
                                <li><strong>&lt;65%:</strong> Rarely achieving best performance, focus on technique</li>
                            </ul>
                            
                            <p><strong>How to improve:</strong> Identify when VMG drops (lulls? waves? mistakes?) and minimize those moments. The goal is to spend MORE time sailing at your "best VMG" level. Review wind shift timeline and heel consistency to find where you're losing speed.</p>
                            
                            <p><strong>Example:</strong> If you're at 75% efficiency, you're leaving 25% of potential speed on the table. Improving to 85% would gain you ~10 seconds per upwind leg!</p>
                        `)}
                    </div>

                    <div class="metric-card p-6 rounded-xl border-2" style="background: linear-gradient(to bottom right, rgba(120, 53, 15, 0.9), rgba(146, 64, 14, 0.7)); border-color: rgba(217, 119, 6, 0.8);">
                        <div class="text-2xl font-bold text-amber-300 mb-3">
                            ‚è±Ô∏è Time in Optimal Zone
                            ${helpIcon(`<strong>Time in Optimal Zone: ${analysis.timeInZone.toFixed(0)}%</strong><br/><br/>Percentage of time within ¬±3¬∞ of your optimal heel/trim.<br/><br/>Measures consistency: Can you hold the target angle?`)}
                        </div>
                        <div class="text-6xl font-bold text-white mb-3">
                            ${analysis.timeInZone.toFixed(0)}%
                            ${metricBadge(analysis.timeInZone, 60, 40)}
                        </div>
                        <div class="text-xl font-semibold ${analysis.timeInZone >= 60 ? 'text-green-400' : analysis.timeInZone >= 40 ? 'text-yellow-400' : 'text-orange-400'}">
                            ${analysis.timeInZone >= 60 ? '‚úÖ Excellent' : analysis.timeInZone >= 40 ? 'üü° Good' : '‚ö†Ô∏è Fair'}
                        </div>
                        <div class="text-base font-medium text-white opacity-80 mt-2">Within ¬±3¬∞ optimal</div>
                        ${expandableHelp('What is the optimal zone?', `
                            <p><strong>Definition:</strong></p>
                            <ul>
                                <li>Optimal heel: ${analysis.optimalHeelUp}¬∞</li>
                                <li>Optimal trim: ${analysis.optimalTrimUp}¬∞</li>
                                <li>Zone: Within ¬±3¬∞ of both optimal values</li>
                                <li>¬±3¬∞ allows for waves, puffs, steering adjustments</li>
                            </ul>
                            
                            <p><strong>Your Data:</strong></p>
                            <ul>
                                <li>${analysis.timeInZone.toFixed(0)}% of time in optimal zone</li>
                                <li>This means you're sailing with ideal heel/trim ${analysis.timeInZone.toFixed(0)}% of the time</li>
                            </ul>
                            
                            <p><strong>Interpretation:</strong></p>
                            <ul>
                                <li><strong>>60%:</strong> Excellent consistency, technique locked in</li>
                                <li><strong>40-60%:</strong> Good control, some variation</li>
                                <li><strong>20-40%:</strong> Inconsistent heel/trim control</li>
                                <li><strong>&lt;20%:</strong> Heel and trim all over the place, focus here</li>
                            </ul>
                            
                            <p><strong>Why ¬±3¬∞?</strong> This is a reasonable range that accounts for waves, puffs, and steering adjustments while still maintaining good performance. Tighter tolerance (¬±2¬∞) would be unrealistic in real conditions. Wider tolerance (¬±5¬∞) wouldn't be "optimal zone" anymore.</p>
                            
                            <p><strong>How to improve:</strong> Use tactile feedback (crew weight placement, sheet tension) to stay in the zone more consistently. Practice holding ${analysis.optimalHeelUp}¬∞ heel in different conditions until it becomes automatic.</p>
                        `)}
                    </div>
                </div>

                <!-- Detailed metrics -->
                <h3 class="text-2xl font-bold mb-4">Detailed Metrics</h3>
                <div class="grid grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
                    ${createMetricCard('‚¨ÜÔ∏è Optimal Heel UP', `${analysis.optimalHeelUp}¬∞`, 'COG-based upwind', 'green')}
                    ${createMetricCard('‚¨áÔ∏è Optimal Heel DOWN', `${analysis.optimalHeelDown}¬∞`, 'COG-based downwind', 'emerald')}
                    ${createMetricCard('‚¨ÜÔ∏è Optimal Trim UP', `${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞`, 'Bow up/down upwind', 'teal')}
                    ${createMetricCard('‚¨áÔ∏è Optimal Trim DOWN', `${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞`, 'Bow up/down downwind', 'cyan')}
                    ${createMetricCard('üéØ Best Pointing', `${analysis.bestPointing.toFixed(1)}¬∞`, analysis.bestPointing < 35 ? '‚úÖ Excellent' : 'üü° Good', 'cyan')}
                    ${createMetricCard('üìê Leeway', `${analysis.leeway.toFixed(1)}¬∞`, analysis.leeway < 8 ? 'üü° Good' : '‚ö†Ô∏è High', 'orange')}
                    ${createMetricCard('üîÑ Tack Efficiency', `${analysis.tackEfficiency.toFixed(0)}%`, `${analysis.tacksCount} tacks`, 'yellow')}
                    ${createMetricCard('üîÑ Gybe Efficiency', `${analysis.gybeEfficiency.toFixed(0)}%`, `${analysis.gybesCount} gybes`, 'amber')}
                    ${createMetricCard('üìè Distance Eff', `${analysis.distanceEfficiency.toFixed(0)}%`, analysis.distanceEfficiency >= 70 ? '‚úÖ Good' : 'üü° Fair', 'indigo')}
                </div>

                ${analysis.coachingTips && analysis.coachingTips.length > 0 ? `
                <div class="mb-8 bg-gray-800 p-6 rounded-xl border border-gray-700">
                    <h3 class="text-xl font-bold mb-4">üéØ Coaching Tips</h3>
                    <div class="space-y-3">
                        ${analysis.coachingTips.map(tip => `
                            <div class="coaching-tip pl-4 py-3 bg-gray-700 rounded">
                                <div class="flex justify-between items-start mb-1">
                                    <div class="font-semibold text-sm ${tip.priority === 'high' ? 'text-red-400' : 'text-yellow-400'}">${tip.category}</div>
                                    <div class="text-xs px-2 py-1 rounded ${tip.priority === 'high' ? 'bg-red-900 text-red-300' : 'bg-yellow-900 text-yellow-300'}">${tip.priority}</div>
                                </div>
                                <div class="text-sm text-gray-300 mb-2">${tip.message}</div>
                                <div class="text-xs text-green-400 font-semibold">Potential gain: ${tip.impact}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : `
                <div class="mb-8 bg-gray-800 p-6 rounded-xl border border-green-700">
                    <h3 class="text-xl font-bold mb-4">üéØ What to do next</h3>
                    <div class="text-green-400 font-semibold mb-2">‚úÖ Excellent performance! No critical issues detected.</div>
                    <div class="text-sm text-gray-400">
                        Your sailing metrics look good. Keep refining your technique and focus on:
                        <ul class="list-disc ml-5 mt-2 space-y-1">
                            <li>Maintaining optimal heel angle: ${analysis.optimalHeelUp}¬∞ upwind</li>
                            <li>Consistent tack execution (current avg: ${analysis.tackEfficiency.toFixed(0)}%)</li>
                            <li>Maximizing time on favorable wind shifts</li>
                        </ul>
                    </div>
                </div>
                `}

                <div class="grid grid-cols-2 gap-6 mb-8">
                    <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                        <h3 class="text-lg font-semibold mb-3">üå¨Ô∏è Wind Shift Analysis</h3>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Time on Lifts:</span>
                                <span class="text-green-400 font-semibold">${analysis.windAnalysis.liftPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Time on Headers:</span>
                                <span class="text-red-400 font-semibold">${analysis.windAnalysis.headerPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Avg Lift Angle:</span>
                                <span class="text-white">${analysis.windAnalysis.avgLiftAngle.toFixed(1)}¬∞</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Avg Header Angle:</span>
                                <span class="text-white">${analysis.windAnalysis.avgHeaderAngle.toFixed(1)}¬∞</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-gray-800 p-4 rounded-xl border border-gray-700">
                        <h3 class="text-lg font-semibold mb-3">üìä Course Bias</h3>
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Port Tack:</span>
                                <span class="font-semibold text-white">${analysis.courseBias.portPct.toFixed(1)}%</span>
                            </div>
                            <div class="flex justify-between">
                                <span class="text-white opacity-70">Starboard Tack:</span>
                                <span class="font-semibold text-white">${analysis.courseBias.starboardPct.toFixed(1)}%</span>
                            </div>
                            <div class="mt-3 pt-3 border-t border-gray-600 text-xs text-white opacity-80">
                                ${Math.abs(analysis.courseBias.portPct - 50) > 20 ? 
                                    `‚ö†Ô∏è Significant bias toward ${analysis.courseBias.portPct > 50 ? 'port' : 'starboard'}` : 
                                    '‚úÖ Well balanced course'}
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mb-8 bg-gray-800 p-4 rounded-xl border border-gray-700">
                    <h3 class="text-lg font-semibold mb-3">üß≠ Predominant Headings (Auto-detected TWA)</h3>
                    <div class="grid grid-cols-2 gap-4 mb-3">
                        <div>
                            <div class="text-sm text-gray-400">Starboard Tack Heading</div>
                            <div class="text-2xl font-bold text-green-400">${analysis.predominantHeadings.peak1}¬∞</div>
                            <div class="text-xs text-gray-500">${analysis.predominantHeadings.peak1Count} samples</div>
                        </div>
                        <div>
                            <div class="text-sm text-gray-400">Port Tack Heading</div>
                            <div class="text-2xl font-bold text-blue-400">${analysis.predominantHeadings.peak2}¬∞</div>
                            <div class="text-xs text-gray-500">${analysis.predominantHeadings.peak2Count} samples</div>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-4 p-3 bg-gray-700 rounded">
                        <div>
                            <div class="text-xs text-gray-400">Wind Direction (FROM)</div>
                            <div class="text-xl font-bold text-yellow-400">${analysis.predominantHeadings.estimatedWindDir.toFixed(0)}¬∞ ${getCompassDirection(analysis.predominantHeadings.estimatedWindDir)}</div>
                            <div class="text-xs text-gray-500 mt-1">Bisector of tack headings</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-400">Average TWA</div>
                            <div class="text-xl font-bold text-yellow-400">${analysis.predominantHeadings.avgTWA.toFixed(0)}¬∞</div>
                        </div>
                    </div>
                    <div class="mt-3 text-xs ${analysis.predominantHeadings.confidence === 'high' ? 'text-green-400' : analysis.predominantHeadings.confidence === 'medium' ? 'text-yellow-400' : 'text-red-400'}">
                        Confidence: ${analysis.predominantHeadings.confidence.toUpperCase()} ${analysis.predominantHeadings.confidence !== 'high' ? '‚ö†Ô∏è Consider manually adjusting wind direction slider for more accurate TWA' : '‚úÖ'}
                    </div>
                    <div class="mt-3 p-3 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <div class="text-xs text-yellow-400 font-semibold mb-1">‚ö†Ô∏è IMPORTANT: Verify Wind Direction</div>
                        <div class="text-xs text-gray-300">
                            Auto-detection uses GPS headings and may be incorrect due to:
                            <ul class="list-disc ml-4 mt-1">
                                <li>Pre-race maneuvering included in time boundaries</li>
                                <li>GPS noise or missing data points</li>
                                <li>Downwind legs contaminating upwind detection</li>
                            </ul>
                            <strong class="text-yellow-400">Always verify against your on-water experience!</strong> Use the wind direction slider above to manually adjust if needed.
                        </div>
                    </div>
                </div>

                <!-- Wind Rose Visualization -->
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">üß≠ Heading Distribution (Wind Rose)</h3>
                    <div class="flex justify-center">
                        <canvas id="windRose" width="400" height="400"></canvas>
                    </div>
                    <div class="text-xs text-gray-400 text-center mt-3">
                        Blue = Port tack ‚Ä¢ Green = Starboard tack ‚Ä¢ Yellow arrow = Wind direction
                    </div>
                </div>

                <!-- Laylines Display -->
                ${analysis.laylines ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        üìê Layline Calculator
                        ${helpIcon(`<strong>What's a Layline?</strong><br/>A geographic line extending from the windward mark. When you cross it, tack and sail directly to the mark at your pointing angle (${analysis.laylines.pointingAngle}¬∞) without being overstood or understood.<br/><br/><strong>How it's calculated:</strong><br/>1. Find your best pointing angle (tightest TWA with good VMG)<br/>2. Port layline = Wind direction - pointing angle<br/>3. Starboard layline = Wind direction + pointing angle<br/>4. Lines extend from mark at these headings`)}
                    </h3>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div>
                            <div class="flex justify-center mb-4">
                                <canvas id="laylinesCanvas" width="300" height="300"></canvas>
                            </div>
                            <div class="text-xs text-gray-400 text-center">
                                Yellow = Wind ‚Ä¢ Blue = Port layline ‚Ä¢ Green = Starboard layline
                            </div>
                        </div>
                        <div class="space-y-4">
                            <div class="p-4 bg-gray-700 rounded">
                                <div class="text-sm text-gray-400">Your Best Pointing Angle</div>
                                <div class="text-3xl font-bold text-yellow-400">
                                    ${analysis.laylines.pointingAngle}¬∞
                                    ${metricBadge(analysis.laylines.pointingAngle, 42, 47, false)}
                                    ${helpIcon(`<strong>Your Best Pointing Angle:</strong> ${analysis.laylines.pointingAngle}¬∞<br/><br/>This is the tightest TWA you can sail while maintaining good VMG (>90% of max). Based on analysis of actual upwind sailing data.`)}
                                </div>
                                <div class="text-xs text-gray-500 mt-1">Tightest TWA with good VMG</div>
                            </div>
                            
                            ${expandableHelp('How is pointing angle determined?', `
                                <p><strong>Method: Tightest angle with good VMG</strong></p>
                                <ul>
                                    <li>Analyzes all upwind sailing at different TWAs (30-55¬∞)</li>
                                    <li>For each angle, calculates average VMG</li>
                                    <li>Finds tightest angle where VMG stays >90% of maximum</li>
                                    <li>Result: ${analysis.laylines.pointingAngle}¬∞ from your actual data</li>
                                </ul>
                                <p><strong>Why this matters:</strong> This is YOUR proven closehauled angle from real sailing, not a theoretical number. Use it for layline calculations and race strategy.</p>
                                <p><strong>Typical values:</strong></p>
                                <ul>
                                    <li>Melges 15: 42-47¬∞ (you're at ${analysis.laylines.pointingAngle}¬∞)</li>
                                    <li>420: 40-45¬∞</li>
                                    <li>Laser: 38-43¬∞</li>
                                </ul>
                            `)}
                            
                            <div class="p-4 bg-blue-900 bg-opacity-30 rounded border border-blue-600">
                                <div class="text-sm font-semibold text-blue-300 mb-2">üìç To Calculate Actual Laylines:</div>
                                <ol class="text-xs text-gray-300 list-decimal ml-4 space-y-1">
                                    <li>Download full version (has GPS map)</li>
                                    <li>Click "Place Windward Mark" button</li>
                                    <li>Click on map where mark is located</li>
                                    <li>Laylines will draw from mark automatically</li>
                                </ol>
                            </div>
                            
                            <div class="grid grid-cols-2 gap-3">
                                <div class="p-3 bg-gray-700 rounded">
                                    <div class="text-xs text-gray-400">When On Port Layline</div>
                                    <div class="text-xl font-bold text-blue-400">Sail ${analysis.laylines.portTackHeading.toFixed(0)}¬∞</div>
                                    <div class="text-xs text-gray-500 mt-1">To reach mark</div>
                                </div>
                                <div class="p-3 bg-gray-700 rounded">
                                    <div class="text-xs text-gray-400">When On Stbd Layline</div>
                                    <div class="text-xl font-bold text-green-400">Sail ${analysis.laylines.starboardTackHeading.toFixed(0)}¬∞</div>
                                    <div class="text-xs text-gray-500 mt-1">To reach mark</div>
                                </div>
                            </div>
                            
                            <div class="text-xs text-gray-400 p-3 bg-gray-700 rounded">
                                <strong>üí° What is a layline?</strong> A geographic line from the mark. When you cross it, you can tack and sail directly to the mark at ${analysis.laylines.pointingAngle}¬∞ TWA without being overstood or understood.
                            </div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Wind Shift Timeline -->
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">üìà Wind Shift Timeline</h3>
                    <div class="chart-container" style="height: 250px;">
                        <canvas id="windShiftTimeline"></canvas>
                    </div>
                    <div class="text-xs text-gray-400 mt-3">
                        <span class="text-green-400">Green peaks</span> = Lifts (favorable) ‚Ä¢ 
                        <span class="text-red-400">Red valleys</span> = Headers (unfavorable) ‚Ä¢ 
                        <span style="background: rgba(16, 185, 129, 0.2); padding: 2px 6px; border-radius: 3px;">Green background</span> = Upwind ‚Ä¢ 
                        <span style="background: rgba(59, 130, 246, 0.2); padding: 2px 6px; border-radius: 3px;">Blue background</span> = Downwind ‚Ä¢
                        <span class="text-yellow-400">‚õµ Yellow dashed lines</span> = Tacks
                    </div>
                </div>

                <!-- Heel by Wind Speed Analysis -->
                ${analysis.heelByWindSpeed && (analysis.heelByWindSpeed.lightAir.samples > 100 || analysis.heelByWindSpeed.moderateAir.samples > 100) ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        üéØ Optimal Heel by Wind Strength
                        ${helpIcon(`<strong>Optimal Heel by Condition</strong><br/>Your boat's best heel angle based on actual VMG data, calculated separately for light and moderate air. This accounts for how your boat performs in different wind strengths.`)}
                    </h3>
                    <div class="grid grid-cols-2 gap-4">
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Light Air (5-10 kts TWS)</div>
                            <div class="text-3xl font-bold text-blue-400">
                                ${analysis.heelByWindSpeed.lightAir.optimal}¬∞
                                ${metricBadge(analysis.heelByWindSpeed.lightAir.optimal, 18, 22)}
                                ${helpIcon(`<strong>Light Air Heel:</strong> ${analysis.heelByWindSpeed.lightAir.optimal}¬∞<br/><br/>Based on ${analysis.heelByWindSpeed.lightAir.samples} data points in 5-10 kts TWS. This is where your top 10% VMG performance occurs most often in light conditions.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">${analysis.heelByWindSpeed.lightAir.samples} samples</div>
                            <div class="text-xs text-gray-400 mt-2">
                                üí° More heel acceptable in light air - reduces wetted surface, helps sail shape
                            </div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Moderate Air (10-15 kts TWS)</div>
                            <div class="text-3xl font-bold text-green-400">
                                ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞
                                ${metricBadge(analysis.heelByWindSpeed.moderateAir.optimal, 15, 20)}
                                ${helpIcon(`<strong>Moderate Air Heel:</strong> ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞<br/><br/>Based on ${analysis.heelByWindSpeed.moderateAir.samples} data points in 10-15 kts TWS. Typically flatter than light air to minimize leeway and maximize power.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">${analysis.heelByWindSpeed.moderateAir.samples} samples</div>
                            <div class="text-xs text-gray-400 mt-2">
                                üí° Flatter sailing in breeze - minimizes leeway, maximizes righting moment
                            </div>
                        </div>
                    </div>
                    ${expandableHelp('How is optimal heel calculated?', `
                        <p><strong>Method: 90th Percentile Binning by Wind Strength</strong></p>
                        <ul>
                            <li>Data separated by boat speed (proxy for wind strength):
                                <ul>
                                    <li><strong>Light air:</strong> 3-5 kts boat speed ‚âà 5-10 kts TWS</li>
                                    <li><strong>Moderate air:</strong> 5-7 kts boat speed ‚âà 10-15 kts TWS</li>
                                </ul>
                            </li>
                            <li>Heel angles grouped into 2¬∞ bins (0¬∞, 2¬∞, 4¬∞... 24¬∞)</li>
                            <li>For each bin, find the 90th percentile VMG (top 10% performance)</li>
                            <li>Optimal = bin with highest 90th percentile VMG</li>
                            <li>Requires minimum 50 samples per bin for reliability</li>
                        </ul>
                        <p><strong>Why 90th percentile?</strong> Represents your best achievable performance at that heel angle. Filters out poor moments (wind holes, waves, mistakes) while avoiding single outliers that "max" would pick up.</p>
                        <p><strong>Why trust this over theory?</strong> This is YOUR boat with YOUR crew weight (${analysis.heelByWindSpeed ? '~360 lbs for Melges 15' : 'your setup'}) and YOUR technique. Generic advice says 8-12¬∞ but your data shows what actually makes you fastest!</p>
                        <p><strong>Light vs Moderate Air:</strong></p>
                        <ul>
                            <li>Light: More heel OK (reduces wetted surface)</li>
                            <li>Moderate: Flatter sailing (minimizes leeway, maximizes power)</li>
                            <li>Your data: ${analysis.heelByWindSpeed.lightAir.optimal}¬∞ light, ${analysis.heelByWindSpeed.moderateAir.optimal}¬∞ moderate</li>
                        </ul>
                    `)}
                </div>
                ` : ''}

                <!-- Leeway Analysis -->
                ${analysis.leewayAnalysis && analysis.leewayAnalysis.diagnosis.length > 0 ? `
                <div class="bg-gray-800 p-6 rounded-xl border ${analysis.leewayAnalysis.concernLevel === 'critical' ? 'border-red-700' : 'border-yellow-700'} mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        ‚öì Leeway Analysis
                        ${helpIcon(`<strong>Leeway:</strong> Difference between heading (where bow points) and COG (where you actually go)<br/><br/><strong>Normal:</strong> 3-8¬∞ for dinghies<br/><strong>Warning:</strong> >15¬∞ usually indicates sensor calibration error, not actual side-slip!`)}
                    </h3>
                    <div class="mb-4 p-4 bg-gray-700 rounded">
                        <div class="text-sm text-gray-400">Average Leeway (COG - Heading)</div>
                        <div class="text-3xl font-bold ${analysis.leewayAnalysis.concernLevel === 'critical' ? 'text-red-400' : analysis.leewayAnalysis.concernLevel === 'moderate' ? 'text-yellow-400' : 'text-green-400'}">
                            ${analysis.leewayAnalysis.average.toFixed(1)}¬∞
                            ${metricBadge(analysis.leewayAnalysis.average, 6, 10, false)}
                        </div>
                        <div class="text-xs text-gray-500 mt-1">Normal range: 3-8¬∞ for well-sailed dinghy</div>
                    </div>
                    ${expandableHelp('How is leeway determined?', `
                        <p><strong>Formula:</strong></p>
                        <code>Leeway = COG - Heading</code>
                        <p>(with 360¬∞ wraparound correction)</p>
                        
                        <p><strong>What it measures:</strong></p>
                        <ul>
                            <li><strong>COG (Course Over Ground):</strong> Your actual GPS track through the water</li>
                            <li><strong>Heading:</strong> Where your bow is pointing from compass</li>
                            <li><strong>Difference:</strong> Side-slip caused by wind force on sails</li>
                        </ul>
                        
                        <p><strong>Your leeway: ${analysis.leewayAnalysis.average.toFixed(1)}¬∞</strong></p>
                        
                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li><strong>3-8¬∞:</strong> Normal for well-sailed dinghy</li>
                            <li><strong>8-15¬∞:</strong> High but possible (excessive heel? centerboard up?)</li>
                            <li><strong>>15¬∞:</strong> Almost certainly sensor calibration error</li>
                        </ul>
                        
                        <p><strong>If leeway seems too high (>15¬∞):</strong></p>
                        <ul>
                            <li>Check Vakaros magnetic declination setting for your location</li>
                            <li>Recalibrate compass (figure-8 pattern while holding Vakaros)</li>
                            <li>Test: Sail straight in light air - should show &lt;5¬∞ leeway</li>
                            <li>NOT actual side-slip if >20¬∞ - that's physically impossible!</li>
                        </ul>
                        
                        <p><strong>Physical reality check:</strong> A boat making 20¬∞ of actual side-slip would be moving almost sideways and would have terrible VMG. If your VMG is good, the leeway reading is wrong (sensor issue).</p>
                    `)}
                    <div class="space-y-3">
                        ${analysis.leewayAnalysis.diagnosis.map(d => `
                            <div class="p-3 bg-gray-700 rounded border-l-4 ${d.severity === 'critical' ? 'border-red-500' : d.severity === 'moderate' ? 'border-yellow-500' : 'border-blue-500'}">
                                <div class="font-semibold text-sm ${d.severity === 'critical' ? 'text-red-400' : d.severity === 'moderate' ? 'text-yellow-400' : 'text-blue-400'}">
                                    ${d.issue}
                                </div>
                                ${d.possibleCauses ? `
                                    <div class="text-xs text-gray-400 mt-2">
                                        <strong>Possible causes:</strong>
                                        <ul class="list-disc ml-5 mt-1 space-y-1">
                                            ${d.possibleCauses.map(cause => `<li>${cause}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                                ${d.data ? `<div class="text-xs text-gray-300 mt-2"><strong>Data:</strong> ${d.data}</div>` : ''}
                                <div class="text-xs text-green-400 mt-2">
                                    <strong>Recommendation:</strong> ${d.recommendation}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                ${!analysis.heelDataQuality.reliable ? `
                <div class="mb-8 bg-yellow-900 bg-opacity-20 border border-yellow-600 p-4 rounded-xl">
                    <div class="flex items-start gap-3">
                        <div class="text-2xl">‚ö†Ô∏è</div>
                        <div>
                            <div class="font-semibold text-yellow-400 mb-1">Limited Data Quality for Heel Optimization</div>
                            <div class="text-sm text-gray-300">Only ${analysis.heelDataQuality.upwindSamples} upwind samples. For reliable heel angle recommendations, you need 500+ samples. The optimal heel of ${analysis.optimalHeelUp}¬∞ may not be accurate. Consider sailing more upwind legs or combining multiple races.</div>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Tack Timing Analysis -->
                ${analysis.tackTiming && analysis.tackTiming.analysis && analysis.tackTiming.analysis.length > 0 ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">
                        ‚õµ Tack Timing Analysis
                        ${helpIcon(`<strong>Tack Timing</strong><br/>Analyzes whether you tacked on headers (correct) or lifts (incorrect).<br/><br/><strong>Good racing:</strong> >60% of tacks on headers<br/><strong>Your score:</strong> ${analysis.tackTiming ? ((analysis.tackTiming.onHeaders / (analysis.tackTiming.onHeaders + analysis.tackTiming.onLifts + analysis.tackTiming.neutral)) * 100).toFixed(0) : 'N/A'}%`)}
                    </h3>
                    <div class="grid grid-cols-3 gap-4 mb-4">
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Tacks on Headers</div>
                            <div class="text-3xl font-bold text-green-400">
                                ${analysis.tackTiming.onHeaders}
                                ${helpIcon(`<strong>Headers:</strong> Unfavorable wind shifts that force you to point lower. Tacking on headers is CORRECT - you're getting off the bad shift.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Correct timing ‚úì</div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Tacks on Lifts</div>
                            <div class="text-3xl font-bold text-red-400">
                                ${analysis.tackTiming.onLifts}
                                ${helpIcon(`<strong>Lifts:</strong> Favorable wind shifts that let you point higher. Tacking on lifts is WRONG - you're giving up free advantage! Should stay on lift longer.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Avoid this ‚úó</div>
                        </div>
                        <div class="p-4 bg-gray-700 rounded">
                            <div class="text-sm text-gray-400">Neutral Tacks</div>
                            <div class="text-3xl font-bold text-gray-400">
                                ${analysis.tackTiming.neutral}
                                ${helpIcon(`<strong>Neutral:</strong> Tacks when wind shift was minimal (¬±3¬∞). Usually strategic decisions for laylines, traffic, or other tactical reasons.`)}
                            </div>
                            <div class="text-xs text-gray-500 mt-1">Strategic</div>
                        </div>
                    </div>
                    ${expandableHelp('How is tack timing analyzed?', `
                        <p><strong>Method:</strong></p>
                        <ul>
                            <li>For each tack, examines wind conditions 30 seconds before the maneuver</li>
                            <li>Calculates average TWA shift during that window</li>
                            <li>Classifies shift:
                                <ul>
                                    <li><strong>>3¬∞ header:</strong> Correct timing (should tack)</li>
                                    <li><strong>&lt;-3¬∞ lift:</strong> Incorrect timing (should stay)</li>
                                    <li><strong>-3¬∞ to +3¬∞:</strong> Neutral (strategic/tactical)</li>
                                </ul>
                            </li>
                        </ul>
                        
                        <p><strong>Your Results:</strong></p>
                        <ul>
                            <li>Tacks on headers: ${analysis.tackTiming.onHeaders} (‚úì correct)</li>
                            <li>Tacks on lifts: ${analysis.tackTiming.onLifts} (‚úó incorrect)</li>
                            <li>Neutral tacks: ${analysis.tackTiming.neutral}</li>
                            <li>Score: ${((analysis.tackTiming.onHeaders / (analysis.tackTiming.onHeaders + analysis.tackTiming.onLifts + analysis.tackTiming.neutral)) * 100).toFixed(0)}% on headers</li>
                        </ul>
                        
                        <p><strong>Interpretation:</strong></p>
                        <ul>
                            <li><strong>>70%:</strong> Excellent wind awareness and shift detection</li>
                            <li><strong>60-70%:</strong> Good awareness, catching most shifts</li>
                            <li><strong>50-60%:</strong> Fair awareness, missing opportunities</li>
                            <li><strong>&lt;50%:</strong> Poor awareness, tacking randomly or on wrong shifts</li>
                        </ul>
                        
                        <p><strong>Why this matters:</strong> Tacking on headers is fundamental upwind strategy. If you tack on lifts, you're giving up free pointing advantage. Each tack on a lift vs staying could cost 5-10 boat lengths!</p>
                        
                        <p><strong>How to improve:</strong></p>
                        <ul>
                            <li>Sail longer on each tack to feel the shifts developing</li>
                            <li>Use compass or tell-tales to detect when you're being headed</li>
                            <li>Tack IMMEDIATELY when you feel a significant header</li>
                            <li>Review wind shift timeline to see when you missed opportunities</li>
                        </ul>
                    `)}
                    <div class="space-y-3">
                        ${analysis.tackTiming.analysis.map(item => `
                            <div class="p-3 bg-gray-700 rounded border-l-4 ${
                                item.assessment === 'excellent' ? 'border-green-500' :
                                item.assessment === 'good' ? 'border-blue-500' :
                                item.assessment === 'concerning' ? 'border-red-500' :
                                'border-yellow-500'
                            }">
                                <div class="font-semibold text-sm ${
                                    item.assessment === 'excellent' ? 'text-green-400' :
                                    item.assessment === 'good' ? 'text-blue-400' :
                                    item.assessment === 'concerning' ? 'text-red-400' :
                                    'text-yellow-400'
                                }">
                                    ${item.metric}
                                </div>
                                <div class="text-xs text-gray-300 mt-1">${item.value}</div>
                                <div class="text-xs text-gray-400 mt-2">
                                    <strong>üí° ${item.recommendation}</strong>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- Multi-Race Comparison -->
                ${analysis.multiRaceComparison && analysis.multiRaceComparison.racesAnalyzed > 1 ? `
                <div class="bg-gray-800 p-6 rounded-xl border border-purple-700 mb-8">
                    <h3 class="text-xl font-bold mb-4">üèÜ Multi-Race Comparison (${analysis.multiRaceComparison.racesAnalyzed} Races)</h3>
                    
                    <div class="grid grid-cols-2 gap-4 mb-6">
                        <div class="p-4 bg-green-900 bg-opacity-20 border border-green-600 rounded">
                            <div class="text-sm text-green-400 font-semibold mb-2">ü•á Best Race: #${parseInt(analysis.multiRaceComparison.bestRace.id) + 1}</div>
                            <div class="grid grid-cols-2 gap-2 text-xs">
                                <div><span class="text-gray-400">Avg VMG:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.avgVMG.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Tack Eff:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.tackEfficiency.toFixed(0)}%</span></div>
                                <div><span class="text-gray-400">Speed:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.avgUpwindSpeed.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Handling:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.bestRace.boatHandlingScore.toFixed(0)}</span></div>
                            </div>
                        </div>
                        <div class="p-4 bg-red-900 bg-opacity-20 border border-red-600 rounded">
                            <div class="text-sm text-red-400 font-semibold mb-2">üìâ Weakest Race: #${parseInt(analysis.multiRaceComparison.worstRace.id) + 1}</div>
                            <div class="grid grid-cols-2 gap-2 text-xs">
                                <div><span class="text-gray-400">Avg VMG:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.avgVMG.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Tack Eff:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.tackEfficiency.toFixed(0)}%</span></div>
                                <div><span class="text-gray-400">Speed:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.avgUpwindSpeed.toFixed(2)}</span></div>
                                <div><span class="text-gray-400">Handling:</span> <span class="text-white font-bold">${analysis.multiRaceComparison.worstRace.boatHandlingScore.toFixed(0)}</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="p-4 bg-gray-700 rounded mb-4">
                        <div class="flex justify-between items-center">
                            <div>
                                <div class="text-sm text-gray-400">Consistency</div>
                                <div class="text-xs text-gray-500">VMG variation</div>
                            </div>
                            <div class="text-right">
                                <div class="text-3xl font-bold ${
                                    analysis.multiRaceComparison.consistency.assessment === 'excellent' ? 'text-green-400' :
                                    analysis.multiRaceComparison.consistency.assessment === 'good' ? 'text-blue-400' :
                                    'text-yellow-400'
                                }">${analysis.multiRaceComparison.consistency.vmgVariation.toFixed(1)}%</div>
                                <div class="text-xs ${
                                    analysis.multiRaceComparison.consistency.assessment === 'excellent' ? 'text-green-400' :
                                    analysis.multiRaceComparison.consistency.assessment === 'good' ? 'text-blue-400' :
                                    'text-yellow-400'
                                }">${analysis.multiRaceComparison.consistency.assessment.toUpperCase()}</div>
                            </div>
                        </div>
                    </div>
                    
                    ${analysis.multiRaceComparison.keyDifferences.length > 0 ? `
                    <div class="space-y-2 mb-4">
                        <div class="text-sm font-semibold text-gray-300">üîç Key Differences:</div>
                        ${analysis.multiRaceComparison.keyDifferences.map(diff => `
                            <div class="p-3 bg-gray-700 rounded text-xs">
                                <div class="font-semibold text-purple-400">${diff.metric}</div>
                                <div class="text-gray-300 mt-1">${diff.difference}</div>
                                <div class="text-gray-400 mt-1"><strong>Impact:</strong> ${diff.impact}</div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    <div class="mt-4">
                        <div class="text-sm font-semibold text-gray-300 mb-2">üìà Performance Trend</div>
                        <div class="chart-container" style="height: 200px;">
                            <canvas id="learningCurveChart"></canvas>
                        </div>
                    </div>
                </div>
                ` : ''}

                <!-- Charts -->
                <h3 class="text-2xl font-bold mb-4">üìä Performance Analysis</h3>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨ÜÔ∏è VMG vs Heel - UPWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.upwindSample.length} points ‚Ä¢ <strong>Optimal: ${analysis.optimalHeelUp}¬∞</strong><br/>
                            <span class="text-yellow-400">‚óè</span> Yellow curve = Polynomial trend<br/>
                            <span class="text-green-400">- - -</span> Green dashed = Optimal heel line<br/>
                            <details class="mt-1">
                                <summary class="cursor-pointer text-blue-400 hover:text-blue-300">How is optimal determined?</summary>
                                <div class="mt-1 p-2 bg-gray-700 rounded text-xs">
                                    1. Bin heel angles in 2¬∞ buckets (0¬∞, 2¬∞, 4¬∞...)<br/>
                                    2. For each bin, find 90th percentile VMG (top 10% performance)<br/>
                                    3. Optimal = heel angle with highest 90th percentile<br/>
                                    4. Requires 50+ samples per bin for reliability<br/>
                                    <em class="text-gray-500">Note: Aggregated across all wind speeds in session</em>
                                </div>
                            </details>
                        </div>
                        <div class="chart-container"><canvas id="heelVmgUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨áÔ∏è VMG vs Heel - DOWNWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.downwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalHeelDown}¬∞<br/>
                            <span class="text-green-400">Green line</span> = optimal heel angle<br/>
                            <span class="text-yellow-400">Yellow curve</span> = VMG trend with heel angle
                        </div>
                        <div class="chart-container"><canvas id="heelVmgDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨ÜÔ∏è VMG vs Trim - UPWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.upwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞<br/>
                            Positive = bow up, Negative = bow down
                        </div>
                        <div class="chart-container"><canvas id="trimVmgUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">‚¨áÔ∏è VMG vs Trim - DOWNWIND</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            ${analysis.downwindSample.length} points ‚Ä¢ Optimal: ${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞
                        </div>
                        <div class="chart-container"><canvas id="trimVmgDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Where you actually sailed</div>
                        <div class="chart-container"><canvas id="heelDistChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Polar Diagram</h4>
                        <div class="text-xs text-gray-400 mb-3">
                            Target = 90th percentile speed (best 10% of points at each angle)<br/>
                            Average = mean of all speeds at each angle
                        </div>
                        <div class="chart-container"><canvas id="polarChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">TWA Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Time at each wind angle</div>
                        <div class="chart-container"><canvas id="twaDistChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution</h4>
                        <div class="text-xs text-gray-400 mb-3">Consistency check</div>
                        <div class="chart-container"><canvas id="speedDistChart"></canvas></div>
                    </div>
                </div>

                <!-- New Charts: Separate Upwind/Downwind Distributions -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution - Upwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.heelDistributionUpwind.length} samples ‚Ä¢ Absolute heel angles</div>
                        <div class="chart-container"><canvas id="heelDistUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Heel Distribution - Downwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.heelDistributionDownwind.length} samples ‚Ä¢ Absolute heel angles</div>
                        <div class="chart-container"><canvas id="heelDistDownChart"></canvas></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution - Upwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.speedDistributionUpwind.length} samples ‚Ä¢ Avg: ${(analysis.speedDistributionUpwind.reduce((a,b)=>a+b,0)/analysis.speedDistributionUpwind.length).toFixed(1)} kts</div>
                        <div class="chart-container"><canvas id="speedDistUpChart"></canvas></div>
                    </div>
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Speed Distribution - Downwind</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.speedDistributionDownwind.length} samples ‚Ä¢ Avg: ${(analysis.speedDistributionDownwind.reduce((a,b)=>a+b,0)/analysis.speedDistributionDownwind.length).toFixed(1)} kts</div>
                        <div class="chart-container"><canvas id="speedDistDownChart"></canvas></div>
                    </div>
                </div>

                ${analysis.maneuvers.length > 0 ? `
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                    ${analysis.tacks.length > 0 ? `
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Tack Performance</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.tacks.length} tacks ‚Ä¢ Avg efficiency: ${analysis.tackEfficiency.toFixed(0)}%<br/>
                        Color = distance lost (green=best, red=worst)</div>
                        <div class="chart-container"><canvas id="tackScatterChart"></canvas></div>
                    </div>
                    ` : ''}
                    ${analysis.gybes.length > 0 ? `
                    <div class="bg-gray-800 p-6 rounded-xl border border-gray-700">
                        <h4 class="text-lg font-semibold mb-2">Gybe Performance</h4>
                        <div class="text-xs text-gray-400 mb-3">${analysis.gybes.length} gybes ‚Ä¢ Avg efficiency: ${analysis.gybeEfficiency.toFixed(0)}%<br/>
                        Color = distance lost (green=best, red=worst)</div>
                        <div class="chart-container"><canvas id="gybeScatterChart"></canvas></div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}

                <!-- Map -->
                <h3 class="text-2xl font-bold mb-4">üó∫Ô∏è GPS Track</h3>
                <div class="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-8">
                    <div id="map"></div>
                    <div class="mt-4 grid grid-cols-7 gap-2">
                        <button id="drawStartLine" class="px-3 py-2 text-xs bg-blue-600 hover:bg-blue-700 rounded">üìè Start Line</button>
                        <button id="drawFinishLine" class="px-3 py-2 text-xs bg-purple-600 hover:bg-purple-700 rounded">üèÅ Finish Line</button>
                        <button id="markWindward" class="px-3 py-2 text-xs bg-green-600 hover:bg-green-700 rounded">‚óè Windward</button>
                        <button id="markLeeward" class="px-3 py-2 text-xs bg-yellow-600 hover:bg-yellow-700 rounded">‚óÜ Leeward</button>
                        <button id="clearMarks" class="px-3 py-2 text-xs bg-red-600 hover:bg-red-700 rounded">‚úï Clear</button>
                        <button id="clearStartLine" class="px-3 py-2 text-xs bg-gray-600 hover:bg-gray-700 rounded" style="display:none;">‚úï Start</button>
                        <button id="clearFinishLine" class="px-3 py-2 text-xs bg-gray-600 hover:bg-gray-700 rounded" style="display:none;">‚úï Finish</button>
                    </div>
                    <div class="mt-2 text-sm text-gray-400 flex gap-6 flex-wrap">
                        <span>üü¢ Excellent VMG</span>
                        <span>üîµ Good VMG</span>
                        <span>üü° Moderate VMG</span>
                        <span>üî¥ Poor VMG</span>
                        <span>üü¢‚ö™ Lifts (>5¬∞)</span>
                        <span>üî¥‚ö™ Headers (>5¬∞)</span>
                        <span>üîµ Tacks ‚Ä¢ üü† Gybes (click for details)</span>
                    </div>
                </div>

                <!-- ACTIONABLE SUGGESTIONS -->
                <div class="p-6 rounded-xl border mb-6" style="background: linear-gradient(to right, rgba(30, 58, 138, 0.7), rgba(88, 28, 135, 0.7)); border-color: rgba(59, 130, 246, 0.7);">
                    <h3 class="text-2xl font-bold mb-4">üéØ What To Do Next</h3>
                    <div id="suggestionsContainer" class="space-y-4"></div>
                </div>
            `;

            setTimeout(() => {
                createAllCharts();
                createWindRose();
                createLaylinesCanvas();
                createWindShiftTimeline();
                createLearningCurveChart();
                initMap();
                renderSuggestions();
                
                // Wire up the main PDF button
                const pdfBtnMain = document.getElementById('pdfButtonMain');
                if (pdfBtnMain) {
                    pdfBtnMain.addEventListener('click', function(e) {
                        alert("Button was clicked! Now trying to generate PDF...");
                        console.log("üîµ Main PDF button clicked!");
                        e.preventDefault();
                        generatePDF();
                    });
                    console.log("‚úÖ Main PDF button wired up");
                } else {
                    console.error("‚ùå Could not find pdfButtonMain element!");
                }
                
                // Setup mark placement buttons
                document.getElementById('markStart')?.addEventListener('click', () => { 
                    markMode = 'start'; 
                    document.getElementById('map').classList.add('clickable');
                });
                document.getElementById('markWindward')?.addEventListener('click', () => { 
                    markMode = 'windward'; 
                    document.getElementById('map').classList.add('clickable');
                });
                document.getElementById('markLeeward')?.addEventListener('click', () => { 
                    markMode = 'leeward'; 
                    document.getElementById('map').classList.add('clickable');
                });
                document.getElementById('markFinish')?.addEventListener('click', () => { 
                    markMode = 'finish'; 
                    document.getElementById('map').classList.add('clickable');
                });
                document.getElementById('clearMarks')?.addEventListener('click', clearMarks);
                document.getElementById('drawStartLine')?.addEventListener('click', () => {
                    markMode = 'startline';
                    startLinePins = [];
                    document.getElementById('map').classList.add('clickable');
                    alert('Click two points on the map to draw the start line');
                });
                document.getElementById('clearStartLine')?.addEventListener('click', clearStartLine);
                document.getElementById('drawFinishLine')?.addEventListener('click', () => {
                    markMode = 'finishline';
                    finishLinePins = [];
                    document.getElementById('map').classList.add('clickable');
                    alert('Click two points on the map to draw the finish line');
                });
                document.getElementById('clearFinishLine')?.addEventListener('click', clearFinishLine);
                
                setupMarkPlacement();
            }, 100);
        }

        function renderSuggestions() {
            const container = document.getElementById('suggestionsContainer');
            if (!container || !analysis || !analysis.suggestions) return;

            container.innerHTML = ''; // Clear

            analysis.suggestions.forEach(s => {
                const card = document.createElement('div');
                card.className = 'p-4 rounded-lg ' + (
                    s.priority === 'CRITICAL' ? 'bg-red-900/30 border-2 border-red-600' :
                    s.priority === 'HIGH' ? 'bg-orange-900/30 border border-orange-600' :
                    s.priority === 'MEDIUM' ? 'bg-yellow-900/30 border border-yellow-600' :
                    s.priority === 'GOOD' ? 'bg-green-900/30 border border-green-600' :
                    'bg-gray-800 border border-gray-600'
                );

                const wrapper = document.createElement('div');
                wrapper.className = 'flex items-start gap-3';

                const icon = document.createElement('div');
                icon.className = 'text-3xl';
                icon.textContent = s.icon;

                const content = document.createElement('div');
                content.className = 'flex-1';

                const title = document.createElement('div');
                title.className = 'font-bold text-lg mb-1';
                title.textContent = s.title;

                const issue = document.createElement('div');
                issue.className = 'text-sm text-gray-300 mb-3';
                issue.textContent = s.issue;

                const actionsList = document.createElement('div');
                actionsList.className = 'space-y-2';

                s.actions.forEach(actionText => {
                    const actionDiv = document.createElement('div');
                    actionDiv.className = 'text-sm pl-4 border-l-2 border-gray-600 text-gray-200';
                    actionDiv.textContent = '‚ñ∏ ' + actionText;
                    actionsList.appendChild(actionDiv);
                });

                content.appendChild(title);
                content.appendChild(issue);
                content.appendChild(actionsList);

                wrapper.appendChild(icon);
                wrapper.appendChild(content);
                card.appendChild(wrapper);
                container.appendChild(card);
            });
        }

        function createMetricCard(title, value, subtitle, color) {
            // Darker color mapping for better mobile readability
            const colors = {
                'green': { bg: 'linear-gradient(to bottom right, rgba(6, 95, 70, 0.8), rgba(4, 120, 87, 0.6))', border: 'rgba(16, 185, 129, 0.7)', text: '#6EE7B7' },
                'emerald': { bg: 'linear-gradient(to bottom right, rgba(6, 78, 59, 0.8), rgba(5, 150, 105, 0.6))', border: 'rgba(16, 185, 129, 0.7)', text: '#6EE7B7' },
                'teal': { bg: 'linear-gradient(to bottom right, rgba(19, 78, 74, 0.8), rgba(17, 94, 89, 0.6))', border: 'rgba(20, 184, 166, 0.7)', text: '#5EEAD4' },
                'cyan': { bg: 'linear-gradient(to bottom right, rgba(21, 94, 117, 0.8), rgba(22, 78, 99, 0.6))', border: 'rgba(34, 211, 238, 0.7)', text: '#67E8F9' },
                'blue': { bg: 'linear-gradient(to bottom right, rgba(30, 58, 138, 0.8), rgba(30, 64, 175, 0.6))', border: 'rgba(59, 130, 246, 0.7)', text: '#93C5FD' },
                'indigo': { bg: 'linear-gradient(to bottom right, rgba(55, 48, 163, 0.8), rgba(67, 56, 202, 0.6))', border: 'rgba(129, 140, 248, 0.7)', text: '#A5B4FC' },
                'purple': { bg: 'linear-gradient(to bottom right, rgba(88, 28, 135, 0.8), rgba(107, 33, 168, 0.6))', border: 'rgba(168, 85, 247, 0.7)', text: '#C084FC' },
                'pink': { bg: 'linear-gradient(to bottom right, rgba(131, 24, 67, 0.8), rgba(157, 23, 77, 0.6))', border: 'rgba(236, 72, 153, 0.7)', text: '#F9A8D4' },
                'red': { bg: 'linear-gradient(to bottom right, rgba(127, 29, 29, 0.8), rgba(153, 27, 27, 0.6))', border: 'rgba(239, 68, 68, 0.7)', text: '#FCA5A5' },
                'orange': { bg: 'linear-gradient(to bottom right, rgba(124, 45, 18, 0.8), rgba(154, 52, 18, 0.6))', border: 'rgba(249, 115, 22, 0.7)', text: '#FED7AA' },
                'amber': { bg: 'linear-gradient(to bottom right, rgba(120, 53, 15, 0.8), rgba(146, 64, 14, 0.6))', border: 'rgba(245, 158, 11, 0.7)', text: '#FCD34D' },
                'yellow': { bg: 'linear-gradient(to bottom right, rgba(113, 63, 18, 0.8), rgba(133, 77, 14, 0.6))', border: 'rgba(234, 179, 8, 0.7)', text: '#FEF08A' },
                'lime': { bg: 'linear-gradient(to bottom right, rgba(54, 83, 20, 0.8), rgba(63, 98, 18, 0.6))', border: 'rgba(163, 230, 53, 0.7)', text: '#D9F99D' }
            };
            
            const c = colors[color] || colors['blue'];
            
            return `
                <div class="metric-card p-4 rounded-xl border" style="background: ${c.bg}; border-color: ${c.border};">
                    <div class="text-xl font-bold mb-2" style="color: ${c.text};">${title}</div>
                    <div class="text-5xl font-bold text-white mb-2">${value}</div>
                    <div class="text-base font-semibold text-white opacity-90">${subtitle}</div>
                </div>
            `;
        }

        function polynomialRegression(data, degree = 2) {
            // Simple polynomial regression for trend lines
            const n = data.length;
            if (n < 10) return null;
            
            // For quadratic (degree 2): y = ax¬≤ + bx + c
            let sumX = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0;
            let sumY = 0, sumXY = 0, sumX2Y = 0;

            data.forEach(d => {
                const x = d.x;
                const y = d.y;
                sumX += x;
                sumX2 += x * x;
                sumX3 += x * x * x;
                sumX4 += x * x * x * x;
                sumY += y;
                sumXY += x * y;
                sumX2Y += x * x * y;
            });

            // Solve normal equations (simplified for quadratic)
            const denom = (n * sumX4 - sumX2 * sumX2);
            if (Math.abs(denom) < 0.0001) return null;
            
            const a = (n * sumX2Y - sumX2 * sumY) / denom;
            const b = (sumXY * sumX2 - sumX * sumX2Y) / (sumX * sumX2 - n * sumX3);
            const c = (sumY - b * sumX - a * sumX2) / n;

            return { a, b, c };
        }

        function createAllCharts() {
            console.log("üìä Creating all charts...");
            
            const showBestFit = document.getElementById('showBestFitCheck')?.checked !== false;
            
            // VMG vs Heel - UPWIND with best fit
            const heelUpData = analysis.upwindSample.map(r => ({x: r.vmg, y: Math.abs(r.heel)}));
            const heelUpDatasets = [{
                label: 'Data Points',
                data: heelUpData,
                backgroundColor: 'rgba(16, 185, 129, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(heelUpData);
                if (fit) {
                    const vmgRange = heelUpData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    // Find optimal VMG (where heel = optimal)
                    const optimalHeel = analysis.optimalHeelUp;
                    const optimalVMG = fitLine.reduce((best, point) => {
                        return Math.abs(point.y - optimalHeel) < Math.abs(best.y - optimalHeel) ? point : best;
                    }, fitLine[0]);
                    
                    heelUpDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal heel value (reuse minVMG/maxVMG from above)
                    heelUpDatasets.push({
                        label: `Optimal Heel: ${optimalHeel}¬∞`,
                        data: [
                            { x: minVMG, y: optimalHeel },
                            { x: maxVMG, y: optimalHeel }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('heelVmgUpChart'), {
                type: 'scatter',
                data: { datasets: heelUpDatasets },
                options: getScatterOptions('VMG (kts)', 'Heel (¬∞)', null, null, 0, 25)
            });

            // VMG vs Heel - DOWNWIND with best fit
            const heelDownData = analysis.downwindSample.map(r => ({x: Math.abs(r.vmg), y: Math.abs(r.heel)}));
            const heelDownDatasets = [{
                label: 'Data Points',
                data: heelDownData,
                backgroundColor: 'rgba(59, 130, 246, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(heelDownData);
                if (fit) {
                    const vmgRange = heelDownData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    heelDownDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal heel value (reuse minVMG/maxVMG from above)
                    const optimalHeel = analysis.optimalHeelDown;
                    heelDownDatasets.push({
                        label: `Optimal Heel: ${optimalHeel}¬∞`,
                        data: [
                            { x: minVMG, y: optimalHeel },
                            { x: maxVMG, y: optimalHeel }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('heelVmgDownChart'), {
                type: 'scatter',
                data: { datasets: heelDownDatasets },
                options: getScatterOptions('VMG (kts)', 'Heel (¬∞)', null, null, 0, 25)
            });

            // VMG vs Trim - UPWIND with best fit
            const trimUpData = analysis.upwindSample.map(r => ({x: r.vmg, y: r.trim}));
            const trimUpDatasets = [{
                label: 'Data Points',
                data: trimUpData,
                backgroundColor: 'rgba(168, 85, 247, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(trimUpData);
                if (fit) {
                    const vmgRange = trimUpData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    trimUpDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal trim value (reuse minVMG/maxVMG from above)
                    const optimalTrim = analysis.optimalTrimUp;
                    trimUpDatasets.push({
                        label: `Optimal Trim: ${optimalTrim}¬∞`,
                        data: [
                            { x: minVMG, y: optimalTrim },
                            { x: maxVMG, y: optimalTrim }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('trimVmgUpChart'), {
                type: 'scatter',
                data: { datasets: trimUpDatasets },
                options: getScatterOptions('VMG (kts)', 'Trim (¬∞ bow up/down)', null, null, -15, 15)
            });

            // VMG vs Trim - DOWNWIND with best fit
            const trimDownData = analysis.downwindSample.map(r => ({x: Math.abs(r.vmg), y: r.trim}));
            const trimDownDatasets = [{
                label: 'Data Points',
                data: trimDownData,
                backgroundColor: 'rgba(251, 191, 36, 0.6)',
                pointRadius: 2
            }];
            
            if (showBestFit) {
                const fit = polynomialRegression(trimDownData);
                if (fit) {
                    const vmgRange = trimDownData.map(d => d.x);
                    const minVMG = Math.min(...vmgRange);
                    const maxVMG = Math.max(...vmgRange);
                    const fitLine = [];
                    for (let vmg = minVMG; vmg <= maxVMG; vmg += 0.1) {
                        fitLine.push({ x: vmg, y: fit.a * vmg * vmg + fit.b * vmg + fit.c });
                    }
                    
                    trimDownDatasets.push({
                        label: 'Best Fit',
                        data: fitLine,
                        borderColor: 'rgb(251, 191, 36)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 2,
                        type: 'line'
                    });
                    
                    // Add horizontal line at optimal trim value (reuse minVMG/maxVMG from above)
                    const optimalTrim = analysis.optimalTrimDown;
                    trimDownDatasets.push({
                        label: `Optimal Trim: ${optimalTrim}¬∞`,
                        data: [
                            { x: minVMG, y: optimalTrim },
                            { x: maxVMG, y: optimalTrim }
                        ],
                        borderColor: 'rgb(34, 197, 94)',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        borderWidth: 3,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false
                    });
                }
            }
            
            new Chart(document.getElementById('trimVmgDownChart'), {
                type: 'scatter',
                data: { datasets: trimDownDatasets },
                options: getScatterOptions('VMG (kts)', 'Trim (¬∞ bow up/down)', null, null, -15, 15)
            });

            // Other charts
            new Chart(document.getElementById('heelDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.heelDistribution.map(h => `${h.heel}¬∞`),
                    datasets: [{ data: analysis.heelDistribution.map(h => h.count), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Heel Angle', 'Count')
            });

            new Chart(document.getElementById('polarChart'), {
                type: 'line',
                data: {
                    labels: analysis.polar.map(p => `${p.twa}¬∞`),
                    datasets: [
                        { label: 'Target', data: analysis.polar.map(p => p.target), borderColor: 'rgb(16, 185, 129)', fill: true, tension: 0.3 },
                        { label: 'Average', data: analysis.polar.map(p => p.avg), borderColor: 'rgb(251, 191, 36)', fill: false, tension: 0.3 }
                    ]
                },
                options: getLineOptions('TWA', 'Speed (kts)')
            });

            new Chart(document.getElementById('twaDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.twaDist.map(t => `${t.twa}¬∞`),
                    datasets: [{ data: analysis.twaDist.map(t => t.count), backgroundColor: 'rgba(168, 85, 247, 0.7)' }]
                },
                options: getBarOptions('TWA', 'Count')
            });

            new Chart(document.getElementById('speedDistChart'), {
                type: 'bar',
                data: {
                    labels: analysis.speedDist.map(s => `${s.speed}`),
                    datasets: [{ data: analysis.speedDist.map(s => s.count), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });

            // NEW: Heel Distribution - Upwind
            const heelBinsUp = {};
            analysis.heelDistributionUpwind.forEach(h => {
                const bin = Math.round(h / 2) * 2;
                heelBinsUp[bin] = (heelBinsUp[bin] || 0) + 1;
            });
            new Chart(document.getElementById('heelDistUpChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(heelBinsUp).sort((a,b) => a-b).map(h => `${h}¬∞`),
                    datasets: [{ data: Object.keys(heelBinsUp).sort((a,b) => a-b).map(h => heelBinsUp[h]), backgroundColor: 'rgba(16, 185, 129, 0.7)' }]
                },
                options: getBarOptions('Heel Angle (¬∞)', 'Count')
            });

            // NEW: Heel Distribution - Downwind
            const heelBinsDown = {};
            analysis.heelDistributionDownwind.forEach(h => {
                const bin = Math.round(h / 2) * 2;
                heelBinsDown[bin] = (heelBinsDown[bin] || 0) + 1;
            });
            new Chart(document.getElementById('heelDistDownChart'), {
                type: 'bar',
                data: {
                    labels: Object.keys(heelBinsDown).sort((a,b) => a-b).map(h => `${h}¬∞`),
                    datasets: [{ data: Object.keys(heelBinsDown).sort((a,b) => a-b).map(h => heelBinsDown[h]), backgroundColor: 'rgba(59, 130, 246, 0.7)' }]
                },
                options: getBarOptions('Heel Angle (¬∞)', 'Count')
            });

            // NEW: Speed Distribution - Upwind
            const speedBinsUp = {};
            analysis.speedDistributionUpwind.forEach(s => {
                const bin = Math.round(s * 2) / 2;
                speedBinsUp[bin] = (speedBinsUp[bin] || 0) + 1;
            });
            
            // NEW: Speed Distribution - Downwind
            const speedBinsDown = {};
            analysis.speedDistributionDownwind.forEach(s => {
                const bin = Math.round(s * 2) / 2;
                speedBinsDown[bin] = (speedBinsDown[bin] || 0) + 1;
            });
            
            // Calculate unified speed range for both charts
            const allSpeedBins = [
                ...Object.keys(speedBinsUp).map(Number),
                ...Object.keys(speedBinsDown).map(Number)
            ];
            const minSpeed = Math.floor(Math.min(...allSpeedBins));
            const maxSpeed = Math.ceil(Math.max(...allSpeedBins));
            const speedRange = [];
            for (let s = minSpeed; s <= maxSpeed; s += 0.5) {
                speedRange.push(s.toFixed(1));
            }
            
            new Chart(document.getElementById('speedDistUpChart'), {
                type: 'bar',
                data: {
                    labels: speedRange,
                    datasets: [{ 
                        data: speedRange.map(s => speedBinsUp[parseFloat(s)] || 0), 
                        backgroundColor: 'rgba(16, 185, 129, 0.7)' 
                    }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });
            
            new Chart(document.getElementById('speedDistDownChart'), {
                type: 'bar',
                data: {
                    labels: speedRange,
                    datasets: [{ 
                        data: speedRange.map(s => speedBinsDown[parseFloat(s)] || 0), 
                        backgroundColor: 'rgba(59, 130, 246, 0.7)' 
                    }]
                },
                options: getBarOptions('Speed (kts)', 'Count')
            });

            // NEW: Tack Performance Scatter Plot (Entry vs Exit Speed, colored by distance lost)
            if (analysis.tacks && analysis.tacks.length > 0) {
                const maxLoss = Math.max(...analysis.tacks.map(t => t.distanceLost));
                const getColorForLoss = (loss) => {
                    const ratio = loss / maxLoss;
                    if (ratio < 0.33) return 'rgba(16, 185, 129, 0.8)';  // Green - good
                    if (ratio < 0.67) return 'rgba(251, 191, 36, 0.8)';  // Yellow - moderate
                    return 'rgba(239, 68, 68, 0.8)';                      // Red - poor
                };
                
                new Chart(document.getElementById('tackScatterChart'), {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Tacks',
                            data: analysis.tacks.map(t => ({
                                x: t.entrySpeed,
                                y: t.exitSpeed,
                                tackNum: t.tackNumber,
                                loss: t.distanceLost,
                                efficiency: t.efficiency
                            })),
                            backgroundColor: analysis.tacks.map(t => getColorForLoss(t.distanceLost)),
                            pointRadius: 8,
                            pointHoverRadius: 10
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const d = context.raw;
                                        return [
                                            `Tack #${d.tackNum}`,
                                            `Entry: ${d.x.toFixed(1)} kts`,
                                            `Exit: ${d.y.toFixed(1)} kts`,
                                            `Efficiency: ${d.efficiency.toFixed(0)}%`,
                                            `Loss: ${d.loss.toFixed(1)}m`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Entry Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { display: true, text: 'Exit Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            }
                        }
                    }
                });
            }

            // NEW: Gybe Performance Scatter Plot
            if (analysis.gybes && analysis.gybes.length > 0) {
                const maxLoss = Math.max(...analysis.gybes.map(g => g.distanceLost));
                const getColorForLoss = (loss) => {
                    const ratio = loss / maxLoss;
                    if (ratio < 0.33) return 'rgba(16, 185, 129, 0.8)';
                    if (ratio < 0.67) return 'rgba(251, 191, 36, 0.8)';
                    return 'rgba(239, 68, 68, 0.8)';
                };
                
                new Chart(document.getElementById('gybeScatterChart'), {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: 'Gybes',
                            data: analysis.gybes.map(g => ({
                                x: g.entrySpeed,
                                y: g.exitSpeed,
                                gybeNum: g.tackNumber,
                                loss: g.distanceLost,
                                efficiency: g.efficiency
                            })),
                            backgroundColor: analysis.gybes.map(g => getColorForLoss(g.distanceLost)),
                            pointRadius: 8,
                            pointHoverRadius: 10
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const d = context.raw;
                                        return [
                                            `Gybe #${d.gybeNum}`,
                                            `Entry: ${d.x.toFixed(1)} kts`,
                                            `Exit: ${d.y.toFixed(1)} kts`,
                                            `Efficiency: ${d.efficiency.toFixed(0)}%`,
                                            `Loss: ${d.loss.toFixed(1)}m`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Entry Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { display: true, text: 'Exit Speed (kts)', color: '#9CA3AF' },
                                ticks: { color: '#9CA3AF' },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            }
                        }
                    }
                });
            }

            console.log("‚úÖ All charts created");
        }

        function createWindRose() {
            if (!analysis || !analysis.trackData) return;
            
            const canvas = document.getElementById('windRose');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = 150;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create 360 bins (1¬∞ each)
            const headingBins = new Array(360).fill(0);
            analysis.trackData.forEach(d => {
                if (d.speed > 2) { // Only count when moving
                    const heading = Math.round(d.cog || d.heading) % 360;
                    headingBins[heading]++;
                }
            });
            
            // Find max for scaling
            const maxCount = Math.max(...headingBins);
            
            // Draw compass rose background
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.3)';
            ctx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 50; r <= maxRadius; r += 50) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Cardinal directions
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 18 : 14;
            ctx.fillStyle = 'rgba(156, 163, 175, 0.6)';
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('N', centerX, centerY - maxRadius - 20);
            ctx.fillText('E', centerX + maxRadius + 20, centerY);
            ctx.fillText('S', centerX, centerY + maxRadius + 20);
            ctx.fillText('W', centerX - maxRadius - 20, centerY);
            
            // Draw heading bars (grouped in 5¬∞ bins for clarity)
            const peak1 = analysis.predominantHeadings.peak1;
            const peak2 = analysis.predominantHeadings.peak2;
            
            for (let deg = 0; deg < 360; deg += 5) {
                // Sum counts in this 5¬∞ bin
                let count = 0;
                for (let i = 0; i < 5; i++) {
                    count += headingBins[(deg + i) % 360];
                }
                
                if (count === 0) continue;
                
                // Determine color based on proximity to peaks
                let color;
                const distToPeak1 = Math.min(Math.abs(deg - peak1), 360 - Math.abs(deg - peak1));
                const distToPeak2 = Math.min(Math.abs(deg - peak2), 360 - Math.abs(deg - peak2));
                
                if (distToPeak1 < 20) {
                    color = 'rgba(59, 130, 246, 0.8)'; // Blue - port tack
                } else if (distToPeak2 < 20) {
                    color = 'rgba(34, 197, 94, 0.8)'; // Green - starboard tack
                } else {
                    color = 'rgba(156, 163, 175, 0.4)'; // Gray - other
                }
                
                // Calculate bar length
                const barLength = (count / maxCount) * maxRadius;
                
                // Convert to radians (0¬∞ = North = up)
                const angle = (deg - 90) * Math.PI / 180;
                
                // Draw wedge
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * barLength,
                    centerY + Math.sin(angle) * barLength
                );
                ctx.lineTo(
                    centerX + Math.cos(angle + 5 * Math.PI / 180) * barLength,
                    centerY + Math.sin(angle + 5 * Math.PI / 180) * barLength
                );
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 0.5;
                ctx.stroke();
            }
            
            // Draw wind direction arrow
            const roseWindDir = analysis.predominantHeadings.estimatedWindDir;
            const windAngle = (roseWindDir - 90) * Math.PI / 180;
            const arrowLength = maxRadius * 1.15;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
            ctx.lineWidth = 3;
            
            // Arrow shaft
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(windAngle) * arrowLength,
                centerY + Math.sin(windAngle) * arrowLength
            );
            ctx.stroke();
            
            // Arrow head
            const headSize = 15;
            const arrowX = centerX + Math.cos(windAngle) * arrowLength;
            const arrowY = centerY + Math.sin(windAngle) * arrowLength;
            
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - headSize * Math.cos(windAngle - Math.PI / 6),
                arrowY - headSize * Math.sin(windAngle - Math.PI / 6)
            );
            ctx.lineTo(
                arrowX - headSize * Math.cos(windAngle + Math.PI / 6),
                arrowY - headSize * Math.sin(windAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            
            // Wind direction label
            ctx.fillStyle = 'rgba(251, 191, 36, 1)';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(`Wind ${roseWindDir.toFixed(0)}¬∞`, arrowX + 15, arrowY);
            
            console.log("üß≠ Wind rose created");
        }

        function createWindShiftTimeline() {
            if (!analysis || !analysis.trackData) return;
            
            const canvas = document.getElementById('windShiftTimeline');
            if (!canvas) {
                console.warn("‚ö†Ô∏è Wind shift timeline canvas not found");
                return;
            }
            
            // Check if Chart.js is available
            if (typeof Chart === 'undefined') {
                console.warn("‚ö†Ô∏è Chart.js library blocked - using fallback display");
                canvas.parentElement.innerHTML = `
                    <div class="p-6 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <div class="text-yellow-400 font-semibold mb-2">‚ö†Ô∏è Wind Shift Timeline Unavailable</div>
                        <div class="text-sm text-gray-300 mb-3">Chart library blocked by browser security.</div>
                        <div class="text-xs text-gray-400">
                            <strong>Wind Shift Summary:</strong><br/>
                            ${analysis.windAnalysis ? `
                                ‚Ä¢ ${analysis.windAnalysis.liftPct.toFixed(0)}% of time on lifts<br/>
                                ‚Ä¢ ${(100 - analysis.windAnalysis.liftPct).toFixed(0)}% of time on headers<br/>
                                ‚Ä¢ Avg shift magnitude: ${analysis.windAnalysis.avgShift ? analysis.windAnalysis.avgShift.toFixed(1) : 'N/A'}¬∞
                            ` : 'Wind shift data available in full desktop version'}
                        </div>
                    </div>
                `;
                return;
            }
            
            // Get upwind data with timestamps
            const upwindData = analysis.trackData
                .filter(d => d.speed > 3 && d.timestamp)
                .map((d, idx) => ({
                    time: d.timestamp,
                    twaDeviation: d.shiftAmount || 0,
                    isUpwind: d.isUpwind,  // Use existing isUpwind property
                    isLift: d.isLift,
                    isHeader: d.isHeader,
                    index: idx
                }));
            
            if (upwindData.length < 10) {
                console.warn("‚ö†Ô∏è Not enough data for timeline");
                canvas.parentElement.innerHTML = `
                    <div class="p-4 bg-gray-700 rounded text-center text-gray-400">
                        Not enough sailing data to generate wind shift timeline
                    </div>
                `;
                return;
            }
            
            // Sample every Nth point to avoid overcrowding
            const sampleRate = Math.max(1, Math.floor(upwindData.length / 500));
            const sampledData = upwindData.filter((_, idx) => idx % sampleRate === 0);
            
            // Calculate actual min/max for better scaling
            const deviations = sampledData.map(d => d.twaDeviation);
            const maxDeviation = Math.max(...deviations.map(Math.abs));
            const yScale = Math.ceil(maxDeviation / 5) * 5; // Round up to nearest 5¬∞
            
            // Create time labels
            const labels = sampledData.map(d => {
                try {
                    const date = new Date(d.time);
                    return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                } catch (e) {
                    return '';
                }
            });
            
            // Find upwind/downwind segments for background shading
            const segments = [];
            let currentSegment = { start: 0, isUpwind: sampledData[0].isUpwind };
            
            for (let i = 1; i < sampledData.length; i++) {
                if (sampledData[i].isUpwind !== currentSegment.isUpwind) {
                    currentSegment.end = i;
                    segments.push({...currentSegment});
                    currentSegment = { start: i, isUpwind: sampledData[i].isUpwind };
                }
            }
            currentSegment.end = sampledData.length;
            segments.push(currentSegment);
            
            // Create background boxes for segments
            const backgroundBoxes = segments.map(seg => ({
                type: 'box',
                xMin: seg.start,
                xMax: seg.end,
                yMin: -yScale,
                yMax: yScale,
                backgroundColor: seg.isUpwind ? 'rgba(16, 185, 129, 0.08)' : 'rgba(59, 130, 246, 0.08)',
                borderWidth: 0,
                label: {
                    display: false
                }
            }));
            
            // Add tack markers as vertical lines
            const tackMarkers = [];
            if (analysis.tacks && analysis.tacks.length > 0) {
                analysis.tacks.forEach(tack => {
                    // Find the index in sampledData closest to this tack's timestamp
                    const tackTime = new Date(tack.timestamp).getTime();
                    let closestIdx = -1;
                    let minDiff = Infinity;
                    
                    sampledData.forEach((d, idx) => {
                        const dataTime = new Date(d.time).getTime();
                        const diff = Math.abs(tackTime - dataTime);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestIdx = idx;
                        }
                    });
                    
                    if (closestIdx >= 0 && minDiff < 60000) { // Within 60 seconds
                        tackMarkers.push({
                            type: 'line',
                            xMin: closestIdx,
                            xMax: closestIdx,
                            yMin: -yScale,
                            yMax: yScale,
                            borderColor: 'rgba(251, 191, 36, 0.9)', // Brighter yellow
                            borderWidth: 4, // Thicker line
                            borderDash: [8, 4], // Longer dashes
                            label: {
                                display: true,
                                content: '‚õµ',
                                position: 'start',
                                backgroundColor: 'rgba(251, 191, 36, 1)', // Solid yellow background
                                color: '#000',
                                font: {
                                    size: 16, // Much bigger emoji
                                    weight: 'bold'
                                },
                                padding: 4
                            }
                        });
                    }
                });
            }
            
            // Combine annotations
            const allAnnotations = [...backgroundBoxes, ...tackMarkers];
            
            try {
                new Chart(canvas, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'TWA Deviation',
                            data: sampledData.map(d => d.twaDeviation),
                            borderColor: 'rgba(156, 163, 175, 0.8)',
                            segment: {
                                borderColor: ctx => {
                                    const curr = ctx.p1.parsed.y;
                                    return curr < -3 ? 'rgba(34, 197, 94, 0.8)' :
                                           curr > 3 ? 'rgba(239, 68, 68, 0.8)' :
                                           'rgba(156, 163, 175, 0.6)';
                                }
                            },
                            backgroundColor: function(context) {
                                const value = context.parsed?.y || 0;
                                return value < 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                            },
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const point = sampledData[idx];
                                        const val = context.parsed.y;
                                        const type = val < -3 ? 'LIFT' : val > 3 ? 'HEADER' : 'Neutral';
                                        const leg = point.isUpwind ? '‚õµ Upwind' : 'üèÑ Downwind';
                                        return `${type}: ${Math.abs(val).toFixed(1)}¬∞ ${val < 0 ? 'favorable' : 'unfavorable'} ‚Ä¢ ${leg}`;
                                    }
                                }
                            },
                            annotation: {
                                annotations: allAnnotations
                            }
                        },
                        scales: {
                            x: {
                                title: { 
                                    display: true, 
                                    text: 'Time', 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 16 : 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: { 
                                    color: '#9CA3AF',
                                    maxRotation: 45,
                                    minRotation: 45,
                                    autoSkip: true,
                                    maxTicksLimit: 15,
                                    font: { 
                                        size: window.innerWidth <= 768 ? 14 : 12
                                    }
                                },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' }
                            },
                            y: {
                                title: { 
                                    display: true, 
                                    text: 'TWA Deviation (¬∞)', 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 16 : 14,
                                        weight: 'bold'
                                    }
                                },
                                ticks: { 
                                    color: '#9CA3AF',
                                    font: { 
                                        size: window.innerWidth <= 768 ? 14 : 12
                                    }
                                },
                                grid: { color: 'rgba(75, 85, 99, 0.3)' },
                                min: -yScale,
                                max: yScale
                            }
                        }
                    }
                });
                
                console.log("üìà Wind shift timeline created with", sampledData.length, "points");
            } catch (error) {
                console.error("‚ùå Error creating wind shift timeline:", error);
                canvas.parentElement.innerHTML = `
                    <div class="p-4 bg-red-900 bg-opacity-20 border border-red-600 rounded text-center">
                        <div class="text-red-400 font-semibold">Error creating timeline chart</div>
                        <div class="text-xs text-gray-400 mt-2">${error.message}</div>
                    </div>
                `;
            }
        }

        function createLaylinesCanvas() {
            if (!analysis || !analysis.laylines) return;
            
            const canvas = document.getElementById('laylinesCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 120;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background circle
            ctx.strokeStyle = 'rgba(156, 163, 175, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw compass directions
            ctx.fillStyle = 'rgba(156, 163, 175, 0.4)';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('N', centerX, centerY - radius - 10);
            ctx.fillText('E', centerX + radius + 15, centerY + 5);
            ctx.fillText('S', centerX, centerY + radius + 20);
            ctx.fillText('W', centerX - radius - 15, centerY + 5);
            
            const laylinesWindDir = analysis.laylines.windDirection;
            const pointingAngle = analysis.laylines.pointingAngle;
            
            // Draw wind direction arrow (pointing FROM)
            const windAngle = (laylinesWindDir - 90) * Math.PI / 180;
            const windLength = radius * 0.8;
            
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(windAngle) * windLength,
                centerY + Math.sin(windAngle) * windLength
            );
            ctx.stroke();
            
            // Wind arrow head
            const arrowX = centerX + Math.cos(windAngle) * windLength;
            const arrowY = centerY + Math.sin(windAngle) * windLength;
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(arrowX - 10 * Math.cos(windAngle - Math.PI / 6), arrowY - 10 * Math.sin(windAngle - Math.PI / 6));
            ctx.lineTo(arrowX - 10 * Math.cos(windAngle + Math.PI / 6), arrowY - 10 * Math.sin(windAngle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
            
            // Draw port tack heading (blue) - this is the heading you sail when closehauled on port
            const portAngle = (analysis.laylines.portTackHeading - 90) * Math.PI / 180;
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(portAngle) * radius,
                centerY + Math.sin(portAngle) * radius
            );
            ctx.stroke();
            
            // Draw starboard tack heading (green) - this is the heading you sail when closehauled on starboard
            const stbdAngle = (analysis.laylines.starboardTackHeading - 90) * Math.PI / 180;
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.9)';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(stbdAngle) * radius,
                centerY + Math.sin(stbdAngle) * radius
            );
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw pointing angle arcs
            ctx.strokeStyle = 'rgba(251, 191, 36, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6, 
                (laylinesWindDir - pointingAngle - 90) * Math.PI / 180,
                (laylinesWindDir - 90) * Math.PI / 180,
                true);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.6,
                (laylinesWindDir - 90) * Math.PI / 180,
                (laylinesWindDir + pointingAngle - 90) * Math.PI / 180,
                false);
            ctx.stroke();
            
            // Label pointing angles
            ctx.fillStyle = 'rgba(251, 191, 36, 0.8)';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${pointingAngle}¬∞`, centerX - radius * 0.4, centerY - 10);
            ctx.fillText(`${pointingAngle}¬∞`, centerX + radius * 0.4, centerY - 10);
            
            // Labels
            ctx.fillStyle = 'rgba(59, 130, 246, 1)';
            ctx.fillText('Port', 
                centerX + Math.cos(portAngle) * (radius + 25),
                centerY + Math.sin(portAngle) * (radius + 25)
            );
            
            ctx.fillStyle = 'rgba(34, 197, 94, 1)';
            ctx.fillText('Stbd',
                centerX + Math.cos(stbdAngle) * (radius + 25),
                centerY + Math.sin(stbdAngle) * (radius + 25)
            );
            
            console.log("üìê Laylines canvas created");
        }

        function createLearningCurveChart() {
            if (!analysis || !analysis.multiRaceComparison || analysis.multiRaceComparison.racesAnalyzed < 2) return;
            
            const canvas = document.getElementById('learningCurveChart');
            if (!canvas) return;
            
            const improvement = analysis.multiRaceComparison.improvement;
            const labels = improvement.map(r => `Race ${parseInt(r.race) + 1}`);
            
            new Chart(canvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Avg VMG',
                            data: improvement.map(r => r.vmg),
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            yAxisID: 'y',
                            borderWidth: 3,
                            pointRadius: 5,
                            pointHoverRadius: 7
                        },
                        {
                            label: 'Tack Efficiency',
                            data: improvement.map(r => r.tackEff),
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            yAxisID: 'y1',
                            borderWidth: 2,
                            pointRadius: 4,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'Boat Handling',
                            data: improvement.map(r => r.handling),
                            borderColor: 'rgba(251, 191, 36, 1)',
                            backgroundColor: 'rgba(251, 191, 36, 0.1)',
                            yAxisID: 'y1',
                            borderWidth: 2,
                            pointRadius: 4,
                            borderDash: [2, 2]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#9CA3AF', font: { size: 11 } }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) {
                                        if (context.datasetIndex === 0) {
                                            label += context.parsed.y.toFixed(2) + ' kts';
                                        } else {
                                            label += context.parsed.y.toFixed(0) + '%';
                                        }
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#9CA3AF', font: { size: 10 } },
                            grid: { color: 'rgba(75, 85, 99, 0.2)' }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'VMG (kts)', color: '#9CA3AF' },
                            ticks: { color: '#9CA3AF' },
                            grid: { color: 'rgba(75, 85, 99, 0.3)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: 'Efficiency (%)', color: '#9CA3AF' },
                            ticks: { color: '#9CA3AF' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
            
            console.log("üìà Learning curve chart created");
        }

        function getScatterOptions(xLabel, yLabel, xMin, xMax, yMin, yMax) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            
            const opts = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { 
                        display: false 
                    } 
                },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        },
                        grid: { color: '#374151' },
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        }
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        },
                        grid: { color: '#374151' },
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        }
                    }
                }
            };
            if (xMin !== null) opts.scales.x.min = xMin;
            if (xMax !== null) opts.scales.x.max = xMax;
            if (yMin !== null) opts.scales.y.min = yMin;
            if (yMax !== null) opts.scales.y.max = yMax;
            return opts;
        }

        function getBarOptions(xLabel, yLabel) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false } },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        grid: { color: '#374151' }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    }
                }
            };
        }

        function getLineOptions(xLabel, yLabel) {
            // Responsive font sizes - bigger on mobile
            const isMobile = window.innerWidth <= 768;
            const fontSize = isMobile ? 14 : 12;
            const titleSize = isMobile ? 16 : 14;
            const legendSize = isMobile ? 15 : 11; // Increased from 13 to 15
            
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { 
                    legend: { 
                        display: true, 
                        labels: { 
                            color: '#9CA3AF',
                            font: { 
                                size: legendSize,
                                weight: 'bold'
                            },
                            padding: isMobile ? 12 : 10,
                            boxWidth: isMobile ? 20 : 15
                        } 
                    } 
                },
                scales: {
                    x: { 
                        title: { 
                            display: true, 
                            text: xLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    },
                    y: { 
                        title: { 
                            display: true, 
                            text: yLabel, 
                            color: '#9CA3AF',
                            font: { size: titleSize, weight: 'bold' }
                        }, 
                        grid: { color: '#374151' }, 
                        ticks: { 
                            color: '#9CA3AF',
                            font: { size: fontSize }
                        } 
                    }
                }
            };
        }

        function initMap() {
            if (!analysis || !analysis.trackData) {
                console.error("‚ùå Map init failed: No analysis data");
                return;
            }

            console.log(`üìç Track data length: ${analysis.trackData.length}`);
            console.log(`üìç First track point:`, analysis.trackData[0]);

            const gpsPoints = analysis.trackData
                .map(d => ({ 
                    lat: d.latitude || d.lat, 
                    lon: d.longitude || d.lon, 
                    vmg: d.vmg, 
                    isLift: d.isLift,
                    isHeader: d.isHeader,
                    shiftAmount: d.shiftAmount 
                }))
                .filter(p => p.lat && p.lon && !isNaN(p.lat) && !isNaN(p.lon));

            console.log(`üìç Filtered GPS points: ${gpsPoints.length}`);
            if (gpsPoints.length > 0) {
                console.log(`üìç First GPS point:`, gpsPoints[0]);
            }

            if (gpsPoints.length === 0) {
                document.getElementById('map').innerHTML = '<div class="flex items-center justify-center h-full text-gray-500 p-6" style="min-height: 400px;"><div class="text-center"><div class="text-4xl mb-2">üìç</div><div>No valid GPS coordinates found in data</div><div class="text-sm text-gray-400 mt-2">Check CSV has latitude/longitude columns</div></div></div>';
                console.error("‚ùå No valid GPS points found");
                console.log("üìã Available fields:", Object.keys(analysis.trackData[0] || {}));
                return;
            }

            console.log(`‚úÖ ${gpsPoints.length} GPS points ready for mapping`);

            // Check if Leaflet is available (might be blocked by CSP)
            if (typeof L === 'undefined') {
                console.warn("‚ö†Ô∏è Leaflet library blocked by Content Security Policy");
                document.getElementById('map').innerHTML = `
                    <div class="p-6 bg-yellow-900 bg-opacity-20 border border-yellow-600 rounded">
                        <h4 class="text-yellow-400 font-bold mb-2">‚ö†Ô∏è GPS Map Unavailable in Preview Mode</h4>
                        <p class="text-sm text-gray-300 mb-3">External map library blocked by browser security policy.</p>
                        <p class="text-xs text-gray-400 mb-3"><strong>To view full GPS track visualization:</strong></p>
                        <ol class="text-xs text-gray-400 list-decimal ml-5 space-y-1 mb-4">
                            <li>Click the download button below to save this HTML file</li>
                            <li>Open the downloaded file directly in Chrome or Firefox</li>
                            <li>GPS map will render with full track, laylines, and markers</li>
                        </ol>
                        <div class="mt-4 p-3 bg-gray-800 rounded">
                            <div class="text-xs text-gray-400 font-semibold mb-2">GPS Data Summary (${gpsPoints.length} points):</div>
                            <div class="grid grid-cols-2 gap-2 text-xs text-gray-300">
                                <div>Lat Range: ${Math.min(...gpsPoints.map(p => p.lat)).toFixed(4)}¬∞ to ${Math.max(...gpsPoints.map(p => p.lat)).toFixed(4)}¬∞</div>
                                <div>Lon Range: ${Math.min(...gpsPoints.map(p => p.lon)).toFixed(4)}¬∞ to ${Math.max(...gpsPoints.map(p => p.lon)).toFixed(4)}¬∞</div>
                                <div>Lifts detected: ${gpsPoints.filter(p => p.isLift).length}</div>
                                <div>Headers detected: ${gpsPoints.filter(p => p.isHeader).length}</div>
                            </div>
                        </div>
                    </div>
                `;
                return;
            }

            console.log(`üó∫Ô∏è Initializing map with ${gpsPoints.length} GPS points`);

            const lats = gpsPoints.map(p => p.lat);
            const lons = gpsPoints.map(p => p.lon);
            const centerLat = (Math.max(...lats) + Math.min(...lats)) / 2;
            const centerLon = (Math.max(...lons) + Math.min(...lons)) / 2;

            if (map) map.remove();
            map = L.map('map').setView([centerLat, centerLon], 14);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap',
                maxZoom: 19
            }).addTo(map);

            // VMG-based coloring
            const vmgValues = gpsPoints.map(p => Math.abs(p.vmg || 0));
            const maxVMG = Math.max(...vmgValues);
            const minVMG = Math.min(...vmgValues);
            const getColor = (vmg) => {
                const absVMG = Math.abs(vmg);
                const ratio = maxVMG > 0 ? (absVMG - minVMG) / (maxVMG - minVMG) : 0;
                if (ratio > 0.75) return '#10B981';  // Green - excellent VMG
                if (ratio > 0.5) return '#3B82F6';   // Blue - good VMG
                if (ratio > 0.25) return '#FBBF24';  // Yellow - moderate VMG
                return '#EF4444';                    // Red - poor VMG
            };

            // Draw GPS track
            for (let i = 0; i < gpsPoints.length - 1; i++) {
                const p1 = gpsPoints[i];
                const p2 = gpsPoints[i + 1];
                L.polyline([[p1.lat, p1.lon], [p2.lat, p2.lon]], {
                    color: getColor(p1.vmg),
                    weight: 3,
                    opacity: 0.7
                }).addTo(map);
            }

            // Add wind shift markers (significant lifts/headers >5¬∞)
            gpsPoints.forEach((p, i) => {
                if (p.isLift && i % 20 === 0) {  // Sample every 20th point to avoid clutter
                    L.circleMarker([p.lat, p.lon], {
                        radius: 4,
                        fillColor: '#10B981',
                        color: '#ffffff',
                        weight: 1,
                        fillOpacity: 0.9
                    }).addTo(map).bindPopup(`<b>Lift</b><br/>${Math.abs(p.shiftAmount).toFixed(1)}¬∞ favorable`);
                } else if (p.isHeader && i % 20 === 0) {
                    L.circleMarker([p.lat, p.lon], {
                        radius: 4,
                        fillColor: '#EF4444',
                        color: '#ffffff',
                        weight: 1,
                        fillOpacity: 0.9
                    }).addTo(map).bindPopup(`<b>Header</b><br/>${Math.abs(p.shiftAmount).toFixed(1)}¬∞ unfavorable`);
                }
            });

            // Add maneuver markers
            if (analysis.maneuvers) {
                analysis.maneuvers.forEach((m) => {
                    if (m.lat && m.lon) {
                        const markerColor = m.type === 'Tack' ? '#3B82F6' : '#F59E0B';
                        L.circleMarker([m.lat, m.lon], {
                            radius: 3,
                            fillColor: '#1F2937',
                            color: markerColor,
                            weight: 1,
                            fillOpacity: 0.8
                        }).addTo(map).bindPopup(`
                            <b>${m.type} #${m.tackNumber}</b><br/>
                            Efficiency: ${m.efficiency.toFixed(0)}%<br/>
                            Entry: ${m.entrySpeed.toFixed(1)} kts<br/>
                            Exit: ${m.exitSpeed.toFixed(1)} kts<br/>
                            Loss: ${m.distanceLost.toFixed(1)}m
                        `);
                    }
                });
            }

            console.log("‚úÖ Map rendered");
        }

        function showError(message) {
            document.getElementById('mainContent').innerHTML = `
                <div class="flex items-center justify-center" style="min-height: 400px;">
                    <div class="text-center text-red-400">
                        <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                        <p class="text-xl">${message}</p>
                    </div>
                </div>
            `;
        }

        function generatePDF() {
            alert("generatePDF function called!");
            console.log("üîµ PDF generation started");
            
            if (!analysis) {
                alert("No analysis data available. Please load a CSV file first.");
                console.error("‚ùå No analysis data");
                return;
            }
            
            alert("Analysis data exists, checking jsPDF library...");
            console.log("‚úÖ Analysis data exists:", analysis);
            
            if (typeof window.jspdf === 'undefined') {
                alert("PDF library not loaded. Please refresh the page and try again.");
                console.error("‚ùå jsPDF library not available");
                return;
            }
            
            console.log("‚úÖ jsPDF library loaded");
            
            // Show loading state
            const btn = document.getElementById('generatePDF');
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚è≥ Generating PDF...';
            btn.disabled = true;
            
            try {
                const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            let y = 20;
            
            // TITLE PAGE WITH BRANDING
            pdf.setFillColor(15, 23, 42); // Dark blue-gray
            pdf.rect(0, 0, pageWidth, 70, 'F');
            
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(28);
            pdf.setFont(undefined, 'bold');
            pdf.text('‚õµ SAILING', pageWidth / 2, 30, { align: 'center' });
            pdf.setFontSize(32);
            pdf.text('PERFORMANCE REPORT', pageWidth / 2, 45, { align: 'center' });
            
            pdf.setFontSize(11);
            pdf.setFont(undefined, 'normal');
            const date = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            pdf.text(date, pageWidth / 2, 58, { align: 'center' });
            
            y = 85;
            pdf.setTextColor(0, 0, 0);
            
            // EXECUTIVE SUMMARY with colored boxes
            pdf.setFontSize(18);
            pdf.setFont(undefined, 'bold');
            pdf.setTextColor(15, 23, 42);
            pdf.text('EXECUTIVE SUMMARY', 20, y);
            pdf.setTextColor(0, 0, 0);
            y += 2;
            pdf.setLineWidth(0.5);
            pdf.setDrawColor(59, 130, 246);
            pdf.line(20, y, 80, y);
            y += 10;
            
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'normal');
            
            // Three key metric boxes side by side
            const boxWidth = 56;
            const boxHeight = 28;
            const spacing = 6;
            let boxX = 20;
            
            // Box 1: Boat Handling
            pdf.setFillColor(37, 99, 235);
            pdf.roundedRect(boxX, y, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(8);
            pdf.text('BOAT HANDLING SCORE', boxX + boxWidth/2, y + 6, { align: 'center' });
            pdf.setFontSize(24);
            pdf.setFont(undefined, 'bold');
            pdf.text(analysis.boatHandlingScore.toFixed(0), boxX + boxWidth/2, y + 18, { align: 'center' });
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'normal');
            pdf.text('/100', boxX + boxWidth/2 + 8, y + 18, { align: 'center' });
            pdf.setFontSize(7);
            pdf.text(analysis.boatHandlingScore >= 80 ? '‚úì EXCELLENT' : analysis.boatHandlingScore >= 60 ? 'GOOD' : 'NEEDS WORK', boxX + boxWidth/2, y + 24, { align: 'center' });
            
            boxX += boxWidth + spacing;
            
            // Box 2: VMG Efficiency
            pdf.setFillColor(147, 51, 234);
            pdf.roundedRect(boxX, y, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setFontSize(8);
            pdf.text('VMG EFFICIENCY', boxX + boxWidth/2, y + 6, { align: 'center' });
            pdf.setFontSize(24);
            pdf.setFont(undefined, 'bold');
            pdf.text(analysis.vmgEfficiency.toFixed(0) + '%', boxX + boxWidth/2, y + 18, { align: 'center' });
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            pdf.text(`${analysis.avgVMG.toFixed(2)} / ${analysis.bestVMG.toFixed(2)} kts`, boxX + boxWidth/2, y + 24, { align: 'center' });
            
            boxX += boxWidth + spacing;
            
            // Box 3: Tack Efficiency
            pdf.setFillColor(234, 179, 8);
            pdf.roundedRect(boxX, y, boxWidth, boxHeight, 3, 3, 'F');
            pdf.setFontSize(8);
            pdf.text('TACK EFFICIENCY', boxX + boxWidth/2, y + 6, { align: 'center' });
            pdf.setFontSize(24);
            pdf.setFont(undefined, 'bold');
            pdf.text(analysis.tackEfficiency.toFixed(0) + '%', boxX + boxWidth/2, y + 18, { align: 'center' });
            pdf.setFontSize(7);
            pdf.setFont(undefined, 'normal');
            pdf.text(`${analysis.tacks} maneuvers`, boxX + boxWidth/2, y + 24, { align: 'center' });
            
            y += boxHeight + 15;
            pdf.setTextColor(0, 0, 0);
            
            // PERFORMANCE METRICS TABLE
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('Performance Metrics', 20, y);
            y += 8;
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            
            const metrics = [
                ['Metric', 'Upwind', 'Downwind', 'Assessment'],
                ['Optimal Heel Angle', `${analysis.optimalHeelUp}¬∞`, `${analysis.optimalHeelDown}¬∞`, analysis.heelDataQuality.reliable ? '‚úì Reliable' : '‚ö† Limited Data'],
                ['Optimal Trim', `${analysis.optimalTrimUp > 0 ? '+' : ''}${analysis.optimalTrimUp}¬∞`, `${analysis.optimalTrimDown > 0 ? '+' : ''}${analysis.optimalTrimDown}¬∞`, ''],
                ['Average Speed', `${analysis.avgUpwindSpeed.toFixed(1)} kts`, `${analysis.avgDownwindSpeed.toFixed(1)} kts`, ''],
                ['Speed Ratio', '-', `${analysis.speedRatio.toFixed(2)}x`, analysis.speedRatio > 1.3 ? 'Good' : 'Fair'],
                ['Best Pointing', `${analysis.bestPointing.toFixed(1)}¬∞`, '-', analysis.bestPointing < 35 ? 'Excellent' : 'Good'],
                ['Average Leeway', `${analysis.leeway.toFixed(1)}¬∞`, '-', analysis.leeway < 8 ? 'Good' : '‚ö† High'],
                ['Distance Efficiency', '-', '-', `${analysis.distanceEfficiency.toFixed(0)}%`],
            ];
            
            const colWidths = [60, 30, 30, 40];
            const rowHeight = 6;
            
            metrics.forEach((row, idx) => {
                let x = 20;
                
                if (idx === 0) {
                    // Header row
                    pdf.setFont(undefined, 'bold');
                    pdf.setFillColor(241, 245, 249);
                    pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight, 'F');
                    pdf.setDrawColor(203, 213, 225);
                    pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight);
                } else {
                    pdf.setFont(undefined, 'normal');
                    if (idx % 2 === 0) {
                        pdf.setFillColor(249, 250, 251);
                        pdf.rect(x, y - 4, colWidths.reduce((a,b) => a+b, 0), rowHeight, 'F');
                    }
                }
                
                row.forEach((cell, colIdx) => {
                    pdf.text(cell, x + 2, y);
                    x += colWidths[colIdx];
                });
                
                y += rowHeight;
            });
            
            y += 10;
            
            // VISUAL: GPS Track Representation
            if (y > 220) {
                pdf.addPage();
                y = 20;
            }
            
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('GPS Track Overview', 20, y);
            y += 8;
            
            // Simple track visualization
            const trackData = analysis.trackData.filter(d => d.lat && d.lon);
            if (trackData.length > 100) {
                const lats = trackData.map(d => d.latitude || d.lat);
                const lons = trackData.map(d => d.longitude || d.lon);
                const minLat = Math.min(...lats);
                const maxLat = Math.max(...lats);
                const minLon = Math.min(...lons);
                const maxLon = Math.max(...lons);
                
                // Scale to fit in 160x80mm box
                const boxWidth = 160;
                const boxHeight = 80;
                const startX = 25;
                const startY = y + 5;
                
                // Draw background
                pdf.setFillColor(240, 245, 250);
                pdf.rect(startX, startY, boxWidth, boxHeight, 'F');
                
                // Draw track
                const sample = Math.max(1, Math.floor(trackData.length / 300)); // Sample points
                pdf.setDrawColor(59, 130, 246);
                pdf.setLineWidth(0.3);
                
                for (let i = 0; i < trackData.length - sample; i += sample) {
                    const d1 = trackData[i];
                    const d2 = trackData[i + sample];
                    
                    const x1 = startX + ((d1.longitude || d1.lon) - minLon) / (maxLon - minLon) * boxWidth;
                    const y1 = startY + boxHeight - ((d1.latitude || d1.lat) - minLat) / (maxLat - minLat) * boxHeight;
                    const x2 = startX + ((d2.longitude || d2.lon) - minLon) / (maxLon - minLon) * boxWidth;
                    const y2 = startY + boxHeight - ((d2.latitude || d2.lat) - minLat) / (maxLat - minLat) * boxHeight;
                    
                    // Color by VMG
                    const vmg = Math.abs(d1.vmg || 0);
                    if (vmg > 4) {
                        pdf.setDrawColor(16, 185, 129); // Green
                    } else if (vmg > 3) {
                        pdf.setDrawColor(59, 130, 246); // Blue
                    } else if (vmg > 2) {
                        pdf.setDrawColor(251, 191, 36); // Yellow
                    } else {
                        pdf.setDrawColor(239, 68, 68); // Red
                    }
                    
                    pdf.line(x1, y1, x2, y2);
                }
                
                // Draw maneuver markers
                if (analysis.maneuvers) {
                    analysis.maneuvers.forEach(m => {
                        if (m.lat && m.lon) {
                            const mx = startX + (m.lon - minLon) / (maxLon - minLon) * boxWidth;
                            const my = startY + boxHeight - (m.lat - minLat) / (maxLat - minLat) * boxHeight;
                            const markerColor = m.type === 'Tack' ? [59, 130, 246] : [251, 146, 60];
                            pdf.setFillColor(...markerColor);
                            pdf.circle(mx, my, 1, 'F');
                        }
                    });
                }
                
                // Legend
                y = startY + boxHeight + 8;
                pdf.setFontSize(7);
                pdf.setTextColor(0, 0, 0);
                pdf.text('Track colored by VMG:', startX, y);
                pdf.setFillColor(16, 185, 129);
                pdf.circle(startX + 35, y - 1, 1, 'F');
                pdf.text('Excellent', startX + 37, y);
                pdf.setFillColor(59, 130, 246);
                pdf.circle(startX + 55, y - 1, 1, 'F');
                pdf.text('Good', startX + 57, y);
                pdf.setFillColor(251, 191, 36);
                pdf.circle(startX + 70, y - 1, 1, 'F');
                pdf.text('Moderate', startX + 72, y);
                pdf.setFillColor(239, 68, 68);
                pdf.circle(startX + 90, y - 1, 1, 'F');
                pdf.text('Poor', startX + 92, y);
                
                y += 8;
            }
            
            // VISUAL: Simple Performance Charts
            if (y > 220) {
                pdf.addPage();
                y = 20;
            }
            
            y += 5;
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('Performance Charts', 20, y);
            y += 10;
            
            // Maneuver efficiency comparison (simple bar chart)
            if (analysis.tacks.length > 0 || analysis.gybes.length > 0) {
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('Tack vs Gybe Efficiency', 20, y);
                y += 8;
                
                const barWidth = 60;
                const barHeight = 30;
                const maxEff = 100;
                
                // Tack bar
                pdf.setFillColor(59, 130, 246);
                const tackBarHeight = (analysis.tackEfficiency / maxEff) * barHeight;
                pdf.rect(25, y + barHeight - tackBarHeight, barWidth, tackBarHeight, 'F');
                pdf.setFontSize(8);
                pdf.setFont(undefined, 'normal');
                pdf.text(`Tacks: ${analysis.tackEfficiency.toFixed(0)}%`, 27, y + barHeight + 5);
                
                // Gybe bar
                pdf.setFillColor(251, 146, 60);
                const gybeBarHeight = (analysis.gybeEfficiency / maxEff) * barHeight;
                pdf.rect(100, y + barHeight - gybeBarHeight, barWidth, gybeBarHeight, 'F');
                pdf.text(`Gybes: ${analysis.gybeEfficiency.toFixed(0)}%`, 102, y + barHeight + 5);
                
                // Axis
                pdf.setDrawColor(100, 100, 100);
                pdf.setLineWidth(0.5);
                pdf.line(25, y + barHeight, 165, y + barHeight);
                
                y += barHeight + 15;
            }
            
            // VMG Distribution (simple bar chart)
            y += 5;
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Speed Distribution', 20, y);
            y += 8;
            
            const speedBins = [
                { range: '0-3', upwind: 0, downwind: 0 },
                { range: '3-5', upwind: 0, downwind: 0 },
                { range: '5-7', upwind: 0, downwind: 0 },
                { range: '7+', upwind: 0, downwind: 0 }
            ];
            
            analysis.trackData.forEach(d => {
                const s = d.speed || 0;
                const binIdx = s < 3 ? 0 : s < 5 ? 1 : s < 7 ? 2 : 3;
                if (d.isUpwind) {
                    speedBins[binIdx].upwind++;
                } else {
                    speedBins[binIdx].downwind++;
                }
            });
            
            const maxCount = Math.max(...speedBins.flatMap(b => [b.upwind, b.downwind]));
            const chartWidth = 140;
            const chartHeight = 35;
            const barSpacing = 4;
            const groupWidth = chartWidth / speedBins.length;
            
            speedBins.forEach((bin, idx) => {
                const x = 25 + idx * groupWidth;
                
                // Upwind bar
                pdf.setFillColor(16, 185, 129);
                const upwindHeight = (bin.upwind / maxCount) * chartHeight;
                pdf.rect(x, y + chartHeight - upwindHeight, (groupWidth - barSpacing) / 2, upwindHeight, 'F');
                
                // Downwind bar
                pdf.setFillColor(59, 130, 246);
                const downwindHeight = (bin.downwind / maxCount) * chartHeight;
                pdf.rect(x + (groupWidth - barSpacing) / 2, y + chartHeight - downwindHeight, (groupWidth - barSpacing) / 2, downwindHeight, 'F');
                
                // Label
                pdf.setFontSize(7);
                pdf.setTextColor(0, 0, 0);
                pdf.text(bin.range, x + groupWidth / 2 - 3, y + chartHeight + 4);
            });
            
            // Legend
            pdf.setFillColor(16, 185, 129);
            pdf.rect(25, y + chartHeight + 8, 3, 3, 'F');
            pdf.setFontSize(7);
            pdf.text('Upwind', 30, y + chartHeight + 10);
            pdf.setFillColor(59, 130, 246);
            pdf.rect(50, y + chartHeight + 8, 3, 3, 'F');
            pdf.text('Downwind', 55, y + chartHeight + 10);
            
            y += chartHeight + 18;
            
            // COACHING RECOMMENDATIONS
            if (analysis.coachingTips && analysis.coachingTips.length > 0) {
                if (y > 220) {
                    pdf.addPage();
                    y = 20;
                }
                
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Coaching Recommendations', 20, y);
                y += 2;
                pdf.setLineWidth(0.5);
                pdf.setDrawColor(34, 197, 94);
                pdf.line(20, y, 95, y);
                y += 10;
                
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                
                analysis.coachingTips.forEach((tip, i) => {
                    if (y > 260) {
                        pdf.addPage();
                        y = 20;
                    }
                    
                    // Priority badge
                    const badgeColor = tip.priority === 'high' ? [239, 68, 68] : [251, 191, 36];
                    pdf.setFillColor(...badgeColor);
                    pdf.roundedRect(20, y - 3, 18, 5, 1, 1, 'F');
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFontSize(7);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(tip.priority.toUpperCase(), 22, y);
                    
                    // Tip content
                    pdf.setTextColor(0, 0, 0);
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${i + 1}. ${tip.category}`, 41, y);
                    y += 6;
                    
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    const messageLines = pdf.splitTextToSize(tip.message, 165);
                    pdf.text(messageLines, 23, y);
                    y += messageLines.length * 4.5;
                    
                    pdf.setFillColor(240, 253, 244);
                    pdf.roundedRect(23, y, 165, 7, 1, 1, 'F');
                    pdf.setTextColor(22, 163, 74);
                    pdf.setFontSize(8);
                    pdf.text(`‚ö° Potential Performance Gain: ${tip.impact}`, 26, y + 4.5);
                    pdf.setTextColor(0, 0, 0);
                    y += 10;
                });
            }
            
            // WIND & TACTICAL ANALYSIS
            if (y > 200) {
                pdf.addPage();
                y = 20;
            }
            
            pdf.setFontSize(14);
            pdf.setFont(undefined, 'bold');
            pdf.text('Wind & Tactical Analysis', 20, y);
            y += 2;
            pdf.setDrawColor(234, 179, 8);
            pdf.line(20, y, 85, y);
            y += 10;
            
            // Predominant Headings Box
            pdf.setFillColor(254, 252, 232);
            pdf.setDrawColor(234, 179, 8);
            pdf.setLineWidth(1);
            pdf.roundedRect(20, y, 170, 35, 2, 2, 'FD');
            
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('üß≠ Auto-Detected Wind Direction', 25, y + 7);
            
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            pdf.text(`Starboard Tack Heading:`, 25, y + 14);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${analysis.predominantHeadings.peak1}¬∞`, 70, y + 14);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(${analysis.predominantHeadings.peak1Count} samples)`, 85, y + 14);
            
            pdf.text(`Port Tack Heading:`, 25, y + 20);
            pdf.setFont(undefined, 'bold');
            pdf.text(`${analysis.predominantHeadings.peak2}¬∞`, 70, y + 20);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(${analysis.predominantHeadings.peak2Count} samples)`, 85, y + 20);
            
            pdf.setFillColor(37, 99, 235);
            pdf.roundedRect(25, y + 24, 70, 7, 1, 1, 'F');
            pdf.setTextColor(255, 255, 255);
            pdf.setFont(undefined, 'bold');
            pdf.text(`Estimated Wind: ${analysis.predominantHeadings.estimatedWindDir.toFixed(0)}¬∞`, 28, y + 29);
            pdf.setFont(undefined, 'normal');
            pdf.text(`(Avg TWA: ${analysis.predominantHeadings.avgTWA.toFixed(0)}¬∞)`, 75, y + 29);
            
            pdf.setTextColor(0, 0, 0);
            y += 42;
            
            // Wind Shift Statistics
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Wind Shift Performance:', 20, y);
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(9);
            y += 6;
            
            const liftColor = analysis.windAnalysis.liftPct > 45 ? [22, 163, 74] : [234, 179, 8];
            pdf.setTextColor(...liftColor);
            pdf.text(`‚Ä¢ Sailing on Lifts: ${analysis.windAnalysis.liftPct.toFixed(1)}%`, 23, y);
            pdf.setTextColor(0, 0, 0);
            pdf.text(`(avg ${analysis.windAnalysis.avgLiftAngle.toFixed(1)}¬∞ benefit)`, 70, y);
            y += 5;
            
            pdf.setTextColor(239, 68, 68);
            pdf.text(`‚Ä¢ Sailing on Headers: ${analysis.windAnalysis.headerPct.toFixed(1)}%`, 23, y);
            pdf.setTextColor(0, 0, 0);
            pdf.text(`(avg ${analysis.windAnalysis.avgHeaderAngle.toFixed(1)}¬∞ penalty)`, 70, y);
            y += 8;
            
            // Course Bias
            pdf.setFontSize(10);
            pdf.setFont(undefined, 'bold');
            pdf.text('Course Balance:', 20, y);
            pdf.setFont(undefined, 'normal');
            pdf.setFontSize(9);
            y += 6;
            
            pdf.text(`‚Ä¢ Port Tack: ${analysis.courseBias.portPct.toFixed(1)}%`, 23, y);
            y += 5;
            pdf.text(`‚Ä¢ Starboard Tack: ${analysis.courseBias.starboardPct.toFixed(1)}%`, 23, y);
            y += 6;
            
            const biasDiff = Math.abs(analysis.courseBias.portPct - 50);
            if (biasDiff > 20) {
                pdf.setFillColor(254, 243, 199);
                pdf.roundedRect(23, y, 165, 8, 1, 1, 'F');
                pdf.setTextColor(180, 83, 9);
                pdf.text(`‚ö† Significant ${biasDiff.toFixed(0)}% bias toward ${analysis.courseBias.portPct > 50 ? 'port' : 'starboard'} - verify if this matches favored side`, 26, y + 5);
                pdf.setTextColor(0, 0, 0);
                y += 10;
            } else {
                pdf.setTextColor(22, 163, 74);
                pdf.text('‚úì Well-balanced course - good tactical execution', 23, y);
                pdf.setTextColor(0, 0, 0);
                y += 7;
            }
            
            // MANEUVER ANALYSIS
            if (analysis.maneuvers && analysis.maneuvers.length > 0) {
                if (y > 200) {
                    pdf.addPage();
                    y = 20;
                }
                
                y += 5;
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Maneuver Analysis', 20, y);
                y += 2;
                pdf.setDrawColor(239, 68, 68);
                pdf.line(20, y, 70, y);
                y += 10;
                
                // Summary boxes
                const boxHeight = 20;
                const boxWidth = 80;
                
                // Tacks box
                if (analysis.tacks.length > 0) {
                    pdf.setFillColor(59, 130, 246);
                    pdf.roundedRect(20, y, boxWidth, boxHeight, 2, 2, 'F');
                    pdf.setTextColor(255, 255, 255);
                    pdf.setFontSize(8);
                    pdf.text('TACKS', 25, y + 6);
                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${analysis.tacks.length}`, 25, y + 14);
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    pdf.text(`Avg: ${analysis.tackEfficiency.toFixed(0)}%`, 45, y + 14);
                    
                    // Gybes box
                    pdf.setFillColor(251, 146, 60);
                    pdf.roundedRect(20 + boxWidth + 5, y, boxWidth, boxHeight, 2, 2, 'F');
                    pdf.setFontSize(8);
                    pdf.text('GYBES', 30 + boxWidth, y + 6);
                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.text(`${analysis.gybes.length}`, 30 + boxWidth, y + 14);
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'normal');
                    pdf.text(`Avg: ${analysis.gybeEfficiency.toFixed(0)}%`, 50 + boxWidth, y + 14);
                    
                    y += boxHeight + 10;
                    pdf.setTextColor(0, 0, 0);
                    
                    // Key insights box
                    pdf.setFillColor(241, 245, 249);
                    pdf.roundedRect(20, y, 170, 25, 2, 2, 'F');
                    pdf.setFontSize(9);
                    pdf.setFont(undefined, 'bold');
                    pdf.text('üìä Performance Insights:', 25, y + 6);
                    pdf.setFont(undefined, 'normal');
                    pdf.setFontSize(8);
                    pdf.text(`‚Ä¢ Entry/Exit scatter plots show direct speed retention through maneuvers`, 25, y + 12);
                    pdf.text(`‚Ä¢ Green dots = minimal distance lost, Red dots = significant loss`, 25, y + 17);
                    pdf.text(`‚Ä¢ View interactive charts in web app for detailed analysis of each maneuver`, 25, y + 22);
                    
                    y += 30;
                }
                
                // Top performers
                const sortedTacks = [...analysis.tacks].sort((a, b) => b.efficiency - a.efficiency);
                const sortedGybes = [...analysis.gybes].sort((a, b) => b.efficiency - a.efficiency);
                
                if (sortedTacks.length > 0) {
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(59, 130, 246);
                    pdf.text('Top 3 Tacks:', 20, y);
                    pdf.setTextColor(0, 0, 0);
                    y += 6;
                    
                    pdf.setFontSize(8);
                    pdf.setFont(undefined, 'normal');
                    sortedTacks.slice(0, 3).forEach((m, i) => {
                        const effColor = m.efficiency >= 90 ? [22, 163, 74] : [234, 179, 8];
                        pdf.setTextColor(...effColor);
                        pdf.text(`T${m.tackNumber}`, 23, y);
                        pdf.setTextColor(0, 0, 0);
                        pdf.text(`${m.efficiency.toFixed(0)}%  ${m.entrySpeed.toFixed(1)}‚Üí${m.exitSpeed.toFixed(1)} kts  -${m.distanceLost.toFixed(0)}m`, 33, y);
                        y += 4;
                    });
                    y += 4;
                }
                
                if (sortedGybes.length > 0) {
                    pdf.setFontSize(10);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(251, 146, 60);
                    pdf.text('Top 3 Gybes:', 20, y);
                    pdf.setTextColor(0, 0, 0);
                    y += 6;
                    
                    pdf.setFontSize(8);
                    pdf.setFont(undefined, 'normal');
                    sortedGybes.slice(0, 3).forEach((m, i) => {
                        const effColor = m.efficiency >= 90 ? [22, 163, 74] : [234, 179, 8];
                        pdf.setTextColor(...effColor);
                        pdf.text(`G${m.tackNumber}`, 23, y);
                        pdf.setTextColor(0, 0, 0);
                        pdf.text(`${m.efficiency.toFixed(0)}%  ${m.entrySpeed.toFixed(1)}‚Üí${m.exitSpeed.toFixed(1)} kts  -${m.distanceLost.toFixed(0)}m`, 33, y);
                        y += 4;
                    });
                }
            }
            
            // DATA QUALITY & DISCLAIMERS
            if (!analysis.heelDataQuality.reliable) {
                if (y > 230) {
                    pdf.addPage();
                    y = 20;
                }
                
                y += 10;
                pdf.setFillColor(254, 243, 199);
                pdf.setDrawColor(234, 179, 8);
                pdf.setLineWidth(1);
                pdf.roundedRect(20, y, 170, 30, 2, 2, 'FD');
                pdf.setTextColor(180, 83, 9);
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'bold');
                pdf.text('‚ö† Data Quality Notice', 25, y + 7);
                pdf.setFontSize(9);
                pdf.setFont(undefined, 'normal');
                const warningLines = pdf.splitTextToSize(
                    `This analysis is based on ${analysis.heelDataQuality.upwindSamples} upwind data points. For statistically reliable heel angle optimization, we recommend at least 500 data points. The reported optimal heel angle of ${analysis.optimalHeelUp}¬∞ should be validated with additional sailing sessions. Consider using the "All Races" view to combine multiple sessions for more reliable results.`,
                    160
                );
                pdf.text(warningLines, 25, y + 14);
                pdf.setTextColor(0, 0, 0);
                y += 33;
            }
            
            // CALL TO ACTION & FOOTER
            if (y > 230) {
                pdf.addPage();
                y = 20;
            }
            
            y += 10;
            pdf.setFillColor(15, 23, 42);
            pdf.roundedRect(20, y, 170, 25, 2, 2, 'F');
            
            pdf.setTextColor(255, 255, 255);
            pdf.setFontSize(12);
            pdf.setFont(undefined, 'bold');
            pdf.text('Want More Detailed Analysis?', pageWidth / 2, y + 8, { align: 'center' });
            pdf.setFontSize(9);
            pdf.setFont(undefined, 'normal');
            pdf.text('View interactive charts, GPS track maps, and real-time performance', pageWidth / 2, y + 14, { align: 'center' });
            pdf.text('metrics in the full web application at claude.ai/sailing-coach', pageWidth / 2, y + 19, { align: 'center' });
            
            // Footer
            pdf.setTextColor(128, 128, 128);
            pdf.setFontSize(7);
            pdf.text('Generated by Sailing Coach Analysis Tool  ‚Ä¢  Data-driven performance optimization for competitive sailors', pageWidth / 2, pageHeight - 10, { align: 'center' });
            
            console.log("‚úÖ PDF ready to save");
            pdf.save('sailing-performance-report.pdf');
            console.log("‚úÖ PDF saved successfully");
            
            // Restore button
            btn.innerHTML = originalText;
            btn.disabled = false;
            
            alert("‚úÖ PDF generated successfully! Check your Downloads folder.");
            
            } catch (error) {
                console.error("‚ùå PDF generation error:", error);
                console.error("Error stack:", error.stack);
                
                // Restore button
                btn.innerHTML = originalText;
                btn.disabled = false;
                
                alert("‚ùå Error generating PDF: " + error.message + "\n\nTry:\n1. Use Chrome or Safari (not in-app browser)\n2. Disable content blockers\n3. Check browser console for details");
            }
        }

        function setupMarkPlacement() {
            if (!map) return;
            
            map.on('click', function(e) {
                if (markMode === 'startline') {
                    // Start line drawing mode
                    startLinePins.push({lat: e.latlng.lat, lon: e.latlng.lng});
                    
                    if (startLinePins.length === 1) {
                        // Place first pin
                        L.marker([startLinePins[0].lat, startLinePins[0].lon], {
                            icon: L.divIcon({
                                className: 'start-pin',
                                html: '<div style="width: 10px; height: 10px; background: #3B82F6; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Start Line Pin 1');
                    } else if (startLinePins.length === 2) {
                        // Place second pin and draw line
                        L.marker([startLinePins[1].lat, startLinePins[1].lon], {
                            icon: L.divIcon({
                                className: 'start-pin',
                                html: '<div style="width: 10px; height: 10px; background: #3B82F6; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Start Line Pin 2');
                        
                        // Draw start line
                        startLinePolyline = L.polyline([
                            [startLinePins[0].lat, startLinePins[0].lon],
                            [startLinePins[1].lat, startLinePins[1].lon]
                        ], {
                            color: '#3B82F6',
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '10, 8',
                            className: 'start-line'
                        }).addTo(map).bindPopup('<strong>START LINE</strong><br/>Click "‚úï Clear Line" to remove');
                        
                        // Calculate line length
                        const R = 6371; // Earth radius in km
                        const dLat = (startLinePins[1].lat - startLinePins[0].lat) * Math.PI / 180;
                        const dLon = (startLinePins[1].lon - startLinePins[0].lon) * Math.PI / 180;
                        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                Math.cos(startLinePins[0].lat * Math.PI / 180) * Math.cos(startLinePins[1].lat * Math.PI / 180) *
                                Math.sin(dLon/2) * Math.sin(dLon/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                        const distance = R * c * 1000; // in meters
                        
                        console.log(`üìè Start line drawn: ${distance.toFixed(0)}m length`);
                        
                        // Show clear line button
                        document.getElementById('clearStartLine').style.display = 'block';
                        
                        markMode = null;
                        document.getElementById('map').classList.remove('clickable');
                    }
                } else if (markMode === 'finishline') {
                    // Finish line drawing mode
                    finishLinePins.push({lat: e.latlng.lat, lon: e.latlng.lng});
                    
                    if (finishLinePins.length === 1) {
                        // Place first pin
                        L.marker([finishLinePins[0].lat, finishLinePins[0].lon], {
                            icon: L.divIcon({
                                className: 'finish-pin',
                                html: '<div style="width: 10px; height: 10px; background: #A855F7; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Finish Line Pin 1');
                    } else if (finishLinePins.length === 2) {
                        // Place second pin and draw line
                        L.marker([finishLinePins[1].lat, finishLinePins[1].lon], {
                            icon: L.divIcon({
                                className: 'finish-pin',
                                html: '<div style="width: 10px; height: 10px; background: #A855F7; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            })
                        }).addTo(map).bindPopup('Finish Line Pin 2');
                        
                        // Draw finish line
                        finishLinePolyline = L.polyline([
                            [finishLinePins[0].lat, finishLinePins[0].lon],
                            [finishLinePins[1].lat, finishLinePins[1].lon]
                        ], {
                            color: '#A855F7',
                            weight: 4,
                            opacity: 0.8,
                            dashArray: '10, 8',
                            className: 'finish-line'
                        }).addTo(map).bindPopup('<strong>FINISH LINE</strong><br/>Click "‚úï Finish" to remove');
                        
                        // Calculate line length
                        const R = 6371; // Earth radius in km
                        const dLat = (finishLinePins[1].lat - finishLinePins[0].lat) * Math.PI / 180;
                        const dLon = (finishLinePins[1].lon - finishLinePins[0].lon) * Math.PI / 180;
                        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                Math.cos(finishLinePins[0].lat * Math.PI / 180) * Math.cos(finishLinePins[1].lat * Math.PI / 180) *
                                Math.sin(dLon/2) * Math.sin(dLon/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                        const distance = R * c * 1000; // in meters
                        
                        console.log(`üèÅ Finish line drawn: ${distance.toFixed(0)}m length`);
                        
                        // Show clear line button
                        document.getElementById('clearFinishLine').style.display = 'block';
                        
                        markMode = null;
                        document.getElementById('map').classList.remove('clickable');
                    }
                } else if (markMode) {
                    // Regular mark placement
                    const mark = {
                        type: markMode,
                        lat: e.latlng.lat,
                        lon: e.latlng.lng
                    };
                    manualMarks.push(mark);
                    addMarkToMap(mark);
                    markMode = null;
                    document.getElementById('map').classList.remove('clickable');
                }
            });
        }

        function addMarkToMap(mark) {
            if (!map) return;
            
            const colors = {
                start: '#3B82F6',
                windward: '#10B981',
                leeward: '#FBBF24',
                finish: '#A855F7'
            };

            const icons = {
                start: '‚ñ≤',        // Triangle for start
                windward: '‚óè',     // Circle for windward
                leeward: '‚óÜ',      // Diamond for leeward (gate)
                finish: '‚ñ†'        // Square for finish
            };

            const marker = L.marker([mark.lat, mark.lon], {
                icon: L.divIcon({
                    className: 'custom-mark',
                    html: `<div style="background: ${colors[mark.type]}; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.3); border: 2px solid white;">${icons[mark.type]}</div>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                }),
                draggable: true  // Make marker draggable
            }).addTo(map);
            
            marker.bindPopup(`<strong>${mark.type.toUpperCase()} MARK</strong><br/><span style="font-size: 11px; color: #666;">Drag to adjust position</span>`);
            
            // Update mark position and redraw laylines when dragged
            marker.on('dragend', function(event) {
                const position = event.target.getLatLng();
                mark.lat = position.lat;
                mark.lon = position.lng;
                
                console.log(`üìç ${mark.type} mark moved to ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`);
                
                // If windward mark, redraw laylines
                if (mark.type === 'windward' && analysis && analysis.laylines) {
                    // Remove old laylines
                    map.eachLayer(layer => {
                        if (layer instanceof L.Polyline && layer.options.className === 'layline') {
                            map.removeLayer(layer);
                        }
                    });
                    // Draw new laylines from updated position
                    drawLaylines(mark.lat, mark.lon);
                }
            });
            
            // If windward mark, draw laylines
            if (mark.type === 'windward' && analysis && analysis.laylines) {
                drawLaylines(mark.lat, mark.lon);
            }
        }
        
        function drawLaylines(markLat, markLon) {
            if (!map || !analysis || !analysis.laylines) return;
            
            const windDir = analysis.laylines.windDirection;
            const pointingAngle = analysis.laylines.pointingAngle;
            
            // Calculate layline headings (these are the directions the lines extend FROM the mark)
            const portLaylineHeading = (windDir - pointingAngle + 360) % 360;
            const stbdLaylineHeading = (windDir + pointingAngle) % 360;
            
            // Convert headings to radians for math
            const portAngle = portLaylineHeading * Math.PI / 180;
            const stbdAngle = stbdLaylineHeading * Math.PI / 180;
            
            // Extend laylines ~0.02 degrees (roughly 2km at this latitude)
            const lineLength = 0.02;
            
            // Port layline (extends away from mark in direction opposite to port tack heading)
            // When you cross this line sailing on starboard, you tack to port
            const portStart = [markLat, markLon];
            const portEnd = [
                markLat - lineLength * Math.cos(portAngle),
                markLon - lineLength * Math.sin(portAngle)
            ];
            
            const portLayline = L.polyline([portStart, portEnd], {
                color: '#3B82F6',
                weight: 3,
                opacity: 0.8,
                dashArray: '15, 10',
                className: 'layline layline-port'
            }).addTo(map);
            
            portLayline.bindPopup(`
                <strong>PORT LAYLINE</strong><br/>
                Cross this line on starboard tack<br/>
                Then tack to port and sail ${analysis.laylines.portTackHeading.toFixed(0)}¬∞<br/>
                at ${pointingAngle}¬∞ TWA to reach mark
            `);
            
            // Starboard layline (extends away from mark in direction opposite to starboard tack heading)
            // When you cross this line sailing on port, you tack to starboard
            const stbdStart = [markLat, markLon];
            const stbdEnd = [
                markLat - lineLength * Math.cos(stbdAngle),
                markLon - lineLength * Math.sin(stbdAngle)
            ];
            
            const stbdLayline = L.polyline([stbdStart, stbdEnd], {
                color: '#10B981',
                weight: 3,
                opacity: 0.8,
                dashArray: '15, 10',
                className: 'layline layline-stbd'
            }).addTo(map);
            
            stbdLayline.bindPopup(`
                <strong>STARBOARD LAYLINE</strong><br/>
                Cross this line on port tack<br/>
                Then tack to starboard and sail ${analysis.laylines.starboardTackHeading.toFixed(0)}¬∞<br/>
                at ${pointingAngle}¬∞ TWA to reach mark
            `);
            
            console.log(`üìê Laylines drawn: Port ${portLaylineHeading.toFixed(0)}¬∞, Stbd ${stbdLaylineHeading.toFixed(0)}¬∞ from mark at ${markLat.toFixed(4)}, ${markLon.toFixed(4)}`);
        }

        function clearMarks() {
            manualMarks = [];
            markMode = null;
            if (map) {
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker) {
                        map.removeLayer(layer);
                    }
                });
                document.getElementById('map').classList.remove('clickable');
                // Re-render the map to restore maneuver markers
                initMap();
            }
        }

        function clearStartLine() {
            startLinePins = [];
            if (map) {
                // Remove start line polyline
                if (startLinePolyline) {
                    map.removeLayer(startLinePolyline);
                    startLinePolyline = null;
                }
                // Remove start pin markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer.options.icon?.options?.className === 'start-pin') {
                        map.removeLayer(layer);
                    }
                });
                // Hide clear line button
                document.getElementById('clearStartLine').style.display = 'none';
                console.log('üìè Start line cleared');
            }
        }

        function clearFinishLine() {
            finishLinePins = [];
            if (map) {
                // Remove finish line polyline
                if (finishLinePolyline) {
                    map.removeLayer(finishLinePolyline);
                    finishLinePolyline = null;
                }
                // Remove finish pin markers
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer.options.icon?.options?.className === 'finish-pin') {
                        map.removeLayer(layer);
                    }
                });
                // Hide clear line button
                document.getElementById('clearFinishLine').style.display = 'none';
                console.log('üèÅ Finish line cleared');
            }
        }

        // Mobile menu toggle
        function setupMobileMenu() {
            const menuBtn = document.getElementById('mobileMenuBtn');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('mobileOverlay');
            
            if (!menuBtn || !sidebar || !overlay) return;
            
            function toggleMenu() {
                sidebar.classList.toggle('open');
                overlay.classList.toggle('active');
            }
            
            function closeMenu() {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
            }
            
            menuBtn.addEventListener('click', toggleMenu);
            overlay.addEventListener('click', closeMenu);
            
            // Close menu when clicking a link/button in sidebar
            sidebar.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'A') {
                    setTimeout(closeMenu, 300); // Delay to allow action to complete
                }
            });
        }

        window.onload = initApp;
        
        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('‚úÖ Service Worker registered successfully:', registration.scope);
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60000); // Check every minute
                    })
                    .catch(err => {
                        console.log('‚ùå Service Worker registration failed:', err);
                    });
            });
        }
    </script>
</body>
</html>
